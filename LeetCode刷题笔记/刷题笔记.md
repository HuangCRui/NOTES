# 树



## 110.平衡二叉树



**提前阻断**  O(N)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
       return traverse(root) != -1;
    }

    public int traverse(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = traverse(root.left);
        if(left == -1){
            return -1;
        }
        int right = traverse(root.right);
        if(right == -1){
            return -1;
        }

        return Math.abs(right - left) < 2 ? Math.max(right, left) + 1 : -1;//最大高度+1
    }
}
```

先进行左递归 求左子树的高度

再进行右递归 

return  对左右的值进行判断  求出高度，作为父节点的  left / right  向上返回 

若子树不平衡，到了父节点left / right == -1 **代表有一侧已经不平衡了**  直接一路向上返回至 root

![image-20201009173946463](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201009173946463.png)



和上面一样...  区别是在哪 +1

```java
class Solution {
    boolean flag = true;
    public boolean isBalanced(TreeNode root) {
        depth(root);
        return flag;
    }
    
    public int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = depth(root.left) + 1;
        int right = depth(root.right) + 1;
        if(Math.abs(left - right) > 1){
            flag = false;
        }
        return Math.max(left, right);
    }
}
```





---

暴力法

时间复杂度 O(Nlog2 N)： 

最差情况下， isBalanced(root) 遍历树**所有节点**，占用 O(N) ；判断每个节点的最大**高度** depth(root) 需要遍历 **各子树**的**所有节点** ，子树的节点数的复杂度为 O(log_2 N) 。
空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。



```java
public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
       return isBalanced(root.left) && isBalanced(root.right) && Math.abs(depth(root.left) - depth(root.right)) < 2;
    }
    
    public int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
```





##  589. N叉树的前序遍历



```java
class Solution {
    List<Integer> pre = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        PreOdr(root);
        return pre;
    }

    public void PreOdr(Node root){
        if(root == null){
            return;
        }
        pre.add(root.val);

        for(Node child : root.children){
            PreOdr(child);
        }
        return;
    }
}
```



迭代：

**用Stack结构  push的时候需要将children的顺序反过来，才能做到peek的是最左侧的子结点**



```java
class Solution {
    List<Integer> pre = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        Stack<Node> stack = new Stack<>();
        if(root == null){
            return pre;
        }
        stack.push(root);

        while(!stack.isEmpty()){
            Node father = stack.peek();
            stack.pop();
            pre.add(father.val);
            Collections.reverse(father.children);
            for(Node child : father.children){
                stack.push(child);
            }
        }
        return pre;
    }
}
```





##  特定深度节点链表





```java
class Solution {
    public ListNode[] listOfDepth(TreeNode root) {
         Queue<TreeNode> queue = new LinkedList<>();
        //数组每个元素是一个链表的第一个节点
        ListNode[] list = new ListNode[depth(root)];
        TreeNode father = queue.poll();
        queue.offer(root);
        ListNode head = new ListNode(0);
        int index = 0;
        while(!queue.isEmpty()){
            int size = queue.size();
            ListNode curr = head;
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                curr.next = new ListNode(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                //curr结点始终指向链表的最后一个节点
                curr = curr.next;
            }
            list[index++] = head.next;
            head.next = null;
        }

        return list;
    }

    //其实不必如此，用List.toArray()也可以转为数组  
    //求出该二叉树最大深度
    public int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = depth(root.left) + 1;
        int right = depth(root.right) + 1;
        return Math.max(left, right);
    }
}
```







## 102. 二叉树的层序遍历



```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> l1 = new ArrayList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();
        //注意进行判断  可能会出现nullpointerexception  (node.val)
        if(root != null){
            queue.offer(root);
        }
        while(!queue.isEmpty()){
            List<Integer> l2 = new ArrayList<>();
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                l2.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }
            l1.add(l2);
        }
        return l1;
    }
}
```





## 94.二叉树的中序遍历



**递归：**

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        Recur(root);
        return list;
    }
    public void Recur(TreeNode root){
        if(root == null){
            return;
        }
        Recur(root.left);
        list.add(root.val);
        Recur(root.right);
        return;
    }
}
```





### 颜色标记法：

访问过的节点记为 **灰色**  没访问过的是 **白色** 

每次**弹出**栈顶pop()   

- 如果是白色，**依次将右  自己  左**入栈， **自己记为灰色** 
- 如果是灰色，出栈 记录val

始终保持 **左 中 右的顺序  需要在每次碰到一个节点时，先将自己弹出 再把子节点  *按顺序* 加进去，**



**中序：左 中 右    *反着*入栈**

**前序 后序同理**

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((GRAY, node))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        return res
```



优化：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<Object> s = new Stack<>();
        if(root == null){
            return list;
        }
        s.push(root);
        while(!s.isEmpty()){
            Object o = s.pop();
            if(o instanceof TreeNode){
                TreeNode node = (TreeNode)o;
                if(node.right != null){
                    s.push(node.right);
                }
                s.push(node.val);
                if(node.left != null){
                    s.push(node.left);
                }
            }else{
                list.add((int)o);
            }
        }
        return list;
    }
}
```





## 530.二叉搜索树的绝对最小差&783. 二叉搜索树节点最小距离





**先明白一点：二叉搜索树的中序遍历结果->**就是一个**有序的**list  将其转换为数组来求**相邻位置**最小差值即可

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int getMinimumDifference(TreeNode root) {
        recur(root);
        Integer[] arr = list.toArray(new Integer[list.size()]);
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < arr.length - 1; i ++){
            if(Math.abs(arr[i] - arr[i + 1]) < min){
                min = Math.abs(arr[i] - arr[i + 1]);
            }
        }
        return min;
    }
    public void recur(TreeNode root){
        if(root == null){
            return;
        }
        recur(root.left);
        list.add(root.val);
        recur(root.right);
        return;
    }
}
```





## 897. 递增顺序查找树

```java
class Solution {
    List<TreeNode> list = new ArrayList<>();
    public TreeNode increasingBST(TreeNode root) {
        recur(root);
        TreeNode[] inOrder = list.toArray(new TreeNode[list.size()]);
        inOrder[0].left = null;
        for(int i = 1; i < inOrder.length; i++){
            inOrder[i-1].right = inOrder[i];
            inOrder[i].left = null;
        }
        return inOrder[0];


    }
    public void recur(TreeNode root){
        if(root == null){
            return;
        }
        recur(root.left);
        list.add(root);
        recur(root.right);
        return;
    }
}
```







## 剑指 Offer 54. 二叉搜索树的第k大节点



```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        Recur(root);
        return list.get(list.size()-k);
    }

    public void Recur(TreeNode root){
        if(root == null){
            return;
        }
        Recur(root.left);
        list.add(root.val);
        Recur(root.right);
        return;
    }
}
```



## 116. 填充每个节点的下一个右侧节点指针





---

BFS层序遍历



记录前一个节点pre，如果pre是null，说明这是新的一层的遍历，第一个节点。

遍历这一层后面的节点时 需要使pre.next = cur

（也可以将每个节点的next设置成queue.peek(),在每轮结束的时候将最后一个节点`pre.next = null`）

```java
class Solution {
    public Node connect(Node root) {
        Queue<Node> q = new LinkedList<>();
        if(root == null) return root;
        q.offer(root);
        while(!q.isEmpty()){
            int size = q.size();
            Node n = null;
            for(int i = 0; i < size; i++){
                n = q.poll();
                if(!q.isEmpty()){
                    n.next = q.peek();
                }
                if(n.left != null){
                    q.offer(n.left);
                }
                if(n.right != null){
                    q.offer(n.right);
                }
            }
            n.next = null;
        }
        return root;
    }
}
```

使用队列 效率低 需要不停入队出队





---

链表法

![image-20201016124446572](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201016124446572.png)

对于 cur这一行的节点 把每个都遍历一遍  将其**子节点串在一起**

遍历完一行后，cur节点变为下一行的第一个节点 即：dummy.next



**访问当前层的节点，把下一行的节点串起来**

```java
class Solution {
    public Node connect(Node root) {
        if(root == null) return root;

        Node cur = root;
        while(cur != null){
            //开始新的一行的遍历cur  为下一行重新建立dummy和pre
            //cur继承自上次遍历
            Node dummy = new Node(0);
            Node pre = dummy;

            //因为是完美二叉树，如果有左子节点就一定有右子节点
            while(cur != null && cur.left != null){
                pre.next = cur.left;
                pre = pre.next;

                pre.next = cur.right;
                pre = pre.next;

                cur = cur.next;
            }

            cur = dummy.next;
        }

        return root;
    }
}
```

---

递归解法

将右边节点和右边相邻子树的左节点联系到一起

**主要就是最靠右的一排节点的next不好处理**

```java
public Node connect(Node root) {
    dfs(root, null);
    return root;
}

private void dfs(Node curr, Node next) {
    if (curr == null)
        return;
    curr.next = next;
    dfs(curr.left, curr.right);
    dfs(curr.right, curr.next == null ? null : curr.next.left);
}
```

























# 链表





## 206. 反转链表



**栈**：  “先进后出”

代码略...



**递归解法**   当前节点的next节点   同一个子问题

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode reverse = reverseList(head.next);
        head.next.next = head;
        //避免链表出现  环
        head.next = null;
        return reverse;
    }
}
```





**顺序**解

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode prev = null;
        ListNode temp = null;
        while(cur != null){
            //要将当前cur.next指向上一个节点  记录下next
            temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;
    }
}
```

![image-20201018182051004](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201018182051004.png)















## 143. 重排链表



存储

用 **栈 / 线性表 都可以实现**

```java
class Solution {
    public void reorderList(ListNode head) {
        //又忘了空数据的情况了...... 0/1/2个结点都直接返回。。
        if(head == null || head.next == null || head.next.next == null){
            return;
        }
        Stack<ListNode> s = new Stack<>();
        ListNode cur = head;
        while(cur != null){
            s.push(cur);
            cur = cur.next;
        } 
        cur = head;
        ListNode next = null;

        while(s.peek() != next){
            //System.out.println(cur.val);
            next = cur.next;
            if(s.peek() == next){
                cur.next = next;
                break;
            }
            cur.next = s.pop();
            cur = cur.next;
            //System.out.println(cur.val);
            if(s.peek() == next){
                cur.next = next;
                break;
            }
            //环
            cur.next = next;
            cur = cur.next;
        }
        next.next = null;
        return;
    }
}
```

![image-20201023211757518](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201023211757518.png)



真的慢。。入栈出栈费时

---



递归解法

问题就是取尾元素的时候，**需要遍历一遍链表**。

如果我们的递归函数能够**返回当前头元素对应的尾元素**，并且将头元素和尾元素之间的链表按要求完成，那就变得简单了。

![image-20201023214048916](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201023214048916.png)

我们只需要将 `head` 指向 `tail`，`tail` 指向处理完的链表头即可。

![image-20201023214109626](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201023214109626.png)

把之前的 `tail.next`   (框里面的内层tail)   返回就是外层 `head` 对应的 `tail` 了。



**递归出口**：

- 如果**只有一个节点**，那么我们只需要将 **`head.next` 返回**。

- 如果是两个节点，我们需要将 `head.next.next` 返回。



无需递归到尾结点！

通过len记录   奇数偶数个结点分情况

- 奇数：  l = 1 

- 偶数：  l = 2  **最中间的两个元素的顺序是不改变的，直接返回head.next.next作为returnTail**

  在这一层的外层，head.next指向的是里面一层的head，这时：

  - 令nextHead = head.next;  head.next = tail; 这一层的头节点指向内一层返回的returnTail，（**同时记录并返回这一层的returnTail**）然后内一层返回的returnTail指向nextHead 

每一层需要返回**外面一层**的tail节点，也就是  `return  当前层tail.next`



```java
class Solution {
    public void reorderList(ListNode head) {

        if(head == null || head.next == null || head.next.next == null){
            return;
        }

        int len = 0;
        ListNode l = head;
        while(l != null){
            l = l.next;
            len++;
        }
        reOrder(head, len);

    }
    public ListNode reOrder(ListNode head, int len){
        if(len == 1){
            ListNode returnTail = head.next;
            head.next = null;
            return returnTail;
        }
        if(len == 2){
            ListNode returnTail = head.next.next;
            head.next.next = null;
            return returnTail;
        }
        ListNode tail = reOrder(head.next, len - 2);
        ListNode nextHead = head.next;//上一层 (中间)链表的头结点
        head.next = tail;
        ListNode returnTail =  tail.next;//返回上一层head对应的tail
        tail.next = nextHead;
        return returnTail;
    }
}
```





![image-20201024202611534](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024202611534.png)



---

利用取一头一尾的特性

```java
class Solution {
    public void reorderList(ListNode head) {
        // 一个或者两个结点 都无需进行重排
        if (head == null || head.next == null || head.next.next == null) {
            return;
        }
        //快慢指针找中点
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;fast = fast.next.next;
        }
        ListNode newhead = slow.next;
        slow.next = null;
        //反转链表
        newhead = reverse(newhead);

        while(newhead != null){
            ListNode temp = newhead.next;
            newhead.next = head.next;
            head.next = newhead;

            head = newhead.next;
            newhead = temp;
        }
    }

    public ListNode reverse(ListNode head){
        ListNode prev = null, next = null, temp = null;
        while(head != null){
            next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```



















## 21. 合并两个有序链表





**巧妙使用dummy节点  和  cur节点**

- dummy***哑结点***作为新起的链表的head，不动
- cur***游标***指向合并链表的最后一个节点的位置，负责加入新结点

> 有点死板....想着在原先的基础上把他们合并。有点难度  操作太复杂

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0), cur = dummy;
        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        //这一步比较重要
        //如果哪个链表
        cur.next = l2 != null ? l2 : l1;
        
        return dummy.next;
    }
}
```





---

**递归解法**



- **终止条件**：两个链表都为空，对链表的合并已经完成

- 如何递归：我们判断 `l1` 和 `l2` 头结点哪个更小，然后较小结点的 `next` 指针*<u>指向</u>*     **其余结点的<u>合并结果</u>。（调用递归）**

递归过程中，一方到null了，说明这个链表遍历完了，可以直接**连接到**另一个链表的当前遍历位置 

![image-20201022194918261](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201022194918261.png)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }
        else if(l2 == null){
            return l1;
        }

        //l1是较小的结点，后面的链表接在l1后面，
        else if(l1.val <= l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```



**复杂度分析**

- 时间复杂度：每次递归  都会去掉两个链表其中的一个结点，O(M+N), 至多只会调用每个节点一次

- 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的**长度**。递归调用 mergeTwoLists 函数时需要消耗**栈空间**，栈空间的大小**取决于递归调用的深度**。结束递归调用时 mergeTwoLists 函数**最多调用 n+m 次**（**最坏条件**），因此空间复杂度为 O(n+m)。

















# 双指针







## 19. 删除链表的倒数第N个节点



```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        ListNode tem = dummy;
        dummy.next = head;
        Stack<ListNode> s = new Stack<>();
        while(tem != null){
            s.push(tem);
            tem = tem.next;
        }
        
        for(int i = 0; i <= n; i++){
            head = s.pop();
        }
        head.next = head.next.next;
        return dummy.next;
    }
}
```



```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        List<ListNode> l = new ArrayList<>();
        ListNode dummy = new ListNode(0);
        ListNode tem = dummy;
        dummy.next = head;
        while(tem != null){
            l.add(tem);
            tem = tem.next;
        }
        tem =  l.get(l.size() - n - 1);
        tem.next = tem.next.next;
        return dummy.next;
    }
}
```

---

**双指针**

**dummy节点堪称一绝！！！**

**从dummy开始  防止越界**

保持slow和fast之间隔了n个节点  在fast到达null时，slow.next就是要删掉的



```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        ListNode tem = dummy;
        dummy.next = head;
       //也可以使用一个pre节点 从dummy开始 slow和fast相隔n-1个节点 pre.next = slow.next;
       ListNode slow = dummy;
       ListNode fast = dummy;
       for(int i = 1; i <= n + 1; i++){
           fast = fast.next;
       }

       while(fast != null){
           slow = slow.next;
           fast = fast.next;
       }
       slow.next = slow.next.next;
       return dummy.next;
    }
}
```





## 844. 比较含退格的字符串



```java
class Solution {
    public boolean backspaceCompare(String S, String T) {

        char[] s = S.toCharArray(), t = T.toCharArray();
        int i = s.length - 1, j = t.length - 1, m = 0, n = 0;


        //有一方可能已经到了-1  另一边有可能  还需要遍历一次把#能抵消的抵消完
        //b a##b
        while(i > -1 || j > -1){
        //先把两个字符串的#和可以退格的字符都处理了，再比较"干净的"字符串    
            
           while(i >= 0){
               if(s[i] == '#'){
                   m++;i--;
               }
               //碰到字符时：如果还有没用完的 #退格 就先把这个字符退了
               else if(m > 0){
                   m--;i--;
               }else{
                   //是字符  且  m==0
                   break;
               }
           }

           while(j >= 0){
               if(t[j] == '#'){
                   n++;j--;
               }
               else if(n > 0){
                   n--;j--;
               }else{
                   //是字符  且  n==0
                   break;
               }
           }
//如果能匹配成功，必然不会两个中有一个索引到了-1,每一轮不被抵消的字符都应该能匹配到

           if(i > -1 && j > -1){
               if(s[i] != t[j]){
                   return false;
               }
           }else{
               // 有一个串 遍历完了到了-1  另一个在经历了"多一轮"#退格扫描后，还有剩余的  --没有被#退格掉-- 的字符
               if(i > -1 || j > -1){
                   return false;
               }
           }
           i--;j--;

        }
        return true;

    }
}
```







## 876. 链表的中间结点





```java
class Solution {
    public ListNode middleNode(ListNode head) {
        if(head.next == null){
            return head;
        }
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        //偶数节点fast会停在倒数第二个  
        //奇数节点fast会直接到结尾
        if(fast.next != null){
            return slow.next;
        }
        return slow;
    }
}
```





## 763. 划分字母区间



**贪心**



**字母最后位置信息可以使用数组来保存(char)**



> 同一个字母只会出现在其中一个片段

遍历字符串 先确定每个字母最后出现的位置。



- 从头开始扫描 双指针begin end.

- **end记录扫描过程中遇到的字符 <u>*最后*</u> 出现的位置**  需要一直保持更新状态，记录max_end
- 如果遍历 i 到了end位置，就说明  **沿途中再没有字符最后出现的位置 >= end，此时这个end就可以作为分界点**
- end & begin = end + 1 开始新的一轮扫描  （**这后面的字符都是前面从没出现过的**）

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        int[] last = new int[26];
        List<Integer> res = new ArrayList<>();
        char[] s = S.toCharArray();

        //存储每个字符最后出现的位置
        for(int i = 0; i < s.length; i++){
            last[s[i] - 'a'] = i;
        }
        int begin = 0, end = 0;
        for(int i = 0; i < s.length; i++){
            end = Math.max(last[s[i] - 'a'], end);
            if(i == end){
                res.add(end - begin + 1);
                begin = end + 1;
                end = begin;
            }
        }

        return res;
    }
}
```





## 234. 回文链表

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null){
            return true;
        }
        //使用快慢指针取链表的中点 
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode newhead = slow.next;
        //反转后半个链表
        newhead = reverse(newhead);
        //如果链表结点数为奇数，则只比较后半个链表结点的值，中间的结点无须比较
        while(newhead != null){
            if(newhead.val == head.val){
                newhead = newhead.next;
                head = head.next;
            }else{
                return false;
            }
        }
        return true;
    }
    //反转链表
    public ListNode reverse(ListNode head){
        ListNode cur = head, prev = null, next = null;
        while(cur != null){
            next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```











## 925. 长按键入



脑瘫晚期做法.......

```java
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        char[] n = name.toCharArray(), t = typed.toCharArray();
        int i = 0, j = 0;
        //直到typed判断完了并且越界了，结束
        while(j != t.length){
            
            //typed用完了  name没用完  匹配失败
            if(j == t.length - 1 && i < n.length - 1){
                return false;
            }
            //name用完  typed没用完，可能还有重复输入
            if(i == n.length - 1 && j <= t.length - 1){
                if(n[i] == t[j]){
                    j++;
                    continue;
                }else{
                    return false;
                }
                
            }
            
            if(n[i] == t[j]){
                if(i < n.length-1 && n[i + 1] == n[i]  ){
                    i++;j++;
                }else if(j < t.length-1 && t[j] == t[j + 1]){
                    j++;
                }else{
                    i++;j++;
                }
            }else{
                return false;
            }
            
            
        }
        return true;
    }
}
```



**妙啊......**

**方向错了，应该用type来匹配name，而不是name来匹配type**.....懂的都懂

- type[j]可以和name[i]匹配上
- type[j]没法匹配name[i]，但和type[j - 1]相等，**则认为他是长按的**
- false



type **按理来说长度 >= name**

当*typed* 扫描完毕后，我们再检查*name* 的每个字符是否都被「匹配」了。

最后，如果 **i=name.length**，说明 name 的每个字符都被「匹配」了。

```java
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        int i = 0, j = 0;
        char[] a = name.toCharArray(), b = typed.toCharArray();
        while(j < b.length){
            if(i < a.length && a[i] == b[j]){
                i++;j++;
            }else if(j > 0 && b[j] == b[j - 1]){
                j++;
            }else{
                return false;
            }
        }

        return i == a.length;
    }
}
```







## 845. 数组中的最长山脉



```java
class Solution {
    public int longestMountain(int[] A) {
        int i = 0, j = 0, num = 0, maxi = 0, max_len = 0;

        while(j < A.length){

            //有一个increaseing
            if(j < A.length - 1 && A[j + 1] > A[j]){
                while(j < A.length - 1 && A[j + 1] > A[j]){
                    j++;
                    maxi = j;
                }
                
                //至少有一步下降，可以形成完整山脉  /  存在上升近阶段
                if(j < A.length - 1 && maxi != i && A[j + 1] < A[j]){
                    while(j < A.length - 1 && A[j + 1] < A[j]){
                        j++;
                    }
                    //记录长度 将下一轮的开始位置设置为当前j，(可能作为下一个山脉的beginning)
                    max_len = Math.max(max_len, j - i + 1);
                    //System.out.println(i + "  " + j);
                    i = j; maxi = i;
                }
                //没有下降阶段  /  没有第一步上升阶段
                else{
                    i = j + 1;j = j + 1; maxi = i;
                }
            }
            //开始就降低或者相等
            else{
                i += 1;j += 1;
            }  
        }
        return max_len;
    }
}
```



```java
class Solution {
public int longestMountain(vector<int>& A) {
        int maxLength = 0;
        int i = 1;
        
        //只有一开始就上升才有效
        while (i < A.size()) {
            int increasing = 0, decreasing = 0;
            
            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;
            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;
            
            if (increasing > 0 && decreasing > 0) 
                maxLength = max(maxLength, increasing + decreasing + 1);//少算一个 开头的数 
            
            //处理连续的相同值，跳过，不符合题目要求
            while(i < A.size() && A[i - 1] == A[i]) i++;
        }
        return maxLength;
    }
}
```









# 动态规划



## 1024. 视频拼接

动态规划：

用过的片段，会影响之后对片段的选用，**过去的状态影响当前状态**，有 DP 的味儿了。



定义 `dp[j]`，表示：**覆盖 `[0, j]`区间的最少片段数**，题目是**求 `dp[T]`**



**dp的思想是能少用就少用  尽量把当前这个区间*<u>用完</u>*，再换下一个可用的区间**



```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] dp = new int[T + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        //空区间的初始值为0
        dp[0] = 0;

        for(int i = 1; i <= T; i++){
            for(int[] clip : clips){
                if(i <= clip[1] && i > clip[0]){
                    //遍历每个区间，区间开始的地方数量+1  
                    //取最少的
                    //就是要把每个区间榨干......
                    //如果过了上个使用的区间的右边界，对于新的一个区间
                    //从新区间的左边界位置dp[clip[0]] + 1
                    //那个左边界位置可以保证是最小的数量
                    dp[i] = Math.min(dp[clip[0]] + 1, dp[i]);
                }
            }
        }
        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];
    }
}
```

![image-20201024230632811](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024230632811.png)

时间复杂度：O(T*N)   其中T是区间的长度  N是子区间的数量

慢！

空间复杂度：O(T)



---

贪心：

```java
//贪心思想  始终走到最远的位置，最大化使用前面的区间
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] rec = new int[T];
        int max = 0, pre = 0, res = 0;
        for(int[] clip : clips){
            if(clip[0] < T){
                rec[clip[0]] = Math.max(rec[clip[0]], clip[1]);
            }
        }

        for(int i = 0; i < T; i++){
            //max代表在i位置前   单个  区间  能达到的最远距离
            max = Math.max(max, rec[i]);
            //如果在i位置，max不能比i大？那就只能遍历到这了
            //如果max > i,表示还可以再往前走一走
            if(i == max){
                return -1;
            }
            //pre 记录 上一个 被使用 的 子区间的  结束 位置
            //i == pre 表示上一个子区间已经用完了，并且(max > i)，还能再往前走，结果数量+1
            //将pre 更新为当前使用的区间的max(能走的最远距离)
            if(i == pre){
                res++;
                pre = max;
            }
        }
        return res;
    }
}
```

![image-20201024220031239](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024220031239.png)

时间复杂度：O(T + N)

空间复杂度：O(T)





## 53.最大子序和



**dp解法**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //以当前位nums[i]结尾时  的  最大子序和
        int max = nums[0];
        
        for(int i = 1; i < nums.length; i++){
            nums[i] = Math.max(nums[i] + nums[i - 1], nums[i]);    
            max = Math.max(max, nums[i]);
        }
        return max;
    }
}


//也可以使用pre代替当前计算dp[i]的结果
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```













# 其他类型





## 1207. 独一无二的出现次数

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        int[] help = new int[2002];
        Arrays.fill(help, 0);

        for(int i = 0; i < arr.length; i++){
            help[arr[i] + 1000] ++;
        }
        int sum = 0;
        for(int i = 0; i < help.length; i++){
            if(help[i] != 0){
                sum++;
            }
        }
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < help.length; i++){
            if(help[i] != 0){
                set.add(help[i]);
            }
            
        }
        //将出现次数不为0的 次数 存入set中，(set中的数不重复)，如果数量和sum不同，说明有重复的出现次数
        return set.size() == sum;
    }
}
```





**更快**

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < arr.length; i++){
            map.put(arr[i], map.getOrDefault(arr[i], 0)+1);
        }
        return map.size() == new HashSet<>(map.values()).size();
    }
}
```



**set中只能存放不同的数据**

```java
 if (!set.add(value))//如果存储失败，说明有重复的
     return false;
```





## 242. 有效的字母异位词



**长度为26的数组记录每个字母出现的次数**   

逐字母比较   两个String是否存在哪一个字母的次数不同

钻个空子罢了....

≈哈希表

```java
class Solution {
    public boolean isAnagram(String ss, String tt) {
        int[] bucket1 = new int[26], bucket2 = new int[26];
        Arrays.fill(bucket1, 0);
        Arrays.fill(bucket2, 0);
        char[] s = ss.toCharArray(), t = tt.toCharArray();

        for(int i = 0; i < s.length; i++){
            bucket1[(int)(s[i] - 'a')]++;
        }
        for(int i = 0; i < t.length; i++){
            bucket2[(int)(t[i] - 'a')]++;
        }

        //人傻了 多扫了一遍
        for(int i = 0; i < bucket1.length; i++){
            if(bucket1[i] != bucket2[i]){
                return false;
            }
        }
        return true;
    }
}

//最简单写法
class Solution {
    public boolean isAnagram(String ss, String tt) {
        //先比较长度，如果不相等直接返回，也是避免后面出现减完后还有字符剩余的情况
        if (s.length() != t.length()) {
            return false;
        }
        char[] s = ss.toCharArray(), t = tt.toCharArray();
        int[] table = new int[26];
        for (int i = 0; i < s.length; i++) {
            table[s[i] - 'a']++;
        }
        //若有 个数不一样 的字符出现，就会出现 <0 -> false
        for (int i = 0; i < t.length; i++) {
            table[t[i] - 'a']--;
            if (table[t[i] - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
}
```



**说明:**
你可以假设字符串只包含小写字母。

**进阶:**
如果输入字符串**包含 unicode 字符**怎么办？你能否调整你的解法来应对这种情况？



---

**排序  稳！**  时间O(nlongn)  空间O(logn)  **递归复杂度**

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        char[] str1 = s.toCharArray();
        char[] str2 = t.toCharArray();
        Arrays.sort(str1);
        Arrays.sort(str2);
        return Arrays.equals(str1, str2);
    }
}。
```







---

对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，**它为每个语言中的字符规定了一个唯一的二进制编码**。而 **Unicode中可能存在一个字符对应多个字节**的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和UTF-16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。

回到本题，进阶问题的核心点在于「字符是**离散未知**的」，因此我们用**哈希表维护对应字符的频次**即可。同时读者需要注意Unicode一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。



















# 排序





## 1365. 有多少小于当前数字的数字

**快排 + 映射**



记录每一个数在**<u>原数组中的位置</u>**。对于排序后的数组中的每一个数，我们找出其左侧第一个小于它的数，这样就能够知道数组中小于该数的数量

```java
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int n = nums.length;
        //映射  原位置
        int[][] data = new int[n][2];
        for (int i = 0; i < n; i++) {
            data[i][0] = nums[i];
            data[i][1] = i;
        }
        Arrays.sort(data, new Comparator<int[]>() {
            public int compare(int[] data1, int[] data2) {
                return data1[0] - data2[0];//排序规则
            }
        });

        int[] ret = new int[n];
        int prev = -1;
        for (int i = 0; i < n; i++) {
            //i=0时防止越界
            //出现重复的数，使用上一个数的值，不再对prev进行更新。
            if (prev == -1 || data[i][0] != data[i - 1][0]) {
                prev = i;
            }
            
            ret[data[i][1]] = prev;
        }
        return ret;
    }
}
```



---



**计数排序**

```java
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        

        int[] fre = new int[101], res = new int[nums.length];
        Arrays.fill(fre, 0);

        //将数装到桶中
        for(int i : nums){
            fre[i]++;
        }
        //对每个数出现的频率从小到大累加
        for(int i = 1; i < fre.length; i++){
            fre[i] = fre[i - 1] + fre[i];
        }
        //比这个数小的个数 --比他小的--  fre下标nums[i]-1
        for(int i = 0; i < res.length; i++){
            if(nums[i] > 0){
                res[i] = fre[nums[i] - 1];
            }
        }
        return res;
    }
}
```

> 考这样一个问题：全国高考考生(大量元素)按成绩(0-750)排名问题
> 如何排序，可参考计数排序——特殊的桶排序
> 计数排序
> 大体思想：扫描一遍所有人，按分数分到不同给的桶里，桶内无需再排序，仅需统计各桶内数量
> 适用性：数据量大、数据范围不大的情况
> 假设数据已排序如 [748, 748, 747, ..., 730, 730, ..., 730, 729, ...]
> 问：有多少人在 729 前面？（同分同名次，如 747 是第三名，没有第二名）
> 答：即 第一个 729 的索引











## 148. 排序链表



**归并排序**



![image-20201121202200034](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201121202200034.png)

合并 merge 环节： 

将两个排序链表合并，转化为一个排序链表。
**双指针法**合并，建立**辅助ListNode h 作为头部**。
设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。
返回辅助ListNode h 作为头部的下个节点 h.next。
时间复杂度 O(l + r)，l, r 分别代表两个链表长度。





> **细节：**
>
> - slow.next = null;  将链表切成两段，后面才能操作
>
> - 只有一个head时递归到终点，返回
> - tummy头节点 作为输出链表的头，串在其后
> - 其中一个链表为null后，直接将另一个非空的链表接在后面√



```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        //快慢指针找中点
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode temp = slow.next;
        slow.next = null;//将链表切成两段

        ListNode left =  sortList(head);
        ListNode right =  sortList(temp);

        ListNode tummy = new ListNode(0);
        ListNode res = tummy;
        //归并left right两个链表
        while(left != null && right != null){
            if(left.val >= right.val){
                tummy.next = right;
                right = right.next;
            }else{
                tummy.next = left;
                left = left.next;
            }
            tummy = tummy.next;
        }
        //将剩余部分拼接过来
        tummy.next = left == null ? right : left;
        return res.next;
    }
}
```

对数组做归并排序的空间复杂度为 O(n)O(n)，分别由新开辟数组O(n)O(n)和递归函数调用O(logn)O(logn)组成，而根据链表特性：

数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；
递归额外空间：递归调用函数将带来O(logn)O(logn)的空间复杂度，因此若希望达到O(1)O(1)空间复杂度，则不能使用递归。



对于链表无需数组空间，只需要



**时间O(NlogN)  **

**空间O(logN)**





---



**从底至顶归并排序**



merge单元大小：intv = 1, 2, 4.......

将链表切分为不同长度的单元  再合并



仅根据intv来计算每个单元边界，并完成链表的每轮排序合并



![image-20201125155516161](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201125155516161.png)



- 统计链表长度`length`，用于通过判断`intv < length`判定是否完成排序；

- 执行排序合并时，需要一个辅助节点作为头部，而`res`则作为链表头部排序合并时的辅助头部`pre`；后面的合并排序可以将上次合并排序的尾部`tail`用做辅助节点。



时间复杂度**O(nlogn)**，空间复杂度**O(1)**。

```java
/*
每一对需要merge的分链表的 头结点都有 引用h1 h2，也无需进行什么措施。

h是在合并之前就指在了下一对的位置，(或者null)但merge过后的res开头的链表不一定和h正好连着，(也有一定可能，刚好后面一条链表没有用完，整个接在了pre的后面)

否则如果右边的链表用完了，就没有指针引用指向h节点了。所以需要将pre节点指向merge过后的尾部，并且pre.next = h;
*/
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        int length = 0, interval = 1;
        ListNode h = head;
        while(h != null){
            length++;
            h = h.next;
        }
        ListNode res = new ListNode(0);
        res.next = head;

        while(interval < length){
            //每轮merge从头结点开始
            h = res.next;
            ListNode pre = res;

            //merge一轮 直到h走完这条链表
            while(h != null){
                ListNode h1 = h, h2;
                int i = interval;
                //i
                while(i > 0 && h != null){
                    h = h.next; i--;
                }
                //如果还剩的有i，说明已经到链表结尾了。无法完成形成两个链表，只能形成第一个
                if(i > 0) break;

                h2 = h;i = interval;
                while(i > 0 && h != null){
                    h = h.next; i--;
                }
                //第二条链表的长度可以不为interval，可以短一点
                int c1 = interval, c2 = interval - i;

                while(c1 > 0 && c2 > 0){
                    if(h1.val < h2.val){
                        //pre作为头节点  来进行每一次的归并操作
                        pre.next = h1;
                        h1 = h1.next;
                        c1--;
                    }else{
                        pre.next = h2;
                        h2 = h2.next;
                        c2--;
                    }
                    pre = pre.next;
                }
                pre.next = c1 > 0 ? h1 : h2;
                
                //将pre移动到这一组merge的最后一个节点的位置
                while(c1 > 0 || c2 > 0){
                    pre = pre.next;
                    c1--;c2--;
                }
                //将pre.next连接上下一组节点的开头，即：h
                pre.next = h;
            }
            interval *= 2;
        }
        return res.next;
    }
}
```









## 1370. 上升下降字符串



```java
class Solution {
    public String sortString(String ss) {
        char[] s = ss.toCharArray();
        //每个桶中装着
        int[] bucket = new int[26];
        for(int i = 0; i < s.length; i++){
            bucket[s[i] - 'a'] ++;
        }

        StringBuffer sb = new StringBuffer();
        while(sb.length() != s.length){

            for(int i = 0; i < 26; i++){
                if(bucket[i] > 0){
                    sb.append((char)('a' + i));
                    bucket[i]--;
                }
            }
            for(int i = 25; i >= 0; i--){
                if(bucket[i] > 0){
                    sb.append((char)('a' + i));
                    bucket[i]--;
                }
            }
        }
        return sb.toString();
    }
}
```









## 164. 最大间距



---

**基数排序RadixSort**

```java
class Solution {
    public int maximumGap(int[] nums) {
        if(nums.length < 2){
            return 0;
        }
        long exp = 1;
        int max = 0;
        int[] pre = new int[nums.length];
        for(int i : nums){
            max = Math.max(i, max);
        }
        //detail：需要>=  若出现[1, 1000000] 10的次方的数，基数排序结果会是1 > 1000000
        while(max >= exp){
            int[] radix = new int[10];
            for(int i = 0; i < nums.length; i++){
                int digit = (nums[i] / (int)exp) % 10;//从个位开始依次取这一位的数排序
                radix[digit]++;
            }
            //detail：累加计数和
            for(int i = 1; i < 10; i++){
                radix[i] += radix[i - 1];
            }
            
            // 重点：从后往前遍历是为了维持前一位排序过的顺序。
            // radix[]数组累加得到：这一位的排序能排到第几。
            // 从后至前遍历：遍历到的数(通过当前位索引)也是排在后面，再将radix的计数--，
            // 下一个遍历到的这一位相同的数radix[i-1]，必定是前一位小于radix[i]的。所以维持了前一位的顺序
            for(int i = nums.length - 1; i >= 0; i--){
                int digit = (nums[i] / (int)exp) % 10;
                pre[radix[digit] - 1] = nums[i];
                radix[digit]--;
                
            }
            System.arraycopy(pre, 0, nums, 0, nums.length);
            exp *= 10;

        }
        int ret = 0;
        for (int i = 1; i < nums.length; i++) {
            ret = Math.max(ret, nums[i] - nums[i - 1]);
        }
        return ret;
    }
}
```

**时间O(N) （如果数很大，N前面有很大的系数 约为31）    **

**空间O(N)**



****

`Arrsys.sort(nums)`就完事了

快的一批



---

**桶排序**



数组长度为N  则 **(max - min)  /  (N - 1)     <=   排序后   任意相邻数的差**

<u>N个数， 有N-1个间隙，如果N-1 = max-min  则间隙均为1</u>

<u> N-1 < max-min  则会出现稍大的间隙</u>



相邻元素之间的**最大间距**一定不会出现在某个**桶的内部**，而一定会出现在**不同桶当中**。

因此，在找出每个元素所在的桶之后，我们可以维护每个桶内元素的最大值与最小值。随后，只需从前到后不断比较相邻的桶，用**后一个桶的最小值与前一个桶的最大值之差**作为两个**<u>桶的间距</u>**

```java
class Solution {
    public int maximumGap(int[] nums) {
        if(nums.length < 2){
            return 0;
        }
        int max = 0, min = Integer.MAX_VALUE;
        for(int i = 0; i < nums.length; i++){
            max = Math.max(max, nums[i]);
            min = Math.min(min, nums[i]);
        }
        int delta = max - min;
        //在右重复值的情况，会出现length >= max-min 这种情况将桶的大小设置为1就行，把重复的数装进去。
        int width = Math.max(1, delta / (nums.length - 1));
        int size = (max - min) / width + 1;

        int[][] buckets = new int[size][2];
        for(int[] bucket : buckets){
            Arrays.fill(bucket, -1);
        }

        for(int i = 0; i < nums.length; i++){
            int index = (nums[i] - min) / width;
            //桶中原先没数，就将桶中最大最小值都设为nums[i]
            if(buckets[index][0] == -1){
                buckets[index][0] = buckets[index][1] = nums[i];
            }else{
                buckets[index][0] = Math.min(buckets[index][0], nums[i]);
                buckets[index][1] = Math.max(buckets[index][1], nums[i]);
            }
        }

        //res设置为0  (可能是会出现重复？ 但又好像不考虑重复出现的情况 ) 应该可以设为1？
        //目的是找最大值.....搞错了。。不能用1  有这个测试用例[1,1,1,1]...大意了
        //相同的值会分到一个桶中，无须担心  最大值还是会出现在两个桶之间或者就是0
        int res = 0;int pre = -1;
        for(int i = 0; i < buckets.length; i++){
            if(buckets[i][0] == -1){
                continue;
            }
            //pre == -1 说明还没找到第一个有数的桶....
            //pre记录的是上一个有数字的桶
            if(pre != -1){
                res = Math.max(buckets[i][0] - buckets[pre][1], res);
            }
            pre = i;
        }
        return res;
    }
}
```













## 493. 翻转对



**不需要考虑在当前两个待合并数组内的*重要翻转对***， 因为在递归时就已经考虑过，**只需要考虑跨数组间的翻转对**

*当进行到当前两个子数组时，这两个子序列一定是**有序的***

```java
class Solution {
    public int reversePairs(int[] nums) {
        if(nums.length == 0){
            return 0;
        }
        return DevideRecursive(nums, 0, nums.length - 1);
    }

    public int DevideRecursive(int[] nums, int l, int r){
        //别忘了递归边界
        if(l == r){
            return 0;
        }
        int m = (l + r) / 2;
        int numl = DevideRecursive(nums, l, m);
        int numr = DevideRecursive(nums, m + 1, r);

        int res = numl + numr;

        //统计下标对的数量
        int i = l, j = m+1;
        while(i <= m){
            // 左右两边都已经是归并排序完成的数组  有序
            // 细节啊...   long要对nums[j]转化再进行*2  一开始没想到...(long)2*nums[j] 这样可能得到的就是个溢出的结果
            while(j <= r && (long)nums[i] > (2 * (long)nums[j]) ){
                j++;
            }
            //while停止时的j 已经没法满足条件了  右侧数组j之前的数均满足条件  res += [m + 1, j - 1].length
            res += (j-1) - (m+1) + 1;
            i++;
        }

        //随后需要合并当前两个数组
        int sorted[] = new int[r - l + 1];
        int p = 0;
        int p1 = l, p2 = m+1;
        //这个合并方法真不错.....
        while(p1 <= m || p2 <= r){
            if(p1 > m){
                sorted[p++] = nums[p2++];
            }else if(p2 > r){
                sorted[p++] = nums[p1++];
            }else{
                sorted[p++] = nums[p1] > nums[p2] ? nums[p2++] : nums[p1++];
            }
        }

        //将归并好的数组拷贝回原数组。
        System.arraycopy(sorted, 0, nums, l, sorted.length);

        return res;
    }
}
```











## 327. 区间和的个数



**利用到了归并排序的特性：**

在进行**归并操作之前**：两个数组/元素 相对于彼此是有先后顺序的，进行归并后只是合并成了母数组

**但 ！！ 母数组相对于另一个分裂开的母数组：也是有相对顺序的**



对于本题而言：

- 先求前缀和（注意下标：preSum[i]表示的是下标 < i 的数之和）
- 对前缀和进行二分递归，**每一次的比较实际上都是后面的前缀和 - 前面的前缀和，顺序并不会乱**
- 对已经处理完的两个子数组进行合并，**返回并  与上一级继续比较，** 此时上一级另一个数组也合并完成，二者(当做整体)的相对顺序没有变啊！ ***这个得理解到胃了！*** preSum[rp/lp] - preSum[i]还是子序列和，**但这个和在之前归并中没有计算到，跨两个数组的比较！**





![image-20201129224625092](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201129224625092.png)

> 细节写的像shit一样。。。
>
> 写出来之前先动脑子想想逻辑。。
>
> **要求∈[lower, upper]: **
>
> ***<u>要找刚好大于等于 lower 的位置 lp，刚好大于 upper的位置rp（也没法直接找刚好小于等于upper的位置）</u>***
>
> 才能求得包括lower 和 upper的区间

```java
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        //防止溢出
        long s = 0;
        long[] preSum = new long[nums.length + 1];
        //大bug！仔细分析！
        //前缀和 preSum[i]应该是不包括nums[i]的，是小于i的数累加得到，
        //这样作差preSum[j] - preSum[i]才会得到Sum(nums[i] ~ nums[j-1])

        //preSum[x] - preSum[0]就也相当于nums[0]累加到nums[x-1]
        //preSum[x] - preSum[1]就也相当于nums[1]累加到nums[x-1]
        for(int i = 0; i < nums.length; ++i){
            s += nums[i];
            preSum[i + 1] = s;
        }

        return count(preSum, lower, upper, 0, preSum.length - 1);
    }

    public int count(long[] preSum, int lower, int upper, int l, int r){
        //递归终止
        if(l == r){
            return 0;
        }

        //对两个子数组递归求解
        int m = (l + r) / 2;
        int sl = count(preSum, lower, upper, l, m);
        int sr = count(preSum, lower, upper, m+1, r);
        int res = sl + sr;

        int i = l, lp = m + 1, rp = m + 1; 
        //考虑到  如果rp=m+1时就已经满足条件（nums[rp] - nums[i] > upper），
        //那么则也会有lp=m+1  （肯定也满足 (nums[m+1] - nums[i] < lower)）
        //rp-lp=0 右边数组都不成立
        while(i <= m){
            //直到他们的差刚好  >=lower那个数就停
            while(lp <= r && preSum[lp] - preSum[i] < lower){
                lp++;
            }
            //差 > upper 就停 多了一位
            while(rp <= r && preSum[rp] - preSum[i] <= upper){
                rp++;
            }
            //脑瘫..rp lp写成r l了...  检查了半小时...
            res += (rp-1) - lp + 1;
            i++;
        }
        merge(preSum, l, m, r);
        return res;
    }

    public void merge(long[] preSum, int l, int m, int r){
        long[] sorted = new long[r - l + 1];

        int lp = l, rp = m + 1, i = 0;
        while(lp <= m || rp <= r){
            if(lp > m){
                sorted[i++] = preSum[rp++];
            }else if(rp > r){
                sorted[i++] = preSum[lp++];
            }else{
                sorted[i++] = preSum[lp] > preSum[rp] ? preSum[rp++] : preSum[lp++];
            }
        }
        System.arraycopy(sorted, 0, preSum, l, sorted.length);
        return;
    }
}
```









# 贪心





## 1024. 视频拼接

动态规划：

用过的片段，会影响之后对片段的选用，**过去的状态影响当前状态**，有 DP 的味儿了。



定义 `dp[j]`，表示：**覆盖 `[0, j]`区间的最少片段数**，题目是**求 `dp[T]`**



**dp的思想是能少用就少用  尽量把当前这个区间*<u>用完</u>*，再换下一个可用的区间**



```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] dp = new int[T + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        //空区间的初始值为0
        dp[0] = 0;

        for(int i = 1; i <= T; i++){
            for(int[] clip : clips){
                if(i <= clip[1] && i > clip[0]){
                    //遍历每个区间，区间开始的地方数量+1  
                    //取最少的
                    //就是要把每个区间榨干......
                    //如果过了上个使用的区间的右边界，对于新的一个区间
                    //从新区间的左边界位置dp[clip[0]] + 1
                    //那个左边界位置可以保证是最小的数量
                    dp[i] = Math.min(dp[clip[0]] + 1, dp[i]);
                }
            }
        }
        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];
    }
}
```

![image-20201024230632811](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024230632811.png)

时间复杂度：O(T*N)   其中T是区间的长度  N是子区间的数量

慢！

空间复杂度：O(T)



---

贪心：

```java
//贪心思想  始终走到最远的位置，最大化使用前面的区间
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] rec = new int[T];
        int max = 0, pre = 0, res = 0;
        for(int[] clip : clips){
            if(clip[0] < T){
                rec[clip[0]] = Math.max(rec[clip[0]], clip[1]);
            }
        }

        for(int i = 0; i < T; i++){
            //max代表在i位置前   单个  区间  能达到的最远距离
            max = Math.max(max, rec[i]);
            //如果在i位置，max不能比i大？那就只能遍历到这了
            //如果max > i,表示还可以再往前走一走
            if(i == max){
                return -1;
            }
            //pre 记录 上一个 被使用 的 子区间的  结束 位置
            //i == pre 表示上一个子区间已经用完了，并且(max > i)，还能再往前走，结果数量+1
            //将pre 更新为当前使用的区间的max(能走的最远距离)
            if(i == pre){
                res++;
                pre = max;
            }
        }
        return res;
    }
}
```

![image-20201024220031239](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024220031239.png)

时间复杂度：O(T + N)

空间复杂度：O(T)









## 55. 跳跃游戏



```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1){
            return true;
        }
        int[] max = new int[nums.length];
        max[0] = nums[0];
        for(int i = 1; i < nums.length; i++){
            max[i] = Math.max(i + nums[i], max[i - 1]);
        }

        int to = 0;
        int maxi = 0;//能到达的最远距离
        for(int i = 0; i < nums.length - 1; i++){
            maxi = Math.max(maxi, max[i]);

            if(maxi == i){
                return false;
            }

            if(i == to){
                to = maxi;
            }
        }
        return true;
    }
}
```





```java
class Solution {
    public boolean canJump(int[] nums) {
        int rightMax = 0;
        for(int i = 0; i < nums.length; i++){
            //提前结束：  如果i>rightMax  不需要再进行操作了，等着循环完事直接退出就行
            if(i <= rightMax){
                rightMax = Math.max(nums[i] + i, rightMax);

                if(rightMax >= nums.length - 1){
                    return true;
                }
            }else{
                return false;
            }
        }
        return false;
    }
}
```





## 452. 用最少数量的箭引爆气球



选择原本 **右边界最靠左的气球**  ，其他球的左边界或许不是最左的，但右边界一定更靠右。

**贪心  -->  选择右边界扎！   可以尽可能扎到多的气球**





用区间的尾部排序貌似效率会更好, 因为已经保证后面的区间右侧都是大于当前区间, 所以**将发射点设置在右侧边界**, **如果后面的区间  左边界比这个最左侧的右边界更靠左，则可以一起被扎爆**



example: [[10,16],[2,5],[3,6],[7,12]] 为例子:

先排序, 按区间结束位置排序, 排序后: [[2,5],[1, 6],[4, 11],[7,12],[10,16]]
遍历***计算交叉区间***,
**发射点**初始化为pos = 5, 需要的箭数量 arrows = 1;
区间[3, 6], 3 是小于5的, 在点5射箭可以干掉这个区间

同理[4, 11]  4 < 5 也可以干掉这个区间



> 这里注意：最终其实还是取的交集    
>
> [2, 5]  ->  [3, 5] -> [4, 5]   并且选择射入箭的位置是这个交集的最右侧（即第一个射入区间的右边界）
>
> **这样可以使得能射入尽可能多的区间**

区间[7, 12], 在5的位置射箭无法打掉, 说明需要增加一个新的发射点, 新的待发射点pos = 12
区间[10,16], 10 < 12那么在12位置射箭可以干掉它
返回需要射击点数量



**找多个集合交集内的一个点就可以，这里是找<u>*交集的右边界*</u>**

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length == 0){
            return 0;
        }

        //使用比较而不是作差....作差直接溢出！
        Arrays.sort(points, new Comparator<int[]>() {
			public int compare(int[] o1, int[] o2) {
				return o1[1] < o2[1] ? -1 : 1;
			}
		});

        //leetcode不讲武德  来骗大三的孩子  [[-2147483648,2147483647]]  
        //本来是把tem_right设为Integer.MIN_VALUE 大意了
        int num = 1, tem_right = points[0][1];
        for(int i = 0; i < points.length; i++){
            if(tem_right < points[i][0]){
                num++;
                tem_right = points[i][1];
            }
        }
        return num;
    }
}
```





---



> 和其他合并区间类的题目套路一样, 都是贪心思想, 先排序, 然后遍历检查是否满足合并区间的条件
> 这里判断是否有交叉区间, 所以其实是**计算已知区间的交集数量**.
> 这里以[[10,16],[2,8],[1,6],[7,12]] 为例子:
>
> 先排序, 我是按区间开始位置排序, 排序后: [[1,6],[2,8],[7,12],[10,16]]
> 遍历计算交叉区间(待发射箭头),
> 待发射箭头的区间range = [1, 6], 需要的箭数量 arrows = 1;
> 区间[2, 8], 和带发射区间[1, 6]有交集: 更新发射区域为它们的交集 range = [2, 6]
> 区间[7, 12], 和待发射区间[2, 6]没有任何交集, 说明需要增加一个**新的发射区域**, 新的待发射区域range = [7, 12]
> 区间[10,16], 和待发射区域[7, 12]有交集, 待发射区域更新为[10, 12]
> 返回需要待发射区间的个数







## 976. 三角形的最大周长



**贪心+排序**



排序后，枚举<u>*最长边a[i]*</u>.**只需要用两个短边相加和最长边比较即可**

如果a[i-1] + a[i-2] > a[i]  则说明这最长的三条边**可以组成一个三角形** 且 **周长最大**



> 会不会是不连续的？
>
> 应该是没有的，用反证法可以证明。从小到大排序后得到数组：a,b,c,d,e,f 。 假设由不连续的三个数b , e ,f 组成的三角形周长C1最大，则有C1 = b + e + f。 因为d > b，而b, e ,f 能组成三角形，说明b + e > f; 又因为 d > b，所以 d + e > f也成立，也就是 d e f也能组成三角形，且他的周长C2 = d + e + f，因为d > b，所以d + e + f > b + e + f，因此C2 > C1，因此题目原假设由不连续的三个数b , e ,f 组成的三角形周长C1最大不成立

**如果这连续的三个数无法构成三角形，则a[j | j < i - 2 ] 也无法构成三角形  **

**因为a[j] < a[i-2]**



从贪心的角度考虑，我们一定是选「小于 cc 的最大的两个数」作为边长 a 和 b，此时最有可能满足 a+b>c，使得三条边能够组成一个三角形，且此时的三角形的周长是最大的。



```java
class Solution {
    public int largestPerimeter(int[] A) {
        Arrays.sort(A);

        for(int i = A.length - 1; i >= 2; i--){
            if(A[i-1] + A[i-2] > A[i]){
                return A[i] + A[i-1] + A[i-2];
            }
        }
        return 0;
    }
}
```





























































































# 哈希表





## 454. 四数相加 II

```java
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();

        for(int i = 0; i < A.length; i++){
            for(int j = 0; j < B.length; j++){
                map.put(A[i] + B[j], map.getOrDefault(A[i] + B[j], 0) + 1);
            }
        }

        int sum = 0;
        for(int i = 0; i < C.length; i++){
            for(int j = 0; j < D.length; j++){
                sum += map.getOrDefault(-C[i] - D[j], 0);
            }
        }
        return sum;
    }
}
```









# 分治法



## 53.最大子序和



我们定义一个操作 get(a, l, r) 表示查询 a序列 [l,r] 区间内的最大子段和，那么最终我们要求的答案就是 get(nums, 0, nums.size() - 1)。如何分治实现这个操作呢？对于一个区间 [l,r]，我们取 m = (l + r) / 2，对区间 [l,m] 和 [m+1,r] 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。这个时候我们考虑如何通过 [l,m] 区间的信息和 [m+1,r] 区间的信息合并成区间 [l,r] 的信息。最关键的两个问题是：

我们要维护区间的哪些信息呢？
我们如何合并这些信息呢？
对于一个区间 [l,r]，我们可以维护四个量：

- lSum 表示 [l,r] 内以 l 为左端点的最大子段和
- rSum 表示 [l,r] 内以 r为右端点的最大子段和
- mSum 表示 [l,r] 内的最大子段和
- iSum 表示 [l,r] 的区间和



以下简称[l,m] 为 [l,r] 的「左子区间」，[m+1,r] 为 [l,r] 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 [l,r] 的信息）？对于长度为 1 的区间 [i,i]  四个值相等。

对于长度大于 1 的区间：

首先最好维护的是 iSum，区间[l,r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的 iSum。
对于 [l,r] 的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」的 iSum 加上「右子区间」的 lSum，二者取大。
对于 [l,r] 的 rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取大。
当计算好上面的三个量之后，就很好计算 [l,r] 的 mSum 了。我们可以考虑[l,r] 的 mSum 对应的区间是否跨越 m——它可能不跨越 m，也就是说 [l,r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 m，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。





> 说白了就是二分递归  将子数组得到的信息  上传至母数组  并整合信息的过程



```java
class Solution {
    public int maxSubArray(int[] nums) {
        return getInfo(nums, 0, nums.length - 1).msum;
    }

    //要递归 返回Status类
    public Status getInfo(int[] nums, int l, int r){
        //递归终止条件
        if(l == r){
            return  new Status(nums[l], nums[l], nums[l], nums[l]);
        }
        int m = (l + r) >> 1;
        Status ls = getInfo(nums, l, m);
        Status rs = getInfo(nums, m + 1, r);

        return combineInfo(ls, rs);
    }

    //现在已经计算完成左右子区间的各个值了   合并的过程
    public Status combineInfo(Status ls, Status rs){
        int lsum = Math.max(ls.lsum, ls.isum + rs.lsum);
        int rsum = Math.max(rs.rsum, rs.isum + ls.rsum);
        int msum = Math.max(Math.max(ls.msum, rs.msum), ls.rsum + rs.lsum);
        int isum = ls.isum + rs.isum;

        return new Status(lsum, rsum, msum, isum);
    }



    public class Status{
        int lsum, rsum, msum, isum;
        public Status(int l, int r, int m, int i){
            lsum = l; rsum = r; msum = m; isum = i;
        }
    }
}
```

![image-20201129193733348](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201129193733348.png)



![image-20201129194342656](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201129194342656.png)

> 这种方法懂的都懂  : (



> 题外话
>
> 
>
> 「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维<u>护了四个信息的结构体</u>，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？
>
> 对于这道题而言，确实是如此的。但是仔细观察「方法二」，它**不仅可以解决区间 [0, n - 1]，还可以用于解决任意的子区间 [l, r] 的问题**。如果我们把[0,n−1] 分治下去出现的**所有子区间的信息**都用堆式存储的方式记忆化下来，即建成一颗**真正的树**之后，我们就可以在 ***O(logn)*** 的时间内**求到任意区间内的答案**，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于**大规模查询**的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——**线段树**。
>



































































