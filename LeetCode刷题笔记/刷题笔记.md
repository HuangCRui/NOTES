[TOC]



# 树



## 110.平衡二叉树



**提前阻断**  O(N)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
       return traverse(root) != -1;
    }

    public int traverse(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = traverse(root.left);
        if(left == -1){
            return -1;
        }
        int right = traverse(root.right);
        if(right == -1){
            return -1;
        }

        return Math.abs(right - left) < 2 ? Math.max(right, left) + 1 : -1;//左右子树的最大高度 +1
    }
}
```

先进行左递归 求左子树的高度

再进行右递归 

return  对左右的值进行判断  求出高度，作为父节点的  left / right  向上返回 

若子树不平衡，到了父节点left / right == -1 **代表有一侧已经不平衡了**  直接一路向上返回至 root

![image-20201009173946463](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201009173946463.png)



和上面一样...  区别是  在哪 +1

```java
class Solution {
    boolean flag = true;
    public boolean isBalanced(TreeNode root) {
        depth(root);
        return flag;
    }
    
    public int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = depth(root.left) + 1;
        int right = depth(root.right) + 1;
        if(Math.abs(left - right) > 1){
            flag = false;
        }
        return Math.max(left, right);
    }
}
```





---

暴力法

时间复杂度 O(Nlog2 N)： 

最差情况下， isBalanced(root) 遍历树**所有节点**，占用 O(N) ；判断每个节点的最大**高度** depth(root) 需要遍历 **各子树**的**所有节点** ，子树的节点数的复杂度为 O(log_2 N) 。
空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。



```java
public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
       return isBalanced(root.left) && isBalanced(root.right) && Math.abs(depth(root.left) - depth(root.right)) < 2;
    }
    
    public int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
```





##  589. N叉树的前序遍历



```java
class Solution {
    List<Integer> pre = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        PreOdr(root);
        return pre;
    }

    public void PreOdr(Node root){
        if(root == null){
            return;
        }
        pre.add(root.val);

        for(Node child : root.children){
            PreOdr(child);
        }
        return;
    }
}
```



迭代：

**用Stack结构  push的时候需要将children的顺序反过来，才能做到peek的是最左侧的子结点**



```java
class Solution {
    List<Integer> pre = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        Stack<Node> stack = new Stack<>();
        if(root == null){
            return pre;
        }
        stack.push(root);

        while(!stack.isEmpty()){
            Node father = stack.peek();
            stack.pop();
            pre.add(father.val);
            Collections.reverse(father.children);
            for(Node child : father.children){
                stack.push(child);
            }
        }
        return pre;
    }
}
```





##  特定深度节点链表





```java
class Solution {
    public ListNode[] listOfDepth(TreeNode root) {
         Queue<TreeNode> queue = new LinkedList<>();
        //数组每个元素是一个链表的第一个节点
        ListNode[] list = new ListNode[depth(root)];
        TreeNode father = queue.poll();
        queue.offer(root);
        ListNode head = new ListNode(0);
        int index = 0;
        while(!queue.isEmpty()){
            int size = queue.size();
            ListNode curr = head;
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                curr.next = new ListNode(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
                //curr结点始终指向链表的最后一个节点
                curr = curr.next;
            }
            list[index++] = head.next;
            head.next = null;
        }

        return list;
    }

    //其实不必如此，用List.toArray()也可以转为数组  
    //求出该二叉树最大深度
    public int depth(TreeNode root){
        if(root == null){
            return 0;
        }
        int left = depth(root.left) + 1;
        int right = depth(root.right) + 1;
        return Math.max(left, right);
    }
}
```







## 102. 二叉树的层序遍历



```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> l1 = new ArrayList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();
        //注意进行判断  可能会出现nullpointerexception  (node.val)
        if(root != null){
            queue.offer(root);
        }
        while(!queue.isEmpty()){
            List<Integer> l2 = new ArrayList<>();
            int size = queue.size();
            for(int i = 0; i < size; i++){
                TreeNode node = queue.poll();
                l2.add(node.val);
                if(node.left != null){
                    queue.offer(node.left);
                }
                if(node.right != null){
                    queue.offer(node.right);
                }
            }
            l1.add(l2);
        }
        return l1;
    }
}
```





## 94.二叉树的中序遍历



**递归：**

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        Recur(root);
        return list;
    }
    public void Recur(TreeNode root){
        if(root == null){
            return;
        }
        Recur(root.left);
        list.add(root.val);
        Recur(root.right);
        return;
    }
}
```





### 颜色标记法：

访问过的节点记为 **灰色**  没访问过的是 **白色** 

每次**弹出**栈顶pop()   

- 如果是白色，**依次将右  自己  左**入栈， **自己记为灰色** 
- 如果是灰色，出栈 记录val

始终保持 **左 中 右的顺序  需要在每次碰到一个节点时，先将自己弹出 再把子节点  *按顺序* 加进去，**



**中序：左 中 右    *反着*入栈**

**前序 后序同理**

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        WHITE, GRAY = 0, 1
        res = []
        stack = [(WHITE, root)]
        while stack:
            color, node = stack.pop()
            if node is None: continue
            if color == WHITE:
                stack.append((WHITE, node.right))
                stack.append((GRAY, node))
                stack.append((WHITE, node.left))
            else:
                res.append(node.val)
        return res
```



优化：

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Stack<Object> s = new Stack<>();
        if(root == null){
            return list;
        }
        s.push(root);
        while(!s.isEmpty()){
            Object o = s.pop();
            if(o instanceof TreeNode){
                TreeNode node = (TreeNode)o;
                if(node.right != null){
                    s.push(node.right);
                }
                s.push(node.val);
                if(node.left != null){
                    s.push(node.left);
                }
            }else{
                list.add((int)o);
            }
        }
        return list;
    }
}
```





## 530.二叉搜索树的绝对最小差&783. 二叉搜索树节点最小距离





**先明白一点：二叉搜索树的中序遍历结果->**就是一个**有序的**list  将其转换为数组来求**相邻位置**最小差值即可

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int getMinimumDifference(TreeNode root) {
        recur(root);
        Integer[] arr = list.toArray(new Integer[list.size()]);
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < arr.length - 1; i ++){
            if(Math.abs(arr[i] - arr[i + 1]) < min){
                min = Math.abs(arr[i] - arr[i + 1]);
            }
        }
        return min;
    }
    public void recur(TreeNode root){
        if(root == null){
            return;
        }
        recur(root.left);
        list.add(root.val);
        recur(root.right);
        return;
    }
}
```





## 897. 递增顺序查找树

```java
class Solution {
    List<TreeNode> list = new ArrayList<>();
    public TreeNode increasingBST(TreeNode root) {
        recur(root);
        TreeNode[] inOrder = list.toArray(new TreeNode[list.size()]);
        inOrder[0].left = null;
        for(int i = 1; i < inOrder.length; i++){
            inOrder[i-1].right = inOrder[i];
            inOrder[i].left = null;
        }
        return inOrder[0];


    }
    public void recur(TreeNode root){
        if(root == null){
            return;
        }
        recur(root.left);
        list.add(root);
        recur(root.right);
        return;
    }
}
```







## 剑指 Offer 54. 二叉搜索树的第k大节点



```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        Recur(root);
        return list.get(list.size()-k);
    }

    public void Recur(TreeNode root){
        if(root == null){
            return;
        }
        Recur(root.left);
        list.add(root.val);
        Recur(root.right);
        return;
    }
}
```



## 116. 填充每个节点的下一个右侧节点指针





---

BFS层序遍历



记录前一个节点pre，如果pre是null，说明这是新的一层的遍历，第一个节点。

遍历这一层后面的节点时 需要使pre.next = cur

（也可以将每个节点的next设置成queue.peek(),在每轮结束的时候将最后一个节点`pre.next = null`）

```java
class Solution {
    public Node connect(Node root) {
        Queue<Node> q = new LinkedList<>();
        if(root == null) return root;
        q.offer(root);
        while(!q.isEmpty()){
            int size = q.size();
            Node n = null;
            for(int i = 0; i < size; i++){
                n = q.poll();
                if(!q.isEmpty()){
                    n.next = q.peek();
                }
                if(n.left != null){
                    q.offer(n.left);
                }
                if(n.right != null){
                    q.offer(n.right);
                }
            }
            n.next = null;
        }
        return root;
    }
}
```

使用队列 效率低 需要不停入队出队





---

链表法

![image-20201016124446572](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201016124446572.png)

对于 cur这一行的节点 把每个都遍历一遍  将其**子节点串在一起**

遍历完一行后，cur节点变为下一行的第一个节点 即：dummy.next



**访问当前层的节点，把下一行的节点串起来**

```java
class Solution {
    public Node connect(Node root) {
        if(root == null) return root;

        Node cur = root;
        while(cur != null){
            //开始新的一行的遍历cur  为下一行重新建立dummy和pre
            //cur继承自上次遍历
            Node dummy = new Node(0);
            Node pre = dummy;

            //因为是完美二叉树，如果有左子节点就一定有右子节点
            while(cur != null && cur.left != null){
                pre.next = cur.left;
                pre = pre.next;

                pre.next = cur.right;
                pre = pre.next;

                cur = cur.next;
            }

            cur = dummy.next;
        }

        return root;
    }
}
```

---

递归解法

将右边节点和右边相邻子树的左节点联系到一起

**主要就是最靠右的一排节点的next不好处理**

```java
public Node connect(Node root) {
    dfs(root, null);
    return root;
}

private void dfs(Node curr, Node next) {
    if (curr == null)
        return;
    curr.next = next;
    dfs(curr.left, curr.right);
    dfs(curr.right, curr.next == null ? null : curr.next.left);
}
```







##  814. 二叉树剪枝



```java
class Solution {
    public TreeNode pruneTree(TreeNode root) {
        boolean r =  recur(root);
        return r == false ? null : root;
    }

    public boolean recur(TreeNode root){
        //边界需要注意 返回false  因为需要删除结点的时候  要把null当做 0 结点来处理
        if(root == null){
            return false;
        }
        boolean left = recur(root.left);
        if(left == false){
            root.left = null;
        }

        boolean right = recur(root.right);
        if(right == false){
            root.right = null;
        }
			//只要这一颗子树中有一个结点为1 那么这整棵子树就向上返回true
        //如果根结点为0 那么就在左右子树中寻找是否有一个结点为1 --> 做“或”运算
        return root.val == 0 ? false || left || right : true;
    }
}
```







## 998. 最大二叉树 II



```java
class Solution {
    /**
	  * 这题目也太难读懂了.......
     * 给出的是已经构造好的树
     * ！ 新加入的元素在B[]末尾，故而如果val是最大的，其他元素都在他的左子树
     * else 最大元素i，从i+1开始继续递归（递归右子树）   再寻找最大值， 然后切分 ->会发现val还是在右子树
     * val在B末尾，故而始终在上一层的右子树(不是max的情况)
     * 如果碰到小于val的------>那么剩下的元素应该就在val的左侧，那就是val的左子树！！
     * -> 在形象表示上，新加入的val应该是在整棵树最右边的
     终于算是读懂题目了......


     * 要求如下  对新加入的元素 如果大于当前结点(无论是不是根节点)，则当前结点为val结点的左子结点；否则加入到右子树中
	 */
    public TreeNode insertIntoMaxTree(TreeNode root, int val) {

        //递归边界
        if(root == null || val > root.val){
            TreeNode r = new TreeNode(val);
            r.left = root;
            return r;
        }else{
            TreeNode tmp =  insertIntoMaxTree(root.right, val);
            root.right = tmp;
            return root;
        }
    }
}
```







## 112. 路径总和



**DFS**

```java
/*
 [1,2]
 1

 [-2,null,-3]
-5
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        // 出现负数示例，无法使用此方法来剪枝
        // if(root.val > sum){
        //     return false;
        // }
        
        //在哪减去val都可以.....
        //反正当前结点位置一定会进行判断：sum == root.val  进行或运算，只要有一个叶子结点返回true就完事了
        boolean left = hasPathSum(root.left, sum - root.val);
        boolean right = hasPathSum(root.right, sum - root.val);
        
			 //[1,2] 1  必须是叶子结点结束的路径才可以  此时返回true
        return (sum == root.val && root.left == null && root.right == null) ? true : left || right;
        
        
        /*
        题解：
        
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
        */
    }
}
```





---



**BFS**

广度优先搜索  把父节点的值依次加到子节点上并入队储存，且在每次出队时与sum进行比较

**其实这种做法dfs递归也行......  还更方便。。  **

> 迭代/递归

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        Queue<Integer> num = new LinkedList<Integer>();

        q.offer(root);
        num.offer(root.val);

        while(!q.isEmpty()){
            TreeNode tmp = q.poll();

            int x = num.poll();
            //出队列时  需要判断是否符合叶子的条件 && 等于sum
            if(tmp.left == null && tmp.right == null && x == sum){
                return true;
            }

            if(tmp.left != null){
                q.offer(tmp.left);
                num.offer(x + tmp.left.val);
            }
            if(tmp.right != null){
                q.offer(tmp.right);
                num.offer(x + tmp.right.val);
            }

        }
        return false;
    }
}
```





# 字符串



## [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)



```java
class Solution {
    //迷糊了。其实就相当于减去前面那个小值再加上后面的大值。。。很简单的一个逻辑
    public int romanToInt(String s) {
        char[] t = s.toCharArray();
        int pre = getVal(t[0]);
        int sum = 0;
        for(int i = 1; i < t.length; i++){
            int cur = getVal(t[i]);
            if(pre < cur){
                sum -= pre;
            }else{
                sum += pre;
            }
            pre = cur;
        }
        sum += pre;
        return sum;
    }

    public int getVal(char c){
        switch(c){
            case 'I' : return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            default: return 0;
        }
    }
}
```









# 链表





## 206. 反转链表



**栈**：  “先进后出”

代码略...



**递归解法**   当前节点的next节点   同一个子问题

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode reverse = reverseList(head.next);
        head.next.next = head;
        //避免链表出现  环
        head.next = null;
        return reverse;
    }
}
```





**顺序**解

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode prev = null;
        ListNode temp = null;
        while(cur != null){
            //要将当前cur.next指向上一个节点  记录下next
            temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;
    }
}
```

![image-20201018182051004](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201018182051004.png)















## 143. 重排链表



存储

用 **栈 / 线性表 都可以实现**

```java
class Solution {
    public void reorderList(ListNode head) {
        //又忘了空数据的情况了...... 0/1/2个结点都直接返回。。
        if(head == null || head.next == null || head.next.next == null){
            return;
        }
        Stack<ListNode> s = new Stack<>();
        ListNode cur = head;
        while(cur != null){
            s.push(cur);
            cur = cur.next;
        } 
        cur = head;
        ListNode next = null;

        while(s.peek() != next){
            //System.out.println(cur.val);
            next = cur.next;
            if(s.peek() == next){
                cur.next = next;
                break;
            }
            cur.next = s.pop();
            cur = cur.next;
            //System.out.println(cur.val);
            if(s.peek() == next){
                cur.next = next;
                break;
            }
            //环
            cur.next = next;
            cur = cur.next;
        }
        next.next = null;
        return;
    }
}
```

![image-20201023211757518](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201023211757518.png)



真的慢。。入栈出栈费时

---



递归解法

问题就是取尾元素的时候，**需要遍历一遍链表**。

如果我们的递归函数能够**返回当前头元素对应的尾元素**，并且将头元素和尾元素之间的链表按要求完成，那就变得简单了。

![image-20201023214048916](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201023214048916.png)

我们只需要将 `head` 指向 `tail`，`tail` 指向处理完的链表头即可。

![image-20201023214109626](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201023214109626.png)

把之前的 `tail.next`   (框里面的内层tail)   返回就是外层 `head` 对应的 `tail` 了。



**递归出口**：

- 如果**只有一个节点**，那么我们只需要将 **`head.next` 返回**。

- 如果是两个节点，我们需要将 `head.next.next` 返回。



无需递归到尾结点！

通过len记录   奇数偶数个结点分情况

- 奇数：  l = 1 

- 偶数：  l = 2  **最中间的两个元素的顺序是不改变的，直接返回head.next.next作为returnTail**

  在这一层的外层，head.next指向的是里面一层的head，这时：

  - 令nextHead = head.next;  head.next = tail; 这一层的头节点指向内一层返回的returnTail，（**同时记录并返回这一层的returnTail**）然后内一层返回的returnTail指向nextHead 

每一层需要返回**外面一层**的tail节点，也就是  `return  当前层tail.next`



```java
class Solution {
    public void reorderList(ListNode head) {

        if(head == null || head.next == null || head.next.next == null){
            return;
        }

        int len = 0;
        ListNode l = head;
        while(l != null){
            l = l.next;
            len++;
        }
        reOrder(head, len);

    }
    public ListNode reOrder(ListNode head, int len){
        if(len == 1){
            ListNode returnTail = head.next;
            head.next = null;
            return returnTail;
        }
        if(len == 2){
            ListNode returnTail = head.next.next;
            head.next.next = null;
            return returnTail;
        }
        ListNode tail = reOrder(head.next, len - 2);
        ListNode nextHead = head.next;//上一层 (中间)链表的头结点
        head.next = tail;
        ListNode returnTail =  tail.next;//返回上一层head对应的tail
        tail.next = nextHead;
        return returnTail;
    }
}
```





![image-20201024202611534](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024202611534.png)



---

利用取一头一尾的特性

```java
class Solution {
    public void reorderList(ListNode head) {
        // 一个或者两个结点 都无需进行重排
        if (head == null || head.next == null || head.next.next == null) {
            return;
        }
        //快慢指针找中点
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;fast = fast.next.next;
        }
        ListNode newhead = slow.next;
        slow.next = null;
        //反转链表
        newhead = reverse(newhead);

        while(newhead != null){
            ListNode temp = newhead.next;
            newhead.next = head.next;
            head.next = newhead;

            head = newhead.next;
            newhead = temp;
        }
    }

    public ListNode reverse(ListNode head){
        ListNode prev = null, next = null, temp = null;
        while(head != null){
            next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```



















## 21. 合并两个有序链表





**巧妙使用dummy节点  和  cur节点**

- dummy***哑结点***作为新起的链表的head，不动
- cur***游标***指向合并链表的最后一个节点的位置，负责加入新结点

> 有点死板....想着在原先的基础上把他们合并。有点难度  操作太复杂

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0), cur = dummy;
        while(l1 != null && l2 != null){
            if(l1.val <= l2.val){
                cur.next = l1;
                l1 = l1.next;
            }else{
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        //这一步比较重要
        //如果哪个链表
        cur.next = l2 != null ? l2 : l1;
        
        return dummy.next;
    }
}
```





---

**递归解法**



- **终止条件**：两个链表都为空，对链表的合并已经完成

- 如何递归：我们判断 `l1` 和 `l2` 头结点哪个更小，然后较小结点的 `next` 指针*<u>指向</u>*     **其余结点的<u>合并结果</u>。（调用递归）**

递归过程中，一方到null了，说明这个链表遍历完了，可以直接**连接到**另一个链表的当前遍历位置 

![image-20201022194918261](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201022194918261.png)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null){
            return l2;
        }
        else if(l2 == null){
            return l1;
        }

        //l1是较小的结点，后面的链表接在l1后面，
        else if(l1.val <= l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else{
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```



**复杂度分析**

- 时间复杂度：每次递归  都会去掉两个链表其中的一个结点，O(M+N), 至多只会调用每个节点一次

- 空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的**长度**。递归调用 mergeTwoLists 函数时需要消耗**栈空间**，栈空间的大小**取决于递归调用的深度**。结束递归调用时 mergeTwoLists 函数**最多调用 n+m 次**（**最坏条件**），因此空间复杂度为 O(n+m)。









## [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)



<=x的放到一个链表中，>x的放在另一个链表中。因为都是内存的引用，不会消耗额外空间。

最后再将小链表的尾部指向大链表

```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        if(head == null){
            return null;
        }
        ListNode tummy = new ListNode(0);
        tummy.next = head;
        ListNode stummy = new ListNode(0), ltummy = new ListNode(0);
        ListNode scur = stummy, lcur = ltummy;
        while(tummy.next != null){
            if(tummy.next.val < x){
                scur.next = tummy.next;
                tummy.next = tummy.next.next;
                scur = scur.next;
            }else{
                lcur.next = tummy.next;
                tummy.next = tummy.next.next;
                lcur = lcur.next;
            }
        }
        //防止形成环 最后一个节点是小节点如果不指向null，那么前一个大节点指向的就是后一个小节点，会形成环   而小链表最后一个节点会指向大的链表头，故而不用指null
        lcur.next = null;
        scur.next = ltummy.next;
        return stummy.next;
        
    }
}
```











# 双指针







## 19. 删除链表的倒数第N个节点



```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        ListNode tem = dummy;
        dummy.next = head;
        Stack<ListNode> s = new Stack<>();
        while(tem != null){
            s.push(tem);
            tem = tem.next;
        }
        
        for(int i = 0; i <= n; i++){
            head = s.pop();
        }
        head.next = head.next.next;
        return dummy.next;
    }
}
```



```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        List<ListNode> l = new ArrayList<>();
        ListNode dummy = new ListNode(0);
        ListNode tem = dummy;
        dummy.next = head;
        while(tem != null){
            l.add(tem);
            tem = tem.next;
        }
        tem =  l.get(l.size() - n - 1);
        tem.next = tem.next.next;
        return dummy.next;
    }
}
```

---

**双指针**

**dummy节点堪称一绝！！！**

**从dummy开始  防止越界**

保持slow和fast之间隔了n个节点  在fast到达null时，slow.next就是要删掉的



```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        ListNode tem = dummy;
        dummy.next = head;
       //也可以使用一个pre节点 从dummy开始 slow和fast相隔n-1个节点 pre.next = slow.next;
       ListNode slow = dummy;
       ListNode fast = dummy;
       for(int i = 1; i <= n + 1; i++){
           fast = fast.next;
       }

       while(fast != null){
           slow = slow.next;
           fast = fast.next;
       }
       slow.next = slow.next.next;
       return dummy.next;
    }
}
```





## 844. 比较含退格的字符串



```java
class Solution {
    public boolean backspaceCompare(String S, String T) {

        char[] s = S.toCharArray(), t = T.toCharArray();
        int i = s.length - 1, j = t.length - 1, m = 0, n = 0;


        //有一方可能已经到了-1  另一边有可能  还需要遍历一次把#能抵消的抵消完
        //b a##b
        while(i > -1 || j > -1){
        //先把两个字符串的#和可以退格的字符都处理了，再比较"干净的"字符串    
            
           while(i >= 0){
               if(s[i] == '#'){
                   m++;i--;
               }
               //碰到字符时：如果还有没用完的 #退格 就先把这个字符退了
               else if(m > 0){
                   m--;i--;
               }else{
                   //是字符  且  m==0
                   break;
               }
           }

           while(j >= 0){
               if(t[j] == '#'){
                   n++;j--;
               }
               else if(n > 0){
                   n--;j--;
               }else{
                   //是字符  且  n==0
                   break;
               }
           }
//如果能匹配成功，必然不会两个中有一个索引到了-1,每一轮不被抵消的字符都应该能匹配到

           if(i > -1 && j > -1){
               if(s[i] != t[j]){
                   return false;
               }
           }else{
               // 有一个串 遍历完了到了-1  另一个在经历了"多一轮"#退格扫描后，还有剩余的  --没有被#退格掉-- 的字符
               if(i > -1 || j > -1){
                   return false;
               }
           }
           i--;j--;

        }
        return true;

    }
}
```







## 876. 链表的中间结点





```java
class Solution {
    public ListNode middleNode(ListNode head) {
        if(head.next == null){
            return head;
        }
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        //偶数节点fast会停在倒数第二个  
        //奇数节点fast会直接到结尾
        if(fast.next != null){
            return slow.next;
        }
        return slow;
    }
}
```





## 763. 划分字母区间



**贪心**



**字母最后位置信息可以使用数组来保存(char)**



> 同一个字母只会出现在其中一个片段

遍历字符串 先确定每个字母最后出现的位置。



- 从头开始扫描 双指针begin end.

- **end记录扫描过程中遇到的字符 <u>*最后*</u> 出现的位置**  需要一直保持更新状态，记录max_end
- 如果遍历 i 到了end位置，就说明  **沿途中再没有字符最后出现的位置 >= end，此时这个end就可以作为分界点**
- end & begin = end + 1 开始新的一轮扫描  （**这后面的字符都是前面从没出现过的**）

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        int[] last = new int[26];
        List<Integer> res = new ArrayList<>();
        char[] s = S.toCharArray();

        //存储每个字符最后出现的位置
        for(int i = 0; i < s.length; i++){
            last[s[i] - 'a'] = i;
        }
        int begin = 0, end = 0;
        for(int i = 0; i < s.length; i++){
            end = Math.max(last[s[i] - 'a'], end);
            if(i == end){
                res.add(end - begin + 1);
                begin = end + 1;
                end = begin;
            }
        }

        return res;
    }
}
```





## 234. 回文链表

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null){
            return true;
        }
        //使用快慢指针取链表的中点 
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode newhead = slow.next;
        //反转后半个链表
        newhead = reverse(newhead);
        //如果链表结点数为奇数，则只比较后半个链表结点的值，中间的结点无须比较
        while(newhead != null){
            if(newhead.val == head.val){
                newhead = newhead.next;
                head = head.next;
            }else{
                return false;
            }
        }
        return true;
    }
    //反转链表
    public ListNode reverse(ListNode head){
        ListNode cur = head, prev = null, next = null;
        while(cur != null){
            next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```











## 925. 长按键入



脑瘫晚期做法.......

```java
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        char[] n = name.toCharArray(), t = typed.toCharArray();
        int i = 0, j = 0;
        //直到typed判断完了并且越界了，结束
        while(j != t.length){
            
            //typed用完了  name没用完  匹配失败
            if(j == t.length - 1 && i < n.length - 1){
                return false;
            }
            //name用完  typed没用完，可能还有重复输入
            if(i == n.length - 1 && j <= t.length - 1){
                if(n[i] == t[j]){
                    j++;
                    continue;
                }else{
                    return false;
                }
                
            }
            
            if(n[i] == t[j]){
                if(i < n.length-1 && n[i + 1] == n[i]  ){
                    i++;j++;
                }else if(j < t.length-1 && t[j] == t[j + 1]){
                    j++;
                }else{
                    i++;j++;
                }
            }else{
                return false;
            }
            
            
        }
        return true;
    }
}
```



**妙啊......**

**方向错了，应该用type来匹配name，而不是name来匹配type**.....懂的都懂

- type[j]可以和name[i]匹配上
- type[j]没法匹配name[i]，但和type[j - 1]相等，**则认为他是长按的**
- false



type **按理来说长度 >= name**

当*typed* 扫描完毕后，我们再检查*name* 的每个字符是否都被「匹配」了。

最后，如果 **i=name.length**，说明 name 的每个字符都被「匹配」了。

```java
class Solution {
    public boolean isLongPressedName(String name, String typed) {
        int i = 0, j = 0;
        char[] a = name.toCharArray(), b = typed.toCharArray();
        while(j < b.length){
            if(i < a.length && a[i] == b[j]){
                i++;j++;
            }else if(j > 0 && b[j] == b[j - 1]){
                j++;
            }else{
                return false;
            }
        }

        return i == a.length;
    }
}
```







## 845. 数组中的最长山脉



```java
class Solution {
    public int longestMountain(int[] A) {
        int i = 0, j = 0, num = 0, maxi = 0, max_len = 0;

        while(j < A.length){

            //有一个increaseing
            if(j < A.length - 1 && A[j + 1] > A[j]){
                while(j < A.length - 1 && A[j + 1] > A[j]){
                    j++;
                    maxi = j;
                }
                
                //至少有一步下降，可以形成完整山脉  /  存在上升近阶段
                if(j < A.length - 1 && maxi != i && A[j + 1] < A[j]){
                    while(j < A.length - 1 && A[j + 1] < A[j]){
                        j++;
                    }
                    //记录长度 将下一轮的开始位置设置为当前j，(可能作为下一个山脉的beginning)
                    max_len = Math.max(max_len, j - i + 1);
                    //System.out.println(i + "  " + j);
                    i = j; maxi = i;
                }
                //没有下降阶段  /  没有第一步上升阶段
                else{
                    i = j + 1;j = j + 1; maxi = i;
                }
            }
            //开始就降低或者相等
            else{
                i += 1;j += 1;
            }  
        }
        return max_len;
    }
}
```



```java
class Solution {
public int longestMountain(vector<int>& A) {
        int maxLength = 0;
        int i = 1;
        
        //只有一开始就上升才有效
        while (i < A.size()) {
            int increasing = 0, decreasing = 0;
            
            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;
            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;
            
            if (increasing > 0 && decreasing > 0) 
                maxLength = max(maxLength, increasing + decreasing + 1);//少算一个 开头的数 
            
            //处理连续的相同值，跳过，不符合题目要求
            while(i < A.size() && A[i - 1] == A[i]) i++;
        }
        return maxLength;
    }
}
```









# 动态规划



## 1024. 视频拼接

动态规划：

用过的片段，会影响之后对片段的选用，**过去的状态影响当前状态**，有 DP 的味儿了。



定义 `dp[j]`，表示：**覆盖 `[0, j]`区间的最少片段数**，题目是**求 `dp[T]`**



**dp的思想是能少用就少用  尽量把当前这个区间*<u>用完</u>*，再换下一个可用的区间**



```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] dp = new int[T + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        //空区间的初始值为0
        dp[0] = 0;

        for(int i = 1; i <= T; i++){
            for(int[] clip : clips){
                if(i <= clip[1] && i > clip[0]){
                    //遍历每个区间，区间开始的地方数量+1  
                    //取最少的
                    //就是要把每个区间榨干......
                    //如果过了上个使用的区间的右边界，对于新的一个区间
                    //从新区间的左边界位置dp[clip[0]] + 1
                    //那个左边界位置可以保证是最小的数量
                    dp[i] = Math.min(dp[clip[0]] + 1, dp[i]);
                }
            }
        }
        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];
    }
}
```

![image-20201024230632811](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024230632811.png)

时间复杂度：O(T*N)   其中T是区间的长度  N是子区间的数量

慢！

空间复杂度：O(T)



---

贪心：

```java
//贪心思想  始终走到最远的位置，最大化使用前面的区间
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] rec = new int[T];
        int max = 0, pre = 0, res = 0;
        for(int[] clip : clips){
            if(clip[0] < T){
                rec[clip[0]] = Math.max(rec[clip[0]], clip[1]);
            }
        }

        for(int i = 0; i < T; i++){
            //max代表在i位置前   单个  区间  能达到的最远距离
            max = Math.max(max, rec[i]);
            //如果在i位置，max不能比i大？那就只能遍历到这了
            //如果max > i,表示还可以再往前走一走
            if(i == max){
                return -1;
            }
            //pre 记录 上一个 被使用 的 子区间的  结束 位置
            //i == pre 表示上一个子区间已经用完了，并且(max > i)，还能再往前走，结果数量+1
            //将pre 更新为当前使用的区间的max(能走的最远距离)
            if(i == pre){
                res++;
                pre = max;
            }
        }
        return res;
    }
}
```

![image-20201024220031239](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024220031239.png)

时间复杂度：O(T + N)

空间复杂度：O(T)





## 53.最大子序和



**dp解法**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //以当前位nums[i]结尾时  的  最大子序和
        int max = nums[0];
        
        for(int i = 1; i < nums.length; i++){
            nums[i] = Math.max(nums[i] + nums[i - 1], nums[i]);    
            max = Math.max(max, nums[i]);
        }
        return max;
    }
}


//也可以使用pre代替上一轮计算dp[i]的结果
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}
```









## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)



```java
class Solution {
    // s[i]:按区间开始排序后，以区间i结束的最大 不重叠区间个数
    // 枚举i之前的区间，选择max，即状态转移
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length == 0){
            return 0;
        }
        
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[0] > b[0] ? 1 : -1;
            }
        });

        int[] s = new int[intervals.length];
        Arrays.fill(s, 1);
        int max = 1;

        for(int i = 1; i < intervals.length; i++){
            for(int j = i - 1; j >= 0; j--){
                //j区间在i区间之前
                if(intervals[j][1] <= intervals[i][0]){
                    s[i] = Math.max(s[j] + 1, s[i]);
                }
            }
            max = Math.max(max, s[i]);
        }
        return intervals.length - max;
    }
}
```







# 其他类型





## 1207. 独一无二的出现次数

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        int[] help = new int[2002];
        Arrays.fill(help, 0);

        for(int i = 0; i < arr.length; i++){
            help[arr[i] + 1000] ++;
        }
        int sum = 0;
        for(int i = 0; i < help.length; i++){
            if(help[i] != 0){
                sum++;
            }
        }
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < help.length; i++){
            if(help[i] != 0){
                set.add(help[i]);
            }
            
        }
        //将出现次数不为0的 次数 存入set中，(set中的数不重复)，如果数量和sum不同，说明有重复的出现次数
        return set.size() == sum;
    }
}
```





**更快**

```java
class Solution {
    public boolean uniqueOccurrences(int[] arr) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < arr.length; i++){
            map.put(arr[i], map.getOrDefault(arr[i], 0)+1);
        }
        return map.size() == new HashSet<>(map.values()).size();
    }
}
```



**set中只能存放不同的数据**

```java
 if (!set.add(value))//如果存储失败，说明有重复的
     return false;
```





## 242. 有效的字母异位词



**长度为26的数组记录每个字母出现的次数**   

逐字母比较   两个String是否存在哪一个字母的次数不同

钻个空子罢了....

≈哈希表

```java
class Solution {
    public boolean isAnagram(String ss, String tt) {
        int[] bucket1 = new int[26], bucket2 = new int[26];
        Arrays.fill(bucket1, 0);
        Arrays.fill(bucket2, 0);
        char[] s = ss.toCharArray(), t = tt.toCharArray();

        for(int i = 0; i < s.length; i++){
            bucket1[(int)(s[i] - 'a')]++;
        }
        for(int i = 0; i < t.length; i++){
            bucket2[(int)(t[i] - 'a')]++;
        }

        //人傻了 多扫了一遍
        for(int i = 0; i < bucket1.length; i++){
            if(bucket1[i] != bucket2[i]){
                return false;
            }
        }
        return true;
    }
}

//最简单写法
class Solution {
    public boolean isAnagram(String ss, String tt) {
        //先比较长度，如果不相等直接返回，也是避免后面出现减完后还有字符剩余的情况
        if (s.length() != t.length()) {
            return false;
        }
        char[] s = ss.toCharArray(), t = tt.toCharArray();
        int[] table = new int[26];
        for (int i = 0; i < s.length; i++) {
            table[s[i] - 'a']++;
        }
        //若有 个数不一样 的字符出现，就会出现 <0 -> false
        for (int i = 0; i < t.length; i++) {
            table[t[i] - 'a']--;
            if (table[t[i] - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
}
```



**说明:**
你可以假设字符串只包含小写字母。

**进阶:**
如果输入字符串**包含 unicode 字符**怎么办？你能否调整你的解法来应对这种情况？



---

**排序  稳！**  时间O(nlongn)  空间O(logn)  **递归复杂度**

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        char[] str1 = s.toCharArray();
        char[] str2 = t.toCharArray();
        Arrays.sort(str1);
        Arrays.sort(str2);
        return Arrays.equals(str1, str2);
    }
}。
```







---

对于进阶问题，Unicode 是为了解决传统字符编码的局限性而产生的方案，**它为每个语言中的字符规定了一个唯一的二进制编码**。而 **Unicode中可能存在一个字符对应多个字节**的问题，为了让计算机知道多少字节表示一个字符，面向传输的编码方式的 UTF−8 和UTF-16 也随之诞生逐渐广泛使用，具体相关的知识读者可以继续查阅相关资料拓展视野，这里不再展开。

回到本题，进阶问题的核心点在于「字符是**离散未知**的」，因此我们用**哈希表维护对应字符的频次**即可。同时读者需要注意Unicode一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。







## 204. 计数质数



```java  
class Solution {
    public int countPrimes(int n) {
        if(n == 0 || n == 1){
            return 0;
        }
        int sum = 1;
        
        for(int i = 3; i < n; i++){
            if(i % 2 == 0){
                continue;
            }
            int flag = 1;
            
            //Math.sqrt()会超时
            for(int j = 3; j * j <= i; j++){
                if(i % j == 0){
                    flag = 0;
                    break;
                }
            }
            if(flag == 1){
                sum++;
            }
        }
        return sum;
    }
}
```



---

**筛法**



```java
class Solution {
    public int countPrimes(int n) {
        int[] isPrime = new int[n];
        Arrays.fill(isPrime, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i] == 1) {
                // 如果遍历到当前数的时候没有被前面的数筛掉，说明这个数--不存在--约数，即为质数
                ans += 1;
                // 同理，从i*i开始，因为前面的数都已经被筛过了2,3,...,i-1 的所有倍数，不需要再判断了  
                //从i开始的倍数还没被筛过，开始--
                if ((long) i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
} 
```





## 48. 旋转图像

```java
class Solution {
    public void rotate(int[][] matrix) {
        // j:圈 一共只需要遍历matrix.length/2 - 1圈  (奇偶一样)
        for(int j = 0; j < matrix.length/2; j++){

            // i:每条边的第几个数
            // 内层 只遍历单圈的数 length(matrix.length-1-j*2 - 1)就是需要进行交换的数的"组"的数量，注意是“圈”！ 中间空心嗷
            // 如：一圈每一条边有4个数  只需要对四条边上的  3 组数进行交换
            for(int i = 0; i < matrix.length-1-j*2; i++){
                swap(i,j,matrix);
            }
        }
        return;
    }

    //交换j这一圈第j+i个位置的四个数
    public void swap(int i,int j, int[][] mat){
        int tem = mat[j+i][mat.length-1-j];
        mat[j+i][mat.length-1-j] = mat[j][j+i];

        int tem2 = mat[mat.length-1-j][mat.length-1-i-j];
        mat[mat.length-1-j][mat.length-1-i-j] = tem;

        tem = mat[mat.length-1-i-j][j];
        mat[mat.length-1-i-j][j] = tem2;

        mat[j][j+i] = tem;
        return;
    }
}
```

![image-20201219182824433](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201219182824433.png)













## 118. 杨辉三角



```java
class Solution {
    public List<List<Integer>> generate(int numRows) {        
        // 第i行有i个数

        List<List<Integer>> res = new ArrayList<List<Integer>>();
        for(int i = 0; i < numRows; i++){
            List<Integer> row = new ArrayList<Integer>();

            for(int j = 0; j <= i; j++){
                if(j == 0 || j == i){
                    row.add(1);
                }else{
                    row.add(res.get(i-1).get(j-1) + res.get(i-1).get(j));
                }
            }
            res.add(row);
        }
        return res;
    }
}
```





## [228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)



```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        //连续区间

        if(nums.length == 0){
            return new ArrayList<String>();
        }
        List<String> res = new ArrayList<String>();
        if(nums.length == 1){
            res.add(String.valueOf(nums[0]));
            return res;
        }
        

        for(int i = 0; i < nums.length;i++){
            int pre = nums[i];
            int from = i;
            while(i+1 < nums.length && nums[i + 1] - pre == 1){
                pre = nums[i + 1];
                i++;
            }
            if(i == from){
                res.add(String.valueOf(nums[i]));
               
            }else{
                res.add(nums[from] + "->" + nums[i]);
                
            }
        }
        return res;
    }
}
```



## [1018. 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)

> ```shell
> 1. (a + b) % p = (a % p + b % p) % p 
> 2. (a - b) % p = (a % p - b % p) % p 
> 3. (a * b) % p = (a % p * b % p) % p 
> 4. (a^b) % p = ((a % p)^b) % p
> ```



```java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] A) {
        List<Boolean> res = new ArrayList<>();
        int num = 0;
        //二进制转十进制公式，如果往后加一位：那么前面的位得到的结果*2，加上2^0*A[i]即A[i]

        
        //二进制位数过多，需要考虑！！
        //%5 让值永远控制在0~4   模运算和加减乘除运算的位置可交换，不影响结果
        //只需要在做完运算后 %5
        for(int i = 0; i < A.length; i++){
            num = ((num << 1) + A[i]) % 5;
            res.add(num == 0);
        }
        return res;
    }
}
```





## [1232. 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/)

**并不知道所给数据是否是顺序..不过好像不影响结果。。。**

> 精度？？最好还是别用斜率   官方题解!

```java
class Solution {
    public boolean checkStraightLine(int[][] coordinates) {
        int prex = coordinates[1][0], prey = coordinates[1][1];
        //会出现分母为0的情况，故改为乘法  δy / δx = (y[i] - prey) / (x[i] - prex)
        //δy * (x[i] - prex) == δx * (y[i] - prey)
        int deltay = prey - coordinates[0][1], deltax = prex - coordinates[0][0];
        for(int i = 2; i < coordinates.length; i++){
            if(deltay * (coordinates[i][0] - prex) != deltax * (coordinates[i][1] - prey)){
                 return false;
            }else{
                prex = coordinates[i][0]; prey = coordinates[i][1];
            }
        }
        return true;
    }
}
```



---

![image-20210118033247641](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210118033247641.png)

**过原点：y = kx** P1点的 `k` 就是 -A / B，**避免B=0，改为乘法表示就ok。和解法一差不太多**

```java
class Solution {
    public boolean checkStraightLine(int[][] coordinates) {
        int deltaX = coordinates[0][0], deltaY = coordinates[0][1];
        int n = coordinates.length;
        //每个点都平移P0的坐标位置
        for (int i = 0; i < n; i++) {
            coordinates[i][0] -= deltaX;
            coordinates[i][1] -= deltaY;
        }
        int A = coordinates[1][1], B = -coordinates[1][0];
        for (int i = 2; i < n; i++) {
            int x = coordinates[i][0], y = coordinates[i][1];
            if (A * x + B * y != 0) {
                return false;
            }
        }
        return true;
    }
}
```



# 排序





## 1365. 有多少小于当前数字的数字

**快排 + 映射**



记录每一个数在**<u>原数组中的位置</u>**。对于排序后的数组中的每一个数，我们找出其左侧第一个小于它的数，这样就能够知道数组中小于该数的数量

```java
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        int n = nums.length;
        //映射  原位置
        int[][] data = new int[n][2];
        for (int i = 0; i < n; i++) {
            data[i][0] = nums[i];
            data[i][1] = i;
        }
        Arrays.sort(data, new Comparator<int[]>() {
            public int compare(int[] data1, int[] data2) {
                return data1[0] - data2[0];//排序规则
            }
        });

        int[] ret = new int[n];
        int prev = -1;
        for (int i = 0; i < n; i++) {
            //i=0时防止越界
            //出现重复的数，使用上一个数的值，不再对prev进行更新。
            if (prev == -1 || data[i][0] != data[i - 1][0]) {
                prev = i;
            }
            
            ret[data[i][1]] = prev;
        }
        return ret;
    }
}
```



---



**计数排序**

```java
class Solution {
    public int[] smallerNumbersThanCurrent(int[] nums) {
        

        int[] fre = new int[101], res = new int[nums.length];
        Arrays.fill(fre, 0);

        //将数装到桶中
        for(int i : nums){
            fre[i]++;
        }
        //对每个数出现的频率从小到大累加
        for(int i = 1; i < fre.length; i++){
            fre[i] = fre[i - 1] + fre[i];
        }
        //比这个数小的个数 --比他小的--  fre下标nums[i]-1
        for(int i = 0; i < res.length; i++){
            if(nums[i] > 0){
                res[i] = fre[nums[i] - 1];
            }
        }
        return res;
    }
}
```

> 考这样一个问题：全国高考考生(大量元素)按成绩(0-750)排名问题
> 如何排序，可参考计数排序——特殊的桶排序
> 计数排序
> 大体思想：扫描一遍所有人，按分数分到不同给的桶里，桶内无需再排序，仅需统计各桶内数量
> 适用性：数据量大、数据范围不大的情况
> 假设数据已排序如 [748, 748, 747, ..., 730, 730, ..., 730, 729, ...]
> 问：有多少人在 729 前面？（同分同名次，如 747 是第三名，没有第二名）
> 答：即 第一个 729 的索引











## 148. 排序链表



**归并排序**



![image-20201121202200034](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201121202200034.png)

合并 merge 环节： 

将两个排序链表合并，转化为一个排序链表。
**双指针法**合并，建立**辅助ListNode h 作为头部**。
设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。
返回辅助ListNode h 作为头部的下个节点 h.next。
时间复杂度 O(l + r)，l, r 分别代表两个链表长度。





> **细节：**
>
> - slow.next = null;  将链表切成两段，后面才能操作
>
> - 只有一个head时递归到终点，返回
> - tummy头节点 作为输出链表的头，串在其后
> - 其中一个链表为null后，直接将另一个非空的链表接在后面√



```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        //快慢指针找中点
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        ListNode temp = slow.next;
        slow.next = null;//将链表切成两段

        ListNode left =  sortList(head);
        ListNode right =  sortList(temp);

        ListNode tummy = new ListNode(0);
        ListNode res = tummy;
        //归并left right两个链表
        while(left != null && right != null){
            if(left.val >= right.val){
                tummy.next = right;
                right = right.next;
            }else{
                tummy.next = left;
                left = left.next;
            }
            tummy = tummy.next;
        }
        //将剩余部分拼接过来
        tummy.next = left == null ? right : left;
        return res.next;
    }
}
```

对数组做归并排序的空间复杂度为 O(n)O(n)，分别由新开辟数组O(n)O(n)和递归函数调用O(logn)O(logn)组成，而根据链表特性：

数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；
递归额外空间：递归调用函数将带来O(logn)O(logn)的空间复杂度，因此若希望达到O(1)O(1)空间复杂度，则不能使用递归。



对于链表无需数组空间，只需要



**时间O(NlogN)  **

**空间O(logN)**





---



**从底至顶归并排序**



merge单元大小：intv = 1, 2, 4.......

将链表切分为不同长度的单元  再合并



仅根据intv来计算每个单元边界，并完成链表的每轮排序合并



![image-20201125155516161](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201125155516161.png)



- 统计链表长度`length`，用于通过判断`intv < length`判定是否完成排序；

- 执行排序合并时，需要一个辅助节点作为头部，而`res`则作为链表头部排序合并时的辅助头部`pre`；后面的合并排序可以将上次合并排序的尾部`tail`用做辅助节点。



时间复杂度**O(nlogn)**，空间复杂度**O(1)**。

```java
/*
每一对需要merge的分链表的 头结点都有 引用h1 h2，也无需进行什么措施。

h是在合并之前就指在了下一对的位置，(或者null)但merge过后的res开头的链表不一定和h正好连着，(也有一定可能，刚好后面一条链表没有用完，整个接在了pre的后面)

否则如果右边的链表用完了，就没有指针引用指向h节点了。所以需要将pre节点指向merge过后的尾部，并且pre.next = h;
*/
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        int length = 0, interval = 1;
        ListNode h = head;
        while(h != null){
            length++;
            h = h.next;
        }
        ListNode res = new ListNode(0);
        res.next = head;

        while(interval < length){
            //每轮merge从头结点开始
            h = res.next;
            ListNode pre = res;

            //merge一轮 直到h走完这条链表
            while(h != null){
                ListNode h1 = h, h2;
                int i = interval;
                //i
                while(i > 0 && h != null){
                    h = h.next; i--;
                }
                //如果还剩的有i，说明已经到链表结尾了。无法完成形成两个链表，只能形成第一个
                if(i > 0) break;

                h2 = h;i = interval;
                while(i > 0 && h != null){
                    h = h.next; i--;
                }
                //第二条链表的长度可以不为interval，可以短一点
                int c1 = interval, c2 = interval - i;

                while(c1 > 0 && c2 > 0){
                    if(h1.val < h2.val){
                        //pre作为头节点  来进行每一次的归并操作
                        pre.next = h1;
                        h1 = h1.next;
                        c1--;
                    }else{
                        pre.next = h2;
                        h2 = h2.next;
                        c2--;
                    }
                    pre = pre.next;
                }
                pre.next = c1 > 0 ? h1 : h2;
                
                //将pre移动到这一组merge的最后一个节点的位置
                while(c1 > 0 || c2 > 0){
                    pre = pre.next;
                    c1--;c2--;
                }
                //将pre.next连接上下一组节点的开头，即：h
                pre.next = h;
            }
            interval *= 2;
        }
        return res.next;
    }
}
```









## 1370. 上升下降字符串



```java
class Solution {
    public String sortString(String ss) {
        char[] s = ss.toCharArray();
        //每个桶中装着
        int[] bucket = new int[26];
        for(int i = 0; i < s.length; i++){
            bucket[s[i] - 'a'] ++;
        }

        StringBuffer sb = new StringBuffer();
        while(sb.length() != s.length){

            for(int i = 0; i < 26; i++){
                if(bucket[i] > 0){
                    sb.append((char)('a' + i));
                    bucket[i]--;
                }
            }
            for(int i = 25; i >= 0; i--){
                if(bucket[i] > 0){
                    sb.append((char)('a' + i));
                    bucket[i]--;
                }
            }
        }
        return sb.toString();
    }
}
```









## 164. 最大间距



---

**基数排序RadixSort**

```java
class Solution {
    public int maximumGap(int[] nums) {
        if(nums.length < 2){
            return 0;
        }
        long exp = 1;
        int max = 0;
        int[] pre = new int[nums.length];
        for(int i : nums){
            max = Math.max(i, max);
        }
        //detail：需要>=  若出现[1, 1000000] 10的次方的数，基数排序结果会是1 > 1000000
        while(max >= exp){
            int[] radix = new int[10];
            for(int i = 0; i < nums.length; i++){
                int digit = (nums[i] / (int)exp) % 10;//从个位开始依次取这一位的数排序
                radix[digit]++;
            }
            //detail：累加计数和
            for(int i = 1; i < 10; i++){
                radix[i] += radix[i - 1];
            }
            
            // 重点：从后往前遍历是为了维持前一位排序过的顺序。
            // radix[]数组累加得到：这一位的排序能排到第几。
            // 从后至前遍历：遍历到的数(通过当前位索引)也是排在后面，再将radix的计数--，
            // 下一个遍历到的这一位相同的数radix[i-1]，必定是前一位小于radix[i]的。所以维持了前一位的顺序
            for(int i = nums.length - 1; i >= 0; i--){
                int digit = (nums[i] / (int)exp) % 10;
                pre[radix[digit] - 1] = nums[i];
                radix[digit]--;
                
            }
            System.arraycopy(pre, 0, nums, 0, nums.length);
            exp *= 10;

        }
        int ret = 0;
        for (int i = 1; i < nums.length; i++) {
            ret = Math.max(ret, nums[i] - nums[i - 1]);
        }
        return ret;
    }
}
```

**时间O(N) （如果数很大，N前面有很大的系数 约为31）    **

**空间O(N)**



****

`Arrsys.sort(nums)`就完事了

快的一批



---

**桶排序**



数组长度为N  则 **(max - min)  /  (N - 1)     <=   排序后   任意相邻数的差**

<u>N个数， 有N-1个间隙，如果N-1 = max-min  则间隙均为1</u>

<u> N-1 < max-min  则会出现稍大的间隙</u>



相邻元素之间的**最大间距**一定不会出现在某个**桶的内部**，而一定会出现在**不同桶当中**。

因此，在找出每个元素所在的桶之后，我们可以维护每个桶内元素的最大值与最小值。随后，只需从前到后不断比较相邻的桶，用**后一个桶的最小值与前一个桶的最大值之差**作为两个**<u>桶的间距</u>**

```java
class Solution {
    public int maximumGap(int[] nums) {
        if(nums.length < 2){
            return 0;
        }
        int max = 0, min = Integer.MAX_VALUE;
        for(int i = 0; i < nums.length; i++){
            max = Math.max(max, nums[i]);
            min = Math.min(min, nums[i]);
        }
        int delta = max - min;
        //在右重复值的情况，会出现length >= max-min 这种情况将桶的大小设置为1就行，把重复的数装进去。
        int width = Math.max(1, delta / (nums.length - 1));
        int size = (max - min) / width + 1;

        int[][] buckets = new int[size][2];
        for(int[] bucket : buckets){
            Arrays.fill(bucket, -1);
        }

        for(int i = 0; i < nums.length; i++){
            int index = (nums[i] - min) / width;
            //桶中原先没数，就将桶中最大最小值都设为nums[i]
            if(buckets[index][0] == -1){
                buckets[index][0] = buckets[index][1] = nums[i];
            }else{
                buckets[index][0] = Math.min(buckets[index][0], nums[i]);
                buckets[index][1] = Math.max(buckets[index][1], nums[i]);
            }
        }

        //res设置为0  (可能是会出现重复？ 但又好像不考虑重复出现的情况 ) 应该可以设为1？
        //目的是找最大值.....搞错了。。不能用1  有这个测试用例[1,1,1,1]...大意了
        //相同的值会分到一个桶中，无须担心  最大值还是会出现在两个桶之间或者就是0
        int res = 0;int pre = -1;
        for(int i = 0; i < buckets.length; i++){
            if(buckets[i][0] == -1){
                continue;
            }
            //pre == -1 说明还没找到第一个有数的桶....
            //pre记录的是上一个有数字的桶
            if(pre != -1){
                res = Math.max(buckets[i][0] - buckets[pre][1], res);
            }
            pre = i;
        }
        return res;
    }
}
```













## 493. 翻转对



**不需要考虑在当前两个待合并数组内的*重要翻转对***， 因为在递归时就已经考虑过，**只需要考虑跨数组间的翻转对**

*当进行到当前两个子数组时，这两个子序列一定是**有序的***

```java
class Solution {
    public int reversePairs(int[] nums) {
        if(nums.length == 0){
            return 0;
        }
        return DevideRecursive(nums, 0, nums.length - 1);
    }

    public int DevideRecursive(int[] nums, int l, int r){
        //别忘了递归边界
        if(l == r){
            return 0;
        }
        int m = (l + r) / 2;
        int numl = DevideRecursive(nums, l, m);
        int numr = DevideRecursive(nums, m + 1, r);

        int res = numl + numr;

        //统计下标对的数量
        int i = l, j = m+1;
        while(i <= m){
            // 左右两边都已经是归并排序完成的数组  有序
            // 细节啊...   long要对nums[j]转化再进行*2  一开始没想到...(long)2*nums[j] 这样可能得到的就是个溢出的结果
            while(j <= r && (long)nums[i] > (2 * (long)nums[j]) ){
                j++;
            }
            //while停止时的j 已经没法满足条件了  右侧数组j之前的数均满足条件  res += [m + 1, j - 1].length
            res += (j-1) - (m+1) + 1;
            i++;
        }

        //随后需要合并当前两个数组
        int sorted[] = new int[r - l + 1];
        int p = 0;
        int p1 = l, p2 = m+1;
        //这个合并方法真不错.....
        while(p1 <= m || p2 <= r){
            if(p1 > m){
                sorted[p++] = nums[p2++];
            }else if(p2 > r){
                sorted[p++] = nums[p1++];
            }else{
                sorted[p++] = nums[p1] > nums[p2] ? nums[p2++] : nums[p1++];
            }
        }

        //将归并好的数组拷贝回原数组。
        System.arraycopy(sorted, 0, nums, l, sorted.length);

        return res;
    }
}
```











## 327. 区间和的个数



**利用到了归并排序的特性：**

在进行**归并操作之前**：两个数组/元素 相对于彼此是有先后顺序的，进行归并后只是合并成了母数组

**但 ！！ 母数组相对于另一个分裂开的母数组：也是有相对顺序的**



对于本题而言：

- 先求前缀和（注意下标：preSum[i]表示的是下标 < i 的数之和）
- 对前缀和进行二分递归，**每一次的比较实际上都是后面的前缀和 - 前面的前缀和，顺序并不会乱**
- 对已经处理完的两个子数组进行合并，**返回并  与上一级继续比较，** 此时上一级另一个数组也合并完成，二者(当做整体)的相对顺序没有变啊！ ***这个得理解到胃了！*** preSum[rp/lp] - preSum[i]还是子序列和，**但这个和在之前归并中没有计算到，跨两个数组的比较！**





![image-20201129224625092](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201129224625092.png)

> 细节写的像shit一样。。。
>
> 写出来之前先动脑子想想逻辑。。
>
> **要求∈[lower, upper]: **
>
> ***<u>要找刚好大于等于 lower 的位置 lp，刚好大于 upper的位置rp（也没法直接找刚好小于等于upper的位置）</u>***
>
> 才能求得包括lower 和 upper的区间

```java
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        //防止溢出
        long s = 0;
        long[] preSum = new long[nums.length + 1];
        //大bug！仔细分析！
        //前缀和 preSum[i]应该是不包括nums[i]的，是小于i的数累加得到，
        //这样作差preSum[j] - preSum[i]才会得到Sum(nums[i] ~ nums[j-1])

        //preSum[x] - preSum[0]就也相当于nums[0]累加到nums[x-1]
        //preSum[x] - preSum[1]就也相当于nums[1]累加到nums[x-1]
        for(int i = 0; i < nums.length; ++i){
            s += nums[i];
            preSum[i + 1] = s;
        }

        return count(preSum, lower, upper, 0, preSum.length - 1);
    }

    public int count(long[] preSum, int lower, int upper, int l, int r){
        //递归终止
        if(l == r){
            return 0;
        }

        //对两个子数组递归求解
        int m = (l + r) / 2;
        int sl = count(preSum, lower, upper, l, m);
        int sr = count(preSum, lower, upper, m+1, r);
        int res = sl + sr;

        int i = l, lp = m + 1, rp = m + 1; 
        //考虑到  如果rp=m+1时就已经满足条件（nums[rp] - nums[i] > upper），
        //那么则也会有lp=m+1  （肯定也满足 (nums[m+1] - nums[i] < lower)）
        //rp-lp=0 右边数组都不成立
        while(i <= m){
            //直到他们的差刚好  >=lower那个数就停
            while(lp <= r && preSum[lp] - preSum[i] < lower){
                lp++;
            }
            //差 > upper 就停 多了一位
            while(rp <= r && preSum[rp] - preSum[i] <= upper){
                rp++;
            }
            //脑瘫..rp lp写成r l了...  检查了半小时...
            res += (rp-1) - lp + 1;
            i++;
        }
        merge(preSum, l, m, r);
        return res;
    }

    public void merge(long[] preSum, int l, int m, int r){
        long[] sorted = new long[r - l + 1];

        int lp = l, rp = m + 1, i = 0;
        while(lp <= m || rp <= r){
            if(lp > m){
                sorted[i++] = preSum[rp++];
            }else if(rp > r){
                sorted[i++] = preSum[lp++];
            }else{
                sorted[i++] = preSum[lp] > preSum[rp] ? preSum[rp++] : preSum[lp++];
            }
        }
        System.arraycopy(sorted, 0, preSum, l, sorted.length);
        return;
    }
}
```





# 最小生成树



## [1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)



> Kruskal算法与prim算法不同：
>
> Prim算法是以**顶点**为基础（每次寻找离Vnew集合**最近的顶点**）；
>
> 而Kruskal算法是以**边为基础**，每次从**边集合中寻找最小的边**（不管两个顶点属于V还是Vnew），然后判断该**边的两个顶点是否属于同一个连通图**。
>
> Kruskal需要对所有的边进行排序，然后从小到大，依次遍历每条边，同时判断每条边是否属于同一个连通图，直到所有顶点属于同一个连通图，算法结束。



> kruskal  
>
> 关键在，可以直接得到最短的边，但需要判断这两个顶点是否属于同一个连通图（即V / Vnew），这一步需要并查集，
>
> get 边 + 两个点x、y，只要不在并查集，就**贪心**的认为可以作为最小生成树的边
>
> 
>
> Prim  
>
> 初始点维护一个lowcost数组，Vnew集合每加入一个新的节点，就计算是否有更短的路径，**更新！**，就这么个思路。

**Kruskal算法（并查集）**



```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        if(points.length == 1){
            return 0;
        }
        
        int n = points.length;
        DisjoinSetUnion dsu = new DisjoinSetUnion(n);

        List<Edge> edges = new ArrayList<>();
        //获得每一对点之间的曼哈顿距离
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                edges.add(new Edge(dist(points, i, j), i, j));
            }
        }
        //按边从小到大排序
        //这里注意
        Collections.sort(edges, new Comparator<Edge>(){
            public int compare(Edge e1, Edge e2){
                return e1.len > e2.len ? 1 : (e1.len == e2.len) ? 0 : -1;
            }
        });

        int res = 0, num = 0;
        for(Edge e : edges){
            int len = e.len, x = e.x, y = e.y;
            //将x点、y点：即当前这个最短边的两个顶点  加入并查集
            //同时判断是否属于一个并查集
            if(dsu.unionSet(x, y)){
                //true->不属于一个并查集
                res += len;
                num++;
                if(num == n - 1){
                    break;
                }
            }
        }
        return res;
    }

    //Manhattan dist
    public int dist(int[][] points, int x, int y){
        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);
    }
}

class DisjoinSetUnion{
    int[] f;
    int[] rank;
    int n;

    public DisjoinSetUnion(int n){
        this.n = n;
        this.rank = new int[n];
        Arrays.fill(this.rank, 1);
        this.f = new int[n];
        for(int i = 0; i < n; i++){
            this.f[i] = i;
        }
    }
    public int find(int x){
        if(f[x] != x){
            f[x] = find(f[x]);
        }
        return f[x];
    }
    public boolean unionSet(int x, int y){
        int rootx = find(x), rooty = find(y);
        if(rootx == rooty){
            return false;
        }
        if(rank[rootx] > rank[rooty]){
            f[rooty] = rootx;
            rank[rootx] += rank[rooty];
        }else{
            f[rootx] = rooty;
            rank[rooty] += rank[rootx];
        }
        return true;
    }
}

//保存着每一对点之间的距离，x、y表示两个点在points中的index
class Edge{
    int len, x, y;
    public Edge(int len, int x, int y){
        this.len = len;
        this.x = x;
        this.y = y;
    }
}
```

时空复杂度都50%左右，效率较低



---



**Prim算法**



可以用**堆**来寻找最近的点，O(n^3) ???

也只能优化这一步，后面的更新堆中节点还是需要O(n)

但堆中就需要存放很多东西，也很难管理，要保存：从i1->i2这个信息，因为需要进行堆内调整比较，必须要存两个结点的索引。

```java
PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return find(points, o1[0], o1[1]) - find(points, o2[0], o2[1]);//比较距离
            }
        });
/*本来存的是i1 到 i2,i3...的最短距离，现在i2加入Vnew了，那么堆中就只需要把[i1,i2]这个数据poll出来就行，但没法像数组那样直接替换，在堆中如果要contains代价很大O(n) ，就只能在每次从堆中取出时判断是否是有效的点（即：V-Vnew）
就需要把每个边都加进去，所以时间复杂度是M logN
而且M的复杂度是n^2 ？？就是边数 (n-1) + (n-2) + (n-3)....分别是第一次加入堆的边数，第二次加入堆的边数。。。
然后需要把这里面加入的所有边都从堆顶取出  遍历一遍，查看是否符合条件，不符合条件的就直接跳过，继续poll

Prim堆优化时间复杂度不对，每次向堆中存放的元素个数（就是每次更新Vnew中新元素对于所有V中元素的距离）为n-1, n-2,...  然后外圈需要遍历所有堆中的元素，这就是O(n^2)的复杂度  
然后内圈可以优化一下，将符合条件的最短边的端点记录，遍历points，将这个新加入Vnew的点对V中点的距离加入堆中，O(n)
*/
```



```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        if(points.length == 1){
            return 0;
        }
        int n = points.length;
        int res = 0;
        
        int[] nearest = new int[n];
        Arrays.fill(nearest, Integer.MAX_VALUE);
        int[] v = new int[n];//记录V中节点是否加入到Vnew
        Arrays.fill(v, -1);

        // 初始化nearest数组，Vnew只有i=0这个点
        v[0] = 0;
        for(int i = 0; i < n; i++){
            if(i == 0) continue;
            nearest[i] = dist(points, 0, i);
        }

        //加入剩余n-1个点，先找出最近的那个 
        for(int i = 1; i < n; i++){
            int minIndex = -1; 
            int minVal = Integer.MAX_VALUE;
            for(int j = 0; j < n; j++){
                if(v[j] == 0) continue; //如果j点已经加入Vnew集合，就跳过
                if(nearest[j] < minVal){ //找到最近的点 
                    minIndex = j;
                    minVal = nearest[j];
                }
            }

            v[minIndex] = 0;
            res += nearest[minIndex];
            //已加入Vnew集合中的点，距离更新为-1
            nearest[minIndex] = -1;

            //然后更新Vnew中新加入的点minIndex 到 V 中的每个点的最短距离 
            for(int j = 0; j < n; j++){
                if(v[j] == 0) continue;
                int dist = dist(points, j, minIndex);
                nearest[j] = dist > nearest[j] ? nearest[j] : dist;
            }
        }

        return res;
       
    }

    //Manhattan dist
    public int dist(int[][] points, int x, int y){
        return Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);
    }
}

```

![image-20210120032321330](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210120032321330.png)

还真挺快~





# 并查集



## [1202. 交换字符串中的元素](https://leetcode-cn.com/problems/smallest-string-with-swaps/)



> 并查集思路：
>
> - 数组parent[] 用于记录每一个节点的父节点，所有父节点相同的节点位于同一连通图
> - 数组rank[] 用于记录该节点目前的位于的树的深度（引入路径压缩后就不是这个意思了），**用于优化，在合并两个父节点时，通过rank大小判断谁父谁子**
> - `union`合并两个节点---即所属的并查集
>   - 如果属于同一个并查集，不需要合并
>   - 不属于同一个并查集，判断两个root 谁的`秩`大
> - 路径压缩 `find`，**遍历过程中的所有父节点直接指向根节点，减少后续查找次数**



```java
public class Solution {

    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
        if(pairs.size() == 0){
            return s;
        }

        // 1.将任意交换的节点对  输入并查集
        int len = s.length();
        UnionFind uf = new UnionFind(len);

        for(List<Integer> pair : pairs){
            int i1 = pair.get(0);
            int i2 = pair.get(1);
            uf.union(i1, i2);
        }

        // 2.构建映射关系
        char[] charArray = s.toCharArray();
        // ket:连通分量的代表元，value：同一个连通分量的字符集合，保存在一个优先队列中
        Map<Integer, PriorityQueue<Character>> map = new HashMap<>(len);

        for(int i = 0; i < len; i++){
            int root = uf.find(i);//找到s串中每个字符对应并查集的根节点
            if(map.containsKey(root)){
                map.get(root).offer(charArray[i]);//向这个代表元的字符集合中添加新的字符
            }else{
                PriorityQueue<Character> minHeap = new PriorityQueue<>();
                minHeap.offer(charArray[i]);
                map.put(root, minHeap);
            }
            //map.computeIfAbsent(root, key -> new PriorityQueue<>()).offer(charArray[i]);
        }

        // 3.重组字符串
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < len; i++){
            int root = uf.find(i);
            sb.append(map.get(root).poll());
        }

        return sb.toString();
    }


    public class UnionFind{
        //每个节点的父节点
        private int[] parent;

        private int[] rank;//i为根节点子树的高度

        public UnionFind(int n){
            this.parent = new int[n];
            this.rank = new int[n];
            for(int i = 0; i < n; i++){
                this.parent[i] = i;
                this.rank[i] = 1;
            }
        }

        public void union(int x, int y){
            //直接找到对应的根节点，整棵树后续直接插到根节点上 路径压缩后的宽树-----
            int rootX = find(x);
            int rootY = find(y);
            if(rootX == rootY){//属于同一个根节点
                return;
            }

            if(rank[rootX] == rank[rootY]){
                parent[rootX] = rootY;
                //此时以rootY为根节点的树的高度仅增加了1
                rank[rootY]++;
            } else if(rank[rootX] < rank[rootY]){
                parent[rootX] = rootY;
                //此时以rootY为根节点的树的高度不变 因为本来Y就比X大
            } else{
                parent[rootY] = rootX;
            }
        }
        //这一步就使用了路径压缩，递归。从上至下将路径上每个节点都直接指向根节点
        public int find(int x){
            if(x != parent[x]){//没有递归寻找到并查集的 根 节点，继续递归向上寻找，并且将
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
    }
}
```



> 按秩合并(`启发式合并`)：「启发」的意思是：「依据经验」、「尝试」、「探测」，在可接受误差的情况下行之有效的算法策略。简而言之：虽然不精确、达不到最优，但好过没有；「路径压缩」和「按秩合并」一起使用的时候，难以维护「秩」准确的定义，但依然具有参考价值。这是因为：虽然 rank 不是此时树的精确高度，但是不会出现树 a 的高度比树 b 结点高，但是树 a 的 rank 却比树 b 的 rank 低的情况。
>
> 





## [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)



```java
class Solution {
    //因为name有重复，就根据邮箱对应的index进行合并，使用每一条account信息中对应的email -> index，在并查集中合并

    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        //记录每个邮箱对应的编号
        Map<String, Integer> emailToIndex = new HashMap<>();
        //记录每个邮箱对应的人名
        Map<String, String> emailToName = new HashMap<>();
        int emailsCount = 0;

        //将邮箱、名字 存入对应的哈希表
        //以邮箱名为key，每个邮箱只出现一次，且对应一个人名，每个人名可能对应多个邮箱
        for(List<String> account : accounts){
            String name = account.get(0);
            for(int i = 1; i < account.size(); i++){
                String email = account.get(i);
                if(!emailToIndex.containsKey(email)){
                    emailToIndex.put(email, emailsCount++);
                    emailToName.put(email, name);
                } 
            }
        }

        //按照每个邮箱unique index，来对所有邮箱进行并查，合并
        UnionFind uf = new UnionFind(emailsCount);
        
        //每一个account内的几个email都属于一个并查集，连起来
        for(List<String> account : accounts){
            String firstEmail = account.get(1);
            int firstIndex = emailToIndex.get(firstEmail);
            for(int i = 2; i < account.size(); i++){
                String email = account.get(i);
                int index = emailToIndex.get(email);
                uf.union(firstIndex, index);
            }
        }
        
        Map<Integer, List<String>> indexToEmail = new HashMap<>();
        
        //通过每个邮箱唯一索引index，将  同属于同一个并查集  的email都找出来合为list，以index为key，加入哈希表中
        //每个并查集根节点  对应一个邮箱列表，代表这个并查集所有邮箱
        for(String email : emailToIndex.keySet()){
            int index = uf.find(emailToIndex.get(email));
            List<String> account = indexToEmail.getOrDefault(index, new ArrayList<String>());
            account.add(email);
            indexToEmail.put(index, account);
        }

        List<List<String>> res = new ArrayList<>();
        for(List<String> emails : indexToEmail.values()){
            //对一个并查集内的email进行排序；
            Collections.sort(emails);
            String name = emailToName.get(emails.get(0));//随便找一个这个分量中email对应的name
            List<String> account = new ArrayList<>();

            //将name 和 排序完成的 同一个并查集内的所有emails都加入这条结果
            account.add(name);
            account.addAll(emails);
            res.add(account);
        }

        return res;
    }

}
class UnionFind{
    int[] parent;

    public UnionFind(int n){
        parent = new int[n];
        for(int i = 0; i < n; i++){
            parent[i] = i;
        }
    }

    public void union(int x, int y){
        parent[find(x)] = find(y);//不用考虑秩来合并
    }

    public int find(int x){
        if(parent[x] != x){
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```



---



和解法一不同之处在于：

整理每个邮箱，同时将他们在accounts中所在信息的索引作为其index（**最多也就n个索引**），同时进行 并查集的union，这样得到的map就是：**邮箱名——并查集父节点（在accounts中的索引，*便于后续直接通过index来得到name* ）**

解法一是通过邮箱名和index的map来得到name，耗空间~

```java
//1 按照账户的索引的并查集
//2 建立第一个hashmap<邮箱:父节点>,存储的是每个邮箱对应的账户索引,若此邮箱出现过,则将两个账户对应的索引连接
//3 遍历hashmap,hashmap2根据每个邮箱对应的索引对应的并查集的根为新的键,键值为邮箱列表list
//4 根据hashmap2将键值更新为账户,加入到邮箱中并整理结果

class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        //1 建立并查集父节点 账户名为并查集节点
        int n = accounts.size();
        int[] parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        //2 遍历每条数据，map中存放  email->在accounts中是第几条数据，即父索引
        //  邮箱号  ----  并查集根节点 索引
        //无需通过index单独对邮箱号进行并查，
        Map<String,Integer> map = new HashMap<>();//加入新的email同时，进行并查集合并，父节点
        for (int i = 0; i < n; i++) {
            List<String> account = accounts.get(i);
            for (int j = 1;j < account.size();j++) {
                String s = account.get(j);
                if(map.containsKey(s)){
                    union(parent,map.get(s),i);
                }else {
                    map.put(s,i);
                }
            }
        }
//        System.out.println(Arrays.toString(parent));
//        System.out.println(map);
        //建立hashmap2
        Map<Integer,List<String>> temp = new HashMap<>();//index->邮箱list
        
        List<List<String>> ret = new ArrayList<>();
        Set<String> set = map.keySet();//所有email集合，key
        
        for (String s:set) {
            int key = find(parent,map.get(s));//并查集代表元，就是accounts中索引
            
            if(temp.containsKey(key)){
                temp.get(key).add(s);
            }else{
                List<String> a = new ArrayList<String>();
                a.add(s);
                temp.put(key,a);
            }
        }
        //4 整理结果
        for (int key:temp.keySet()) {
            List<String> r = temp.get(key);
            Collections.sort(r);//注意要排序
            r.add(0, accounts.get(key).get(0));//根据对应accounts中的索引，将用户名加入列表
            ret.add(r);
        }
        return ret;
    }

    private void union(int[] parent, int i, int j) {
        parent[find(parent,i)] = find(parent,j);
    }

    private int find(int[] parent, int i) {
        if(parent[i] != i){
            parent[i] = find(parent,parent[i]);
        }
        return parent[i];
    }

}
```





# 贪心





## 1024. 视频拼接

动态规划：

用过的片段，会影响之后对片段的选用，**过去的状态影响当前状态**，有 DP 的味儿了。



定义 `dp[j]`，表示：**覆盖 `[0, j]`区间的最少片段数**，题目是**求 `dp[T]`**



**dp的思想是能少用就少用  尽量把当前这个区间*<u>用完</u>*，再换下一个可用的区间**



```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] dp = new int[T + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        //空区间的初始值为0
        dp[0] = 0;

        for(int i = 1; i <= T; i++){
            for(int[] clip : clips){
                if(i <= clip[1] && i > clip[0]){
                    //遍历每个区间，区间开始的地方数量+1  
                    //取最少的
                    //就是要把每个区间榨干......
                    //如果过了上个使用的区间的右边界，对于新的一个区间
                    //从新区间的左边界位置dp[clip[0]] + 1
                    //那个左边界位置可以保证是最小的数量
                    dp[i] = Math.min(dp[clip[0]] + 1, dp[i]);
                }
            }
        }
        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];
    }
}
```

![image-20201024230632811](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024230632811.png)

时间复杂度：O(T*N)   其中T是区间的长度  N是子区间的数量

慢！

空间复杂度：O(T)



---

贪心：

```java
//贪心思想  始终走到最远的位置，最大化使用前面的区间
class Solution {
    public int videoStitching(int[][] clips, int T) {
        int[] rec = new int[T];
        int max = 0, pre = 0, res = 0;
        for(int[] clip : clips){
            if(clip[0] < T){
                rec[clip[0]] = Math.max(rec[clip[0]], clip[1]);
            }
        }

        for(int i = 0; i < T; i++){
            //max代表在i位置前   单个  区间  能达到的最远距离
            max = Math.max(max, rec[i]);
            //如果在i位置，max不能比i大？那就只能遍历到这了
            //如果max > i,表示还可以再往前走一走
            if(i == max){
                return -1;
            }
            //pre 记录 上一个 被使用 的 子区间的  结束 位置
            //i == pre 表示上一个子区间已经用完了，并且(max > i)，还能再往前走，结果数量+1
            //将pre 更新为当前使用的区间的max(能走的最远距离)
            if(i == pre){
                res++;
                pre = max;
            }
        }
        return res;
    }
}
```

![image-20201024220031239](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201024220031239.png)

时间复杂度：O(T + N)

空间复杂度：O(T)









## 55. 跳跃游戏



```java
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1){
            return true;
        }
        int[] max = new int[nums.length];
        max[0] = nums[0];
        for(int i = 1; i < nums.length; i++){
            max[i] = Math.max(i + nums[i], max[i - 1]);
        }

        int to = 0;
        int maxi = 0;//能到达的最远距离
        for(int i = 0; i < nums.length - 1; i++){
            maxi = Math.max(maxi, max[i]);

            if(maxi == i){
                return false;
            }

            if(i == to){
                to = maxi;
            }
        }
        return true;
    }
}
```





```java
class Solution {
    public boolean canJump(int[] nums) {
        int rightMax = 0;
        for(int i = 0; i < nums.length; i++){
            //提前结束：  如果i>rightMax  不需要再进行操作了，等着循环完事直接退出就行
            if(i <= rightMax){
                rightMax = Math.max(nums[i] + i, rightMax);

                if(rightMax >= nums.length - 1){
                    return true;
                }
            }else{
                return false;
            }
        }
        return false;
    }
}
```





## 452. 用最少数量的箭引爆气球



选择原本 **右边界最靠左的气球**  ，其他球的**左边界是未知的，但右边界一定更靠右**。

**贪心  -->  选择右边界扎！   可以尽可能扎到多的气球**





用区间的尾部排序貌似效率会更好, 因为已经保证后面的区间右侧都是大于当前区间, 所以**将发射点设置在右侧边界**, **如果后面的区间  左边界比这个最左侧的右边界更靠左，则可以一起被扎爆**



example: [[10,16],[2,5],[3,6],[7,12]] 为例子:

先排序, 按区间结束位置排序, 排序后: [[2,5],[1, 6],[4, 11],[7,12],[10,16]]
遍历***计算交叉区间***,
**发射点**初始化为pos = 5, 需要的箭数量 arrows = 1;
区间[3, 6], 3 是小于5的, 在点5射箭可以干掉这个区间

同理[4, 11]  4 < 5 也可以干掉这个区间



> 这里注意：最终其实还是取的交集    
>
> [2, 5]  ->  [3, 5] -> [4, 5]   并且选择射入箭的位置是这个交集的最右侧（即第一个射入区间的右边界）
>
> **这样可以使得能射入尽可能多的区间**

区间[7, 12], 在5的位置射箭无法打掉, 说明需要增加一个新的发射点, 新的待发射点pos = 12
区间[10,16], 10 < 12那么在12位置射箭可以干掉它
返回需要射击点数量



**找多个集合交集内的一个点就可以，这里是找*交集的右边界***

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length == 0){
            return 0;
        }

        //使用比较而不是作差....作差直接溢出！
        Arrays.sort(points, new Comparator<int[]>() {
			public int compare(int[] o1, int[] o2) {
				return o1[1] < o2[1] ? -1 : 1;
			}
		});

        //不讲武德  [[-2147483648,2147483647]]  
        //本来是把tem_right设为Integer.MIN_VALUE 大意了
        int num = 1, tem_right = points[0][1];
        for(int i = 0; i < points.length; i++){
            if(tem_right < points[i][0]){
                num++;
                tem_right = points[i][1];
            }
        }
        return num;
    }
}
```





---

from 题解

**按区间开始排序**

**也可以每次判断当前区间和射入的区间是否有交集，只是会多一点计算**

> 和其他合并区间类的题目套路一样, 都是贪心思想, 先排序, 然后遍历检查是否满足合并区间的条件
> 这里判断是否有交叉区间, 所以其实是**计算已知区间的交集数量**.
> 这里以[[10,16],[2,8],[1,6],[7,12]] 为例子:
>
> 先排序, 我是按区间开始位置排序, 排序后: [[1,6],[2,8],[7,12],[10,16]]
> 遍历计算交叉区间(待发射箭头),
> 待发射箭头的区间range = [1, 6], 需要的箭数量 arrows = 1;
> 区间[2, 8], 和带发射区间[1, 6]有交集: 更新发射区域为它们的交集 range = [2, 6]
> 区间[7, 12], 和待发射区间[2, 6]没有任何交集, 说明需要增加一个**新的发射区域**, 新的待发射区域range = [7, 12]
> 区间[10,16], 和待发射区域[7, 12]有交集, 待发射区域更新为[10, 12]
> 返回需要待发射区间的个数



**交集  --->  待/可 发射区域**

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length == 0){
            return 0;
        }

        //使用比较而不是作差....作差直接溢出！
        Arrays.sort(points, new Comparator<int[]>() {
			public int compare(int[] o1, int[] o2) {
				return o1[0] < o2[0] ? -1 : 1;
			}
		});

        int /*l = points[0][0],*/ r = points[0][1];

        //不讲武德   [[-2147483648,2147483647]]

        //按照区间左端点排序，那就判断其他区间的右端点是否和这个区间有交集
        //后面的区间  左端点一定大于--可射区间--的左端点
        int num = 1;
        for(int i = 1; i < points.length; i++){
            
            //这里需要用  >=   当前区间的左边界和交集的右边界重合，取交集，就是一个 点
            if(r >= points[i][0]){
                //l = points[i][0];//交集   取左端点中最右边的一个点
                r = points[i][1] > r ? r : points[i][1]; // 取右端点中最左边的一个点
            }else{
                //否则就说明交集在下一个区间的左侧，无法射到了~
                //l = points[i][0];
                r = points[i][1];
                num++;
            }
        }
        return num;
    }
}
```





> 方法二就是在判断右侧端点里最靠左侧的一个（因为左侧端点已经排序完成）-->  不断**取交集**其实也就是在寻找最小的右端点，只要你这个区间的左端点  小于我这个右端点，就是能射到
>
> **最极端情况是交到一个点上，**
>
> 按照右端点来排序只会有两种情况：（**右端点肯定是大于r**）
>
> - 左端点 < r
> - 左端点 > r
>
> 
>
> 考虑一种情况：（按右端点排序顺序）
>
> [l, r]
>
> [l' > r, r']
>
> [l'' < r, r'']
>
> **在第二个区间时就需要再射一箭**，虽然第一个区间射的也能覆盖到第三个区间，但因为是 **根据右端点排序，这个区间归第二个区间管。。**为了射第二个区间，无法避免的重复
>
> 若按方法二来：则第三个区间会交在一起，



**按右端点排序就只需要考虑哪一个区间的左端点落在了r的左边，就是射的到的！**

> |       **|** <--
>
> ​              |    **|** <--
>
> ​     |                   **|**
>
> ​            		   |          **|** <--
>
> 后面一个区间的右端点**总是大于前一个**区间的右端点，如果它的左端点小于r，就完全可以一起射
>
> 如果大于r，就再起一个。
>
> ***如果下一个区间的左端点是小于r的，那么就是横跨在射箭位置。***
>
> 总会包含到的，不会遗漏





----

**以下是纠结了一晚上的思考结果....**

![image-20210103165250854](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210103165250854.png)



> 随着遍历，左边界肯定越来越大（按照左边界排序）
>
> 那么就是取决于不断增加的左边界（**可以忽略，因为每次都是用当前区间的做边界来和r进行比较**）  &&  最小的右边界形成的**交集**
>
> 按右边界来排序，得到的是固定的右边界和未知的左边界
>
> 直接选择最小的右边界作为基准，左边界小于r的全部通过
>
> 
>
> 按左边界来排序，得到的是递增的左边界和位置的右边界
>
> 不断限定**交集的右边界  --->   就相当于使用最小的右边界，射一箭，然后再找最小的右边界来。**

**实际两种方法射出去的点都是一样的（按左边界排序都选择交集的右边界来射）**





## 976. 三角形的最大周长



**贪心+排序**



排序后，枚举<u>*最长边a[i]*</u>.**只需要用两个短边相加和最长边比较即可**

如果a[i-1] + a[i-2] > a[i]  则说明这最长的三条边**可以组成一个三角形** 且 **周长最大**



> 会不会是不连续的？
>
> 应该是没有的，用反证法可以证明。从小到大排序后得到数组：a,b,c,d,e,f 。 假设由不连续的三个数b , e ,f 组成的三角形周长C1最大，则有C1 = b + e + f。 因为d > b，而b, e ,f 能组成三角形，说明b + e > f; 又因为 d > b，所以 d + e > f也成立，也就是 d e f也能组成三角形，且他的周长C2 = d + e + f，因为d > b，所以d + e + f > b + e + f，因此C2 > C1，因此题目原假设由不连续的三个数b , e ,f 组成的三角形周长C1最大不成立

**如果这连续的三个数无法构成三角形，则a[j | j < i - 2 ] 也无法构成三角形  **

**因为a[j] < a[i-2]**



从贪心的角度考虑，我们一定是选「***小于 c 的最大的***  两个数」作为边长 a 和 b，此时最有可能满足 a+b>c，使得三条边能够组成一个三角形，且此时的三角形的周长是最大的。



```java
class Solution {
    public int largestPerimeter(int[] A) {
        Arrays.sort(A);

        for(int i = A.length - 1; i >= 2; i--){
            if(A[i-1] + A[i-2] > A[i]){
                return A[i] + A[i-1] + A[i-2];
            }
        }
        return 0;
    }
}
```







## 767. 重构字符串



**计数 + 贪心**



> 如果长度n为奇数，那么下标从0开始 以偶数结束 **偶数下标个数>奇数**

- 如果数量最多的字母频次>(n+1)/2  , 那么必然会相邻
- 如果数量最多的字母频次 = (n+1)/2  && **n为奇数**, 那么将其全安排在***偶数下标* 位置**
- 其他情况  比如n为偶数，那么**下标中奇偶数量相等**，放哪都可以



1. 先考虑奇数下标，只要 字母出现次数 <= n/2，就放在奇数下标
2. 字母的出现次数**大于 n/2（  (n+1)/2  ）**，或 奇数下标 超出数组下标范围，才放在偶数下标





> - 如果 nn 是奇数且存在一个字母的出现次数为 (n+1)/2(n+1)/2，则该字母全部被放置在偶数下标，其余的 (n-1)/2(n−1)/2 个字母都被放置在奇数下标，因此相邻的字母一定不相同。
>
> - 如果同一个字母**全部被放置**在奇数下标或全部被放置在偶数下标，则该字母不可能在相邻的下标出现。
>
> - 如果同一个字母先被放置在**奇数下标**直到奇数下标超出数组下标范围，然后被放置在**偶数下标**，由于该字母的**出现次数不会超过 n/2**，因此该字母的最小奇数下标与最大偶数下标之差不小于 3，不可能在相邻的下标出现。
>
>   **次数<=2/n **
>
>   **如果相邻？？ 那么他的次数就必然是 >= (n+1)/2**



基于计数的贪心算法可以确保相邻的字母都不相同，得到正确答案



```java
class Solution {
    public String reorganizeString(String S) {
        if(S.length() == 2){
            return S;
        }
        char[] s = S.toCharArray();
        int[] count = new int[26];
        int max = 0;
        for(int i = 0; i < s.length; i++){
            count[s[i] - 'a']++;
            max = Math.max(count[s[i] - 'a'], max);
        }

        //如果超过了length+1 /2 必然会出现相邻
        if(max > (s.length + 1) / 2){
            return "";
        }

        int oddi = 1, eveni = 0;
        
        //按序遍历a-z
        for(int i = 0; i < 26; i++){
            char c = (char)(i + 'a');

            //先填充奇数位
            while(count[i] > 0 && count[i] <= s.length / 2 && oddi <= s.length - 1){
                s[oddi] = c;
                count[i]--;
                oddi += 2;
            }

            //如果奇数位填充满了  /  count[i] = (s.length + 1) / 2，则需要单独填满偶数位才行
            //（如果length为偶数也可以先填充 偶数 往奇数偶数里填均可）
            while(count[i] > 0){
                s[eveni] = c;
                count[i] --;
                eveni += 2;
            }
        }
        return new String(s);
    }
}
```





---



**最大堆 + 贪心**



使用最大堆  **按出现次数** 来保存  **每次取两个数  堆顶和下一个，拼接到sb中，若只剩最后一个，且是出现次数最多的字符，可以保证不会和上一个相邻**

```java
class Solution {
    public String reorganizeString(String S) {
        if(S.length() == 2){
            return S;
        }
        char[] s = S.toCharArray();
        int[] count = new int[26];
        int max = 0;
        for(int i = 0; i < s.length; i++){
            count[s[i] - 'a']++;
            max = Math.max(count[s[i] - 'a'], max);
        }

        //如果超过了length+1 /2 必然会出现相邻
        if(max > (s.length + 1) / 2){
            return "";
        }

        Queue<Character> pq = new PriorityQueue<Character>(new Comparator<Character>(){
            public int compare(Character i, Character j){
                return count[i-'a'] > count[j-'a'] ? -1 : 1;
            }
        });
        for(int i = 0; i < 26; i++){
            if(count[i] > 0){
                pq.offer((char)(i + 'a'));
            }
        }

        StringBuffer sb = new StringBuffer();
        //每次取出两个  
        while(pq.size() > 1){
            char letter1 = pq.poll();
            char letter2 = pq.poll();
            sb.append(letter1);
            sb.append(letter2);
            int index1 = letter1 - 'a', index2 = letter2 - 'a';
            count[index1]--;
            count[index2]--;
            if (count[index1] > 0) {
                pq.offer(letter1);
            }
            if (count[index2] > 0) {
                pq.offer(letter2);
            }
        }
        //如果length为奇数，则再将最后一个拼接到结尾
        if(pq.size() == 1){
            sb.append(pq.poll());
        }

        return sb.toString();
    }
}
```







---



**纯数组操作...**



**大致流程如下：**



**1.** 对出现次数进行排序

**2.** 判断出现次数最大的字符是否 > (1 + s.length) / 2)，若大于，直接退出；若不大于，则说明**此串可以进行重构**

**3.** 需要一个索引nextChar:表示下一个与当前字符不同的字符的索引

**4.** 若: i没有遍历到s的结尾，但是此时nextChar已经遍历到结尾：则说明 **结尾处有连续的字符，可以将其与s开头的字符交换（这样交换不会使其相邻，因为开头的字符出现次数最多，但也不大于(1+s.length) / 2, 出现当前这种情况只能说明最多的字符次数不等于(1+s.length) / 2，不然就刚好插空排了）**

  **故而此方法合理**



时间O(N*N/2) 里面一层遍历nextChar最多只需要遍历一般的s.length即可找到 

空间O(26*2)...大概吧 还有排序递归O(logN) (不包括字符数组s)



因为这是第一个想到的办法，写完题解的两个方法后还是想把这方法写出来= =



```java
class Solution {
    public String reorganizeString(String S) {
        char[] s = S.toCharArray();
       
        int[][] help = new int[26][2];
        for(int i = 0; i < s.length; i++){
            help[s[i] - 'a'][1]++;
            help[s[i] - 'a'][0] = s[i] - 'a';
        }
        Arrays.sort(help, new Comparator<int[]>() {
			@Override
			public int compare(int[] o1, int[] o2) {
				return o1[1] < o2[1] ? 1 : -1;
			}
		});

        if(help[0][1] > (1 + s.length) / 2){
            return "";
        }
    
        int p = 0;
        //按出现次数顺序赋值回原数组
        for(int i = 0; i <26; i++){
            while(help[i][1] != 0){
                s[p++] = (char)(help[i][0] + 'a');
                help[i][1]--;
            }
        }
        
        for(int i = 1; i < s.length; i++){
            if(s[i] == s[i-1]){
                int nextChar = i;
                while(nextChar < s.length && s[i] == s[nextChar]){
                    nextChar++;
                    if(nextChar == s.length){
                        //再从头开始遍历...比较....
                        nextChar = 0;
                    }
                }
                swap(s, i, nextChar);
            }
        }
        return new String(s);
    }
    public void swap(char[] s, int i, int j){
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
}
```













## 659. 分割数组为连续子序列



**因此，只有检查到某个数时，这个数未被消耗完，且既不能和前面组成连续子序列，也不能和后面组成连续子序列时**

**才无法分割**

```java
class Solution {
    public boolean isPossible(int[] nums) {
        //两个map
        //分别记录 每个数字出现的次数  以当前数结尾的--连续序列--个数
        //为啥要记录个数呢？
        //连续的多个数，如果前一个数只结束一个子序列，则不能再利用，若有多个，可以都接在后面
        Map<Integer, Integer> count = new HashMap<>(), tail = new HashMap<>();

        for(int num : nums){
            count.put(num, count.getOrDefault(num, 0) + 1);
        }

        for(int i = 0; i < nums.length; i++){
            int cnt = count.get(nums[i]);
            if(cnt <= 0){
                continue;
            }
            //可以接到上一个序列的后面?
            if(tail.getOrDefault(nums[i] - 1, 0) > 0){
                count.put(nums[i], cnt - 1);
                //覆盖以前一个数结尾的 子序列
                tail.put(nums[i] - 1, tail.get(nums[i] - 1) - 1);
                tail.put(nums[i], tail.getOrDefault(nums[i], 0) + 1);
                //找长度为3的连续子序列，将对应的数字消耗-1
            }else if(count.getOrDefault(nums[i] + 1, 0) > 0 && count.getOrDefault(nums[i] + 2, 0) > 0){
                count.put(nums[i], count.get(nums[i]) - 1);
                count.put(nums[i] + 1, count.get(nums[i] + 1) - 1);
                count.put(nums[i] + 2, count.get(nums[i] + 2) - 1);
                //当前以num+2结尾的子序列+1
                //新的子序列个数直接加一，
                tail.put(nums[i] + 2, tail.getOrDefault(nums[i] + 2, 0) + 1);
            }else{
                //前后两难？都不能构成连续序列
                //如果 nc[i] 为 0，说明这个数字已经消耗完，可以不管了
						//如果 nc[i] 不为 0，说明这个数字多出来了，且无法组成连续子序列，所以可以直接返回 false 了
                return false;
            }
        }
        return true;
    }
}
```



> 为什么不能先找连续的三个 再去判断是否能接到前面序列的尾部呢？
>
> 
>
> --> 处理多个相同的数，12345567
>
> ​	  出现连续的数应该是依次将其拼接到前面序列的尾部，在将前面的序列使用完了后，
>
> ​	  再去考虑从当前数开始往后寻找新的序列
>
> 如果每次都是先寻找新的序列，那么如果是三个数中间的那个数：如456->5，就无法拼接到任何一个子序列后面： **因为找不到恰好以4结尾的连续序列**
>
> **处理顺序问题**







---



用最小堆 保存以num结尾的序列的长度

每次新加入数x时，先判断是否能接到x-1的后面，**取长度最短的接**



> 和解法1不同，这个不是直接找长度为3的序列，而是一个一个加入进序列。
>
> **存在可以加入的序列时先加入，没有就以num开始一个序列**





过程见注释~

```java
class Solution {
    public boolean isPossible(int[] nums) {
        Map<Integer, PriorityQueue<Integer>> map = new HashMap<Integer, PriorityQueue<Integer>>();

        for(int num : nums){
            //如果第一次遍历到num，新放进一个map对
            if(!map.containsKey(num)){
                map.put(num, new PriorityQueue<Integer>());
            }

            //是否存在以 num - 1 结尾的序列
            if(map.containsKey(num - 1)){
                int length = map.get(num - 1).poll();//取出最短的一个序列，加上num
                if(map.get(num-1).isEmpty()){
                    map.remove(num-1);
                }
                map.get(num).offer(length + 1);
            }else{
                //num也不存在前驱序列...以num为序列头 开始
                map.get(num).offer(1);
            }
        }
			//如果有序列的长度小于3，则说明没有形成符合条件的序列
        for(PriorityQueue<Integer> pq : map.values()){
            if(pq.peek() < 3){
                return false;
            }
        }
        return true;
    }
}
```











## 330. 按要求补齐数组



```java
/*
	贪心
*/
class Solution {
    /**
	 * x从1开始，nums中必须要有1这个数
     * 如果碰到nums中的数，且小于等于x 才能将x的范围扩展到x+nums[i]-1
	 */
    public int minPatches(int[] nums, int n) {
        int res = 0;
        // n = 2147483647 如果不使用long，可能会无限循环
        long x = 1;
        int i = 0;
        int length = nums.length;

        //边界 需要包含n 所以在x==n时还需要再处理一次 (long)
        while(x <= n){
            //若nums[i] > x 则会造成 [x,y-1] 无法覆盖到
            //所以只有在y <= x时 才可以扩大覆盖范围
            if(i < length && nums[i] <= x){
                x += nums[i];
                i++;
            }else{
                x *= 2;
                res++;
            }
        }
        return res;
    }
}
```





## [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)



**贪心**

```java
class Solution {
    //右端点最小意味着不会占用后面的区间
    //就寻找  右端点最小  的区间，保证后续区间能尽可能多！后一个左端点与前一个右端点重合概率减小
    // [x1 y2 y2 x2] 尽管x左端点更小，但右侧占用了更多的位置，可能导致不重叠区间数量变少。
    
    //寻找最优策略，就是要使不重合区间数量最大。所以寻找最不占后面区间位置的，而不是最早开始的。
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length == 0){
            return 0;
        }
        int res = 1;
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[1] > b[1] ? 1 : -1;
            }
        });

        int preend = intervals[0][1];
        for(int i = 1; i < intervals.length; i++){
            //此处可以有共同的 区间边界
            if(intervals[i][0] >= preend){
                res++;
                preend = intervals[i][1];
            }
        }
        return intervals.length - res;
    }
}
```





## [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)



```java
class Solution {
    /*
    有m个位置，指的是这m个位置的两侧也为空位，在这m个位置里都可以种花而不违反规则。
    此时最多可以种 (m + 1)/2盆花
    */
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int prev = -1, add = 0;
        for(int i = 0; i < flowerbed.length; i++){
            if(flowerbed[i] == 1){
                //第一个花盆
                if(prev == -1){
                    add += i / 2;
                }else{
                    //可以种植花的位置数p = j - i - 1 - 2 这里面的位置都可以种
                    //分奇偶情况，都可以写为(p + 1) / 2 这就是最多数量(偶数+1不影响结果)
                    add += (i - prev - 2) / 2;
                }
                if(add >= n){
                    return true;
                }
                prev = i;
            }
        }

        if(prev == -1){
            add += (flowerbed.length + 1) / 2;
        }else{
            //右侧剩余的位置 / 2
            add += (flowerbed.length - 1 - prev) / 2;
        }

        return add >= n;
    }
}
```





---

**上面的方法有点复杂了。。。实际并不需要这么麻烦的逻辑**



> 一开始就是这么想的。。但没写出来具体逻辑思路。。把人给绕傻了。。就很烦    笨的一



> 原则：能种就种
>
> 以下情况可以种花：
>
> - 当前位置为空
> - 当前正在开头位置   ||   前一个位置为空
> - 当前正在末尾位置   ||   后一个位置为空
>
> **这样可以保证种的花数量最多！**

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        //已种好的花不会违反种植规则
        if(n == 0){
            return true;
        }
        int prev = 0, next = 0, add = 0;
        for(int i = 0; i < flowerbed.length; i++){
            if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)){
                n--;
                if(n == 0){
                    return true;
                }
                flowerbed[i] = 1;
            }
        }
        return false;
    }
}
```





---

**顶级李姐！**(from题解)



> 连跳两格的方法
>
> 因为如果遇到1,那么下一格子一定是0，这是毋庸置疑的（规则限定），
>
> - 如果下一个格子为1，那么i++  下一轮再i+2   那么在i+1这个位置上一定是空位，就不需要再判断前一个位置是否为空了
>
> **每次都是从1的格子上开始跳两格，可以不用判断前一个节点的状况**
>
> - 如果遇到最后一个格子，这也是在有花盆的位置开始跳了两步( i+1一定是空 )，所以直接填充即可

方法2的再次升级！



# 哈希表





## 454. 四数相加 II

```java
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();

        for(int i = 0; i < A.length; i++){
            for(int j = 0; j < B.length; j++){
                map.put(A[i] + B[j], map.getOrDefault(A[i] + B[j], 0) + 1);
            }
        }

        int sum = 0;
        for(int i = 0; i < C.length; i++){
            for(int j = 0; j < D.length; j++){
                sum += map.getOrDefault(-C[i] - D[j], 0);
            }
        }
        return sum;
    }
}
```



##  205. 同构字符串



双向映射 

> egg - add
>
> eag - add
>
> egg - acd

**只使用单向的映射可能会导致   多对一 / 一对多的问题**

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s.length() != t.length()){
            return false;
        }
        Map<Character, Character> map1 = new HashMap<>(), map2 =  new HashMap<>();
        char[] ss = s.toCharArray(), tt = t.toCharArray();
        for(int i = 0; i < ss.length; i++){
            
            if(map1.get(tt[i]) != null && map2.get(ss[i]) != null){
                if(map1.get(tt[i]) != ss[i] || map2.get(ss[i]) != tt[i]){
                    return false;
                }
            }else{
                //其中一个存在  说明匹配不上
                if(map1.get(tt[i]) != null || map2.get(ss[i]) != null){
                    return false;
                }else{
                    map1.put(tt[i], ss[i]);
                    map2.put(ss[i], tt[i]);
                }
            }
        }
        return true;
    }
}

/*  
逻辑简化
	eag  add
	将第一个else简化  如果后一个有出现：相同字符，却对应与map中不同的字符时，就直接认定为false
	不需要再判断是否是 只有一个map映射存在（即使结果也是false）
	if ((s2t.containsKey(x) && s2t.get(x) != y) || (t2s.containsKey(y) && t2s.get(y) != x)) {
   		return false;
   }
*/


```





# 堆



## 实现大顶堆





```java
	public void genHeap(int[] nums) {
		//从最后一个结点的父节点开始调整
		for(int i = (nums.length - 2) / 2; i >= 0; i--) {
			change(nums, i);
		}
	}
	
	/**
	 * 从最后一个有子结点的父节点(index:(length-2) / 2) 开始进行比较
	 * 将这个父节点与其(两个)子节点进行比较 - 交换
	 * x这个结点的值为tmp 如果一直都比子结点小(第二种情况)，则一直向下移动，
	 * 不管子结点之间的大小关系，只关心子结点和父结点哪个大，就把哪个放到父结点的位置
	 */
	public void change(int[] nums, int start) {
		int next = 2 * start + 1;
		
		//tmp作为当前需要调整的结点的val
		int tmp = nums[start];
		
		while(next < nums.length) {
			//右子结点更大
			if(next < nums.length - 1 && nums[next + 1] > nums[next]) {
				next++;
			}
			//子结点大于当前要判断的节点的值？
			if(nums[next] > tmp) {
				nums[start] = nums[next];
				start = next;
				next = 2 * start + 1;//再移动到start的子结点，因为此时这个结点的值
			}else {
				//否则就是移动tmp值结点完成，返回，将start位置赋为tmp
				break;
			}
		}
		nums[start] = tmp;
	}
```



## 1046. 最后一块石头的重量





```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        if(stones.length == 1){
            return stones[0];
        }
        //PriorityQueue默认为小顶堆 传入参数Comparator
       Queue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o1 > o2 ? -1 : 1;
			}
		});
        
        for(int n : stones){
            pq.add(n);
        }
        while(pq.size() >= 2){
            pq.add(pq.poll() - pq.poll());
        }
        return pq.peek();
    }
}
```



# 栈&队列



## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```java
/*
v1:每次将入栈的所有数在最小栈中也放到相应的位置上，出栈入栈，耗费大量计算时间，每一次push和pop都是O(N)
还是没理解。。。

v2:
最小栈存放  截止目前的min值，这样可以做到和栈s同步
相当于记录和栈同等高的位置的 min
*/
class MinStack {
    int min;
    Stack<Integer> s, mins;
    /** initialize your data structure here. */
    public MinStack() {
        s = new Stack<>();
        mins = new Stack<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int x) {
        s.push(x);
        min = x < min ? x : min;
        mins.push(min);
    }
    
    public void pop() {
        int x = s.pop();
        mins.pop();
        if(!mins.isEmpty()){
            min = mins.peek();
        }else{
            //如果mins栈空了，需要更新最小值min，否则还保存的是之前记录的最小值
            //也可以提前在mins栈中压入Integer.MAX_VALUE，或者手动赋值，如下
            min = Integer.MAX_VALUE;
        }
    }
    
    public int top() {
        return s.peek();
    }
    
    public int getMin() {
        return min;
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```



# 滑动窗口



## [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)



使用大顶堆，存储下标i，按索引大小来形成堆

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int l = 0, r = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>(){
            public int compare(Integer x, Integer y){
                return nums[y] - nums[x]; 
            }
        });
        int[] re = new int[nums.length - k + 1];
        for(int i = 0; i < k-1; i++){
            pq.add(i);
        }
        
        for(r = k - 1; r < nums.length; r++){
            pq.add(r);
            if(pq.peek() >= l){
                re[l] = nums[pq.peek()];
            }else{
                while(pq.peek() < l){
                    pq.poll();
                }
                re[l] = nums[pq.peek()];
            }

            l++;
        }
        return re;
    }
}
```



---



双向队列这方法6666

> **后一个数如果大于前面的数，那么就将队列中前面的数*全部弹出*，只保留后面的更大的数**

队列中也保持着数组中的先后顺序

总是让后面的  &&  更大的数   排在队列前端，也可以保证当前这个数能使用尽可能多的次数

- 只要后面的数没有现在队列尾的数大，就直接入队
- 如果当前数大于队列尾，就弹出前一个数，直到当前数小于队尾的数
- **可以保证的是：** **后一个数虽然小于前一个数，但在前一个数刚好不在窗口范围内时，队列中的后一个数可以作为当前窗口的最大值**





```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 1){
            return nums;
        }
        //更形象的表示窗口
        int l = 0, r = 0;
        LinkedList<Integer> ll = new LinkedList<>();
        
        int[] res = new int[nums.length - k + 1];
        
        //先形成少了一个数的窗口队列  后面不需要进行过多判断，直接就开始第一次窗口最大值选取
        for(; r < k-1; r++){
            while(!ll.isEmpty() && nums[ll.peekLast()] <= nums[r]){
                ll.pollLast();
            }
            ll.offerLast(r);
        }
        
        for(; r < nums.length; r++){
            while(!ll.isEmpty() && nums[ll.peekLast()] <= nums[r]){
                ll.pollLast();
            }
            ll.offerLast(r);
            // 如果是到了窗口外面(左边)，最多也就是l-1的位置，因为上一轮才使用过这个值。故只需要出队一次就行，
            // 队列后面的值都是位置在这个数后面的  且小于当前这个数
            if(ll.peekFirst() < l){
                ll.pollFirst();
            }
            //用左边界来标注结果数组的下标
            res[l] = nums[ll.peekFirst()];
            l++;
        }
        return res;
    }
}
```



# 分治法



## 53.最大子序和



我们定义一个操作 get(a, l, r) 表示查询 a序列 [l,r] 区间内的最大子段和，那么最终我们要求的答案就是 get(nums, 0, nums.size() - 1)。如何分治实现这个操作呢？对于一个区间 [l,r]，我们取 m = (l + r) / 2，对区间 [l,m] 和 [m+1,r] 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。这个时候我们考虑如何通过 [l,m] 区间的信息和 [m+1,r] 区间的信息合并成区间 [l,r] 的信息。最关键的两个问题是：

我们要维护区间的哪些信息呢？
我们如何合并这些信息呢？
对于一个区间 [l,r]，我们可以维护四个量：

- lSum 表示 [l,r] 内以 l 为左端点的最大子段和
- rSum 表示 [l,r] 内以 r为右端点的最大子段和
- mSum 表示 [l,r] 内的最大子段和
- iSum 表示 [l,r] 的区间和



以下简称[l,m] 为 [l,r] 的「左子区间」，[m+1,r] 为 [l,r] 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 [l,r] 的信息）？对于长度为 1 的区间 [i,i]  四个值相等。

对于长度大于 1 的区间：

首先最好维护的是 iSum，区间[l,r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的 iSum。
对于 [l,r] 的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」的 iSum 加上「右子区间」的 lSum，二者取大。
对于 [l,r] 的 rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取大。
当计算好上面的三个量之后，就很好计算 [l,r] 的 mSum 了。我们可以考虑[l,r] 的 mSum 对应的区间是否跨越 m——它可能不跨越 m，也就是说 [l,r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 m，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。





> 说白了就是二分递归  将子数组得到的信息  上传至母数组  并整合信息的过程



```java
class Solution {
    public int maxSubArray(int[] nums) {
        return getInfo(nums, 0, nums.length - 1).msum;
    }

    //要递归 返回Status类
    public Status getInfo(int[] nums, int l, int r){
        //递归终止条件
        if(l == r){
            return  new Status(nums[l], nums[l], nums[l], nums[l]);
        }
        int m = (l + r) >> 1;
        Status ls = getInfo(nums, l, m);
        Status rs = getInfo(nums, m + 1, r);

        return combineInfo(ls, rs);
    }

    //现在已经计算完成左右子区间的各个值了   合并的过程
    public Status combineInfo(Status ls, Status rs){
        int lsum = Math.max(ls.lsum, ls.isum + rs.lsum);
        int rsum = Math.max(rs.rsum, rs.isum + ls.rsum);
        int msum = Math.max(Math.max(ls.msum, rs.msum), ls.rsum + rs.lsum);
        int isum = ls.isum + rs.isum;

        return new Status(lsum, rsum, msum, isum);
    }



    public class Status{
        int lsum, rsum, msum, isum;
        public Status(int l, int r, int m, int i){
            lsum = l; rsum = r; msum = m; isum = i;
        }
    }
}
```

![image-20201129193733348](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201129193733348.png)



![image-20201129194342656](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20201129194342656.png)

> 这种方法懂的都懂  : (



> 题外话
>
> 
>
> 「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维<u>护了四个信息的结构体</u>，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？
>
> 对于这道题而言，确实是如此的。但是仔细观察「方法二」，它**不仅可以解决区间 [0, n - 1]，还可以用于解决任意的子区间 [l, r] 的问题**。如果我们把[0,n−1] 分治下去出现的**所有子区间的信息**都用堆式存储的方式记忆化下来，即建成一颗**真正的树**之后，我们就可以在 ***O(logn)*** 的时间内**求到任意区间内的答案**，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于**大规模查询**的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——**线段树**。
>











# 一些数据结构的小bug



## Collections.sort



![image-20210120174250742](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210120174250742.png)

![image-20210120174916226](../picture/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/image-20210120174916226.png)



**比较器Comparator要求：**



```java
1 sgn(compare(x, y)) == -sgn(compare(y, x))
2 ((compare(x, y)>0) && (compare(y, z)>0))
3 如果compare(x, y)==0 那么sgn(compare(x, z))==sgn(compare(y, z))
```

> Collections.sort()中传入比较器Comparator，需要明确指定三种情况的返回值，（其实Arrays.sort也是需要的，但LeetCode不报错），在idea中会帮助优化，两个都不会报错
>















































