# SQL





1） 什么是SQL ？

**结构化查询语言**(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。

2） SQL 的作用

是所有关系型数据库的统一查询规范，不同的关系型数据库都支持SQL
所有的关系型数据库都可以使用SQL
不同数据库之间的SQL 有一些区别  













| 分类          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| 数据定义语 言 | 简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列 等。 |
| 数据操作语 言 | 简称DML(Data Manipulation Language)，用来对数据库中**表的记录进行更新。** |
| 数据查询语 言 | 简称DQL(Data Query Language)，用来**查询**数据库中表的记录。 |
| 数据控制语 言 | 简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别， 及创建用户。(了解) |

重点：DML 与 DQL！  





1） SQL语句可以单行 或者 多行书写，以**分号 结尾** ; （Sqlyog中可以不用写分号）

2） 可以使用空格和缩进来增加语句的可读性。

3） MySql中使用SQL**不区分大小写**，一般关键字大写，**数据库名 表名列名 小写。**

4） 注释方式  

| 注释语法 | 说明                |
| -------- | ------------------- |
| -- 空格  | 单行注释            |
| /* */    | 多行注释            |
| #        | MySql特有的单行注释 |









## DDL操作 数据库  





**创建数据库**  

| 命令                                            | 说明                                                     |
| ----------------------------------------------- | -------------------------------------------------------- |
| create database 数据库名；                      | 创建指定名称的数据库。                                   |
| create database 数据库名 character set 字符集； | 创建指定名称的数据库，并且指定字符集（一般都 指定utf-8） |

默认是utf8mb4编码

```mysql
/*
方式1 直接指定数据库名进行创建
默认数据库字符集为：latin1
*/
CREATE DATABASE db1;
/*
方式2 指定数据库名称，指定数据库的字符集
一般都指定为 utf8,与Java中的编码保持一致
*/
CREATE DATABASE db1_1 CHARACTER SET utf8;
```



**查看/选择数据库  **

| 命令                            | 说明                       |
| ------------------------------- | -------------------------- |
| use 数据库                      | 切换数据库                 |
| select database();              | 查看当前正在使用的数据库   |
| show databases;                 | 查看Mysql中 都有哪些数据库 |
| show create database 数据库名； | 查看一个数据库的定义信息   |





**修改数据库  **

| 命令                                           | 说明                   |
| ---------------------------------------------- | ---------------------- |
| alter database 数据库名 character set 字符集； | 数据库的字符集修改操作 |



```sql
-- 将数据库db1 的字符集 修改为 utf8
ALTER DATABASE db1 CHARACTER SET utf8;
-- 查看当前数据库的基本信息，发现编码已更改
SHOW CREATE DATABASE db1;
```



**删除数据库  **

| 命令                   | 说明                          |
| ---------------------- | ----------------------------- |
| drop database 数据库名 | 从MySql中永久的删除某个数据库 |

```mysql
-- 删除某个数据库
DROP DATABASE db1_1;
```







## DDL 操作 数据表  





常用的数据类型：  

| 类型    | 描述                                                |
| ------- | --------------------------------------------------- |
| int     | 整型                                                |
| double  | 浮点型                                              |
| varchar | 字符串型                                            |
| date    | 日期类型，给是为 yyyy-MM-dd ,只有年月日，没有时分秒 |



![image-20210331160501218](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331160501218.png)



注意：MySQL中的 char类型与 varchar类型，都对应了 Java中的字符串类型，区别在于：

char类型是**固定长度**的： 根据定义的字符串长度**分配足够的空间。**
varchar类型是**可变长度**的： **只使用字符串长度所需的空间**

比如：保存字符串 "abc"  

```
x char(10) 占用10个字节
y varchar(10) 占用3个字节
```



适用场景：

- char类型适合存储 固定长度的字符串，比如 密码 ，性别一类
- varchar类型适合存储 在一定范围内，有长度变化的字符串  



**varchar中的参数指的是数据的长度，而不是字节数，虽然汉字在utf8中是3个字节，但varchar(20)还是很可以存放20个汉字**

---

**创建表  **

```mysql
CREATE TABLE 表名(
    字段名称1 字段类型（长度），
    字段名称2 字段类型 -> 注意 最后一列不要加逗号
)；
```



```mysql
-- 创建表
CREATE TABLE category(
    cid INT,
    cname VARCHAR(20)
);

-- 创建测试表
CREATE TABLE test1(
    tid INT,
    tdate DATE
);

-- 创建一个表结构与 test1 相同的 test2表
CREATE TABLE test2 LIKE test1;
-- 查看表结构
DESC test2;
```







**查看表  **

| 命令         | 说明                       |
| ------------ | -------------------------- |
| show tables; | 查看当前数据库中的所有表名 |
| desc 表名；  | 查看数据表的结构           |



```mysql
-- 查看当前数据库中的所有表名
SHOW TABLES;
-- 显示当前数据表的结构
DESC category;
-- 查看创建表的SQL语句
SHOW CREATE TABLE category;


```





**删除表  **



| 命令                        | 说明                                               |
| --------------------------- | -------------------------------------------------- |
| drop table 表名；           | 删除表（从数据库中永久删除某一张表）               |
| drop table if exists 表名； | 判断表是否存在， 存在的话就删除,不存在就不执行删除 |



**修改表  **



```mysql
rename table 旧表名 to 新表名

alter table 表名 character set 字符集

alert table 表名 add 字段名称 字段类型
ALTER TABLE category ADD cdesc VARCHAR(20);

lter table 表名 modify 字段名称 字段类型
ALTER TABLE category MODIFY cdesc VARCHAR(50);

alter table 表名 change 旧列名 新列名 类型(长度);

alter table 表名 drop 列名;
```





## DML 操作表中数据  



SQL中的DML 用于对表中的数据进行增删改操作  



**插入数据  **



```
insert into 表名 （字段名1，字段名2...） values(字段值1，字段值2...);
```



按顺序插入全部字段，可以不写字段名  



1) 值与字段必须要**对应**，**个数相同&数据类型相同**

2）值的数据大小，必须在字段指定的长度范围内  

3）*varchar char date类型的值**必须使用单引号**，或者**双引号** 包裹。*

4）如果要插入空值，**可以忽略不写，或者插入null**

5)  如果插入**指定字段**的值，**必须要上写列名**  





----

**更改数据  **



```mysql
update 表名 set 列名 = 值

update 表名 set 列名 = 值 [where 条件表达式：字段名 = 值 ]

-- 一次修改多个属性的值
UPDATE student SET age = 20,address = '北京' WHERE sid = 2;
```







---



**删除数据 **



```
delete from 表名

delete from 表名 [where 字段名 = 值]
```



3) 如果要删除表中的所有数据,有两种做法

1. delete from 表名; 不推荐. **有多少条记录 就执行多少次删除操作**. 效率低
2. **truncate table** 表名: 推荐. 先删除整张表, 然后**再重新创建一张一模一样的表**. **效率高**  



## DQL 查询表中数据  





```
select 列名 from 表名
SELECT eid,ename FROM emp;
```



别名查询，使用关键字 as  

```mysql
# 使用 AS关键字,为列起别名
SELECT
    eid AS '编号',
    ename AS '姓名' ,
    sex AS '性别',
    salary AS '薪资',
    hire_date '入职时间', -- AS 可以省略
    dept_name '部门名称'
FROM emp;
```





使用去重关键字 `distinct`  

```mysql
-- 使用distinct 关键字,去掉重复部门信息
SELECT DISTINCT dept_name FROM emp;
```

对当前这条查询到的字段去重







运算查询 (查询结果参与运算)  





---



**条件查询**  



如果查询语句中**没有设置条件,就会查询所有的行信息**,在实际应用中,一定要指定查询条件,对记录进行过滤  



```
select 列名 from 表名 where 条件表达式

* 先取出表中的每条数据,满足条件的数据就返回,不满足的就过滤掉
```



| 运算符            | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| > < <= >= = <> != | 大于、小于、大于(小于)等于、不等于                           |
| BETWEEN ...AND... | 显示在某一区间的值 例如: 2000-10000之间： Between 2000 and 10000 |
| IN(集合)          | 集合表示多个值,使用逗号分隔,例如: name in (悟空，八戒) in中的每个数据都会作为一次条件,只要满足条件就会显示 |
| LIKE '%张%'       | 模糊查询                                                     |
| IS (Not)  NULL    | 查询某一列为NULL的值, 注: 不能写 = NULL                      |



| 运算符  | 说明             |
| ------- | ---------------- |
| And &&  | 多个条件同时成立 |
| Or \|\| | 多个条件任一成立 |
| Not     | 不成立，取反。   |









模糊查询 通配符  

| 通配符 | 说明                        |
| ------ | --------------------------- |
| %      | 表示匹配**任意多个**字符串, |
| _      | 表示匹配 **一个字符**       |







# 操作单表  



## 排序  







- **过 ORDER BY 子句,可以将查询出的结果进行排序(排序只是显示效果,不会影响真实数据)  **



```
SELECT 字段名 FROM 表名 [WHERE 字段 = 值] ORDER BY 字段名 [ASC / DESC]
```

| ASC 表示升序排序(默认) |
| ---------------------- |
| DESC 表示降序排序      |



### 排序方式  



1) 单列排序

只按照**某一个字段**进行排序, 就是单列排序  



使用 salary 字段,对emp 表数据进行排序 (升序/降序)  

```mysql
-- 默认升序排序 ASC
SELECT * FROM emp ORDER BY salary;

-- 降序排序
SELECT * FROM emp ORDER BY salary DESC;
```





2) 组合排序

同时对**多个字段**进行排序, 如果**第一个字段相同 就按照第二个字段**进行排序,以此类推  



在薪水排序的基础上,再使用id进行排序, 如果薪水相同就以id 做降序排序  

```mysql
-- 组合排序
SELECT * FROM emp ORDER BY salary DESC, eid DESC;
```





## 聚合函数  



之前我们做的查询都是横向查询，它们都是**根据条件一行一行的进行判断**，而使用聚合函数查询是纵向查询，它是对**某一列的值进行计算**，然后返回一个**单一的值**(另外聚合函数会***忽略null空值***。)；  



```
SELECT 聚合函数(字段名) FROM 表名;
```



| 聚合函数    | 作用                             |
| ----------- | -------------------------------- |
| count(字段) | 统计指定列**不为NULL的记录行数** |
| sum(字段)   | 计算指定列的数值和               |
| max(字段)   | 计算指定列的最大值               |
| min(字段)   | 计算指定列的最小值               |
| avg(字段)   | 计算指定列的平均值               |



```mysql
#1 查询员工的总数
-- 统计表中的记录条数 使用 count()
SELECT COUNT(eid) FROM emp; -- 使用某一个字段
SELECT COUNT(*) FROM emp; -- 使用 *
SELECT COUNT(1) FROM emp; -- 使用 1,与 * 效果一样


-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值
-- 所以使用时注意不要使用带有null的列进行统计
SELECT COUNT(dept_name) FROM emp;
```

如果count中的字段为空，那么不会统计数量



```mysql
#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值

-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值
SELECT
SUM(salary) AS '总薪水',
MAX(salary) AS '最高薪水',
MIN(salary) AS '最低薪水',
AVG(salary) AS '平均薪水'
FROM emp;
```



```mysql
#3 查询薪水大于4000员工的个数
SELECT COUNT(*) FROM emp WHERE salary > 4000;
```



```mysql
#5 查询部门为'市场部'所有员工的平均薪水
SELECT
AVG(salary) AS '市场部平均薪资'
FROM emp
WHERE dept_name = '市场部';
```











## 分组  



**分组查询指的是使用 GROUP BY 语句,对查询的信息进行分组,相同数据作为一组  **



```
SELECT 分组字段/聚合函数 FROM 表名 GROUP BY 分组字段 [HAVING 条件];
```



通过性别字段 进行分组  

```mysql
-- 按照性别进行分组操作
SELECT * FROM emp GROUP BY sex; -- 注意 这样写没有意义
```



GROUP BY 分组过程  

![image-20210331184838208](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331184838208.png)



分组时可以查询**要分组的字段**, 或者使用聚合函数进行统计操作

**\* 查询其他字段没有意义**  

将要分组的字段和要求的聚合函数值一起返回。 

```mysql
# 通过性别字段 进行分组,求各组的平均薪资
SELECT sex, AVG(salary) FROM emp GROUP BY sex;
```

![image-20210331184949357](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331184949357.png)



**将  各行数据在   相同字段  有相同的值的分为一组。**

**对各组的某些数据进行聚合，返回统计结果**

```mysql
#1. 查询有几个部门
SELECT dept_name AS '部门名称' FROM emp GROUP BY dept_name;
SELECT DISTINCT dept_name AS '部门名称' FROM emp ;



#2.查询每个部门的平均薪资
SELECT
dept_name AS '部门名称',
AVG(salary) AS '平均薪资'
FROM emp GROUP BY dept_name;



#3.查询每个部门的平均薪资, 部门名称不能为null
SELECT
dept_name AS '部门名称',
AVG(salary) AS '平均薪资'
FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name;
```





- 查询平均薪资大于6000的部门.  

分析:

1) 需要在分组后,***对数据进行过滤***,使用 关键字 **having**

2) 分组操作中的having子语句，是用于在**分组后对数据进行过滤的**，作用**类似于where条件**。  



```mysql
# 查询平均薪资大于6000的部门

-- 需要在分组后再次进行过滤,使用 having
SELECT
dept_name ,
AVG(salary)
FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name HAVING AVG(salary) >
6000 ;
```



where 与 having的区别  

| 过滤方式 | 特点                                                         |
| -------- | ------------------------------------------------------------ |
| where    | where 进行**分组前的过滤** where **后面不能写 聚合函数**,  只能进行单纯的判断或者模糊查询 |
| having   | having 是分组后的过滤 ***having 后面可以写 聚合函数***       |







## limit关键字  



limit 关键字的作用

limit是限制的意思,用于 **限制返回的查询结果的行数** (可以通过limit**指定查询多少行数据**)

limit 语法是 MySql的方言,***用来完成分页***  

```
SELECT 字段1,字段2... FROM 表名 LIMIT offset , length;
```



| limit offset , length; 关键字可以接受一个 或者两个 为0 或者正整数的参数 |
| ------------------------------------------------------------ |
| offset **起始行数**, **从0开始记数**, 如果省略 则默认为 0.   |
| length 返回的行数                                            |



```mysql
# 查询emp表中的前 5条数据
-- 参数1 起始值,默认是0 , 参数2 要查询的条数
SELECT * FROM emp LIMIT 5;
SELECT * FROM emp LIMIT 0 , 5;

# 查询emp表中 从第4条开始,查询6条
-- 起始值默认是从0开始的.
SELECT * FROM emp LIMIT 3 , 6;
```



分页操作

```mysql
-- 分页操作 每页显示3条数据
SELECT * FROM emp LIMIT 0,3; -- 第1页
SELECT * FROM emp LIMIT 3,3; -- 第2页 2-1=1 1*3=3
SELECT * FROM emp LIMIT 6,3; -- 第三页

-- 分页公式 起始索引 = (当前页 - 1) * 每页条数
-- offset索引从0开始，而数据库条数是从1开始
-- limit是MySql中的方言
```







# SQL约束  



1) 约束的作用:

对表中的数据进行**进一步的限制**，从而**保证数据的正确性、有效性、完整性.**

违反约束的***不正确数据,将无法插入到表中***



2) 常见的约束  

| 约束名 | 约束关键字      |
| ------ | --------------- |
| 主键   | primary key     |
| 唯一   | unique          |
| 非空   | **not null**    |
| 外键   | **foreign key** |



## 主键约束  



| 特点 | 不可重复 唯一 非空                                       |
| ---- | -------------------------------------------------------- |
| 作用 | 用来**(唯一)表示**数据库中的    **每一条(每行数据)记录** |



```mysql
字段名 字段类型 primary key


# 方式1 创建一个带主键的表
CREATE TABLE emp2(
    -- 设置主键 唯一 非空
    eid INT PRIMARY KEY,
    ename VARCHAR(20),
    sex CHAR(1)
);
-- 删除表
DROP TABLE emp2;


-- 方式2 创建一个带主键的表
CREATE TABLE emp2(
    eid INT ,
    ename VARCHAR(20),
    sex CHAR(1),
    -- 指定主键为 eid字段
    PRIMARY KEY(eid)
);


-- 方式3 创建一个带主键的表
CREATE TABLE emp2(
    eid INT ,
    ename VARCHAR(20),
    sex CHAR(1)
) 
-- 创建的时候不指定主键,然后通过 DDL语句进行设置
ALTER TABLE emp2 ADD PRIMARY KEY(eid);
```





![image-20210331194709371](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331194709371.png)



3) 哪些字段可以作为主键 ?

通常针对业务去设计主键,**每张表都设计一个主键id**
**主键是给数据库和程序使用的,跟最终的客户无关,**所以主键**没有意义**没有关系,只要能够保证不重复就好,比如 **身份证就可以作为主键.**  







- 删除 表中的主键约束  

```mysql
-- 使用DDL语句 删除表中的主键
ALTER TABLE emp2 DROP PRIMARY KEY;
DESC emp2;
```





- 主键的自增

  注: 主键如果让我们自己添加很有可能重复,我们通常希望在**每次插入新记录时**,数据库***自动生成主键字段的值.***  



```mysql
AUTO_INCREMENT 表示自动增长(字段类型必须是整数类型)

-- 创建主键自增的表
CREATE TABLE emp2(
    -- 关键字 AUTO_INCREMENT,主键类型必须是整数类型
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20),
    sex CHAR(1)
);
```

**系统会保存上次记录到的值，而不是去找表中最大的自增id去+1**

创建主键自增的表,自定义自增其实值

```mysql
-- 创建主键自增的表,自定义自增其实值
CREATE TABLE emp2(
eid INT PRIMARY KEY AUTO_INCREMENT,
ename VARCHAR(20),
sex CHAR(1)
)AUTO_INCREMENT=100;
```









### DELETE和TRUNCATE对自增长的影响  



| 清空表数据的方式 | 特点                                                         |
| ---------------- | ------------------------------------------------------------ |
| DELETE           | 只是删除表中所有数据,对自增没有影响，**原表中记录自增的数据并没有重置** |
| TRUNCATE         | truncate 是将整个表删除掉,然后**创建一个新的表** 自增的主键,重新从 1开始 |









## 非空约束  



非空约束的特点: 某一列不予许为空  



```mysql
字段名 字段类型 not null  

# 非空约束
CREATE TABLE emp2(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    -- 添加非空约束, ename字段不能为空
    ename VARCHAR(20) NOT NULL,
    sex CHAR(1)
);
-- Column 'ename' cannot be null
```



## 唯一约束  





唯一约束的特点: 表中的某一列的值不能重复( ***对null不做唯一的判断*** )  

```mysql
#创建emp3表 为ename 字段添加唯一约束
CREATE TABLE emp3(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    ename VARCHAR(20) UNIQUE,
    sex CHAR(1)
);
-- Duplicate entry 'aa' for key 'ename'
```



| 主键约束与唯一约束的区别:                                  |
| ---------------------------------------------------------- |
| 1. 主键约束 唯一且不能够为空                               |
| 2. 唯一约束,唯一 **但是可以为空**                          |
| 3. 一个表中只能有**一个主键** , 但是可以有**多个唯一约束** |

**唯一约束可以为空**

![image-20210331200423759](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331200423759.png)





## 外键约束  



**FOREIGN KEY** 表示**外键约束**，将在多表中涉及







## 默认值  



默认值约束 用来指定某列的默认值  



```mysql
-- 创建带有默认值的表
CREATE TABLE emp4(
    eid INT PRIMARY KEY AUTO_INCREMENT,
    -- 为ename 字段添加默认值
    ename VARCHAR(20),
    sex CHAR(1) DEFAULT '女'
);

INSERT INTO emp4(ename,sex) VALUES("aaa",DEFAULT);
INSERT INTO emp4(sex) VALUES(DEFAULT);
INSERT INTO emp4(ename) VALUES("aaa"); -- 或者直接不指定
```













# 数据库事务  





## 什么是事务  



**事务是一个整体**,由**一条或者多条SQL 语句**组成,这些SQL语句要么  ***都***  执行成功,要么都执行失败, 只要有一条SQL出现异常,整个操作就会回滚,整个业务执行失败  

```
比如: 银行的转账业务,张三给李四转账500元 , 至少要操作两次数据库, 张三 -500, 李四 + 500,这中
间任何一步出现问题,整个操作就必须全部回滚, 这样才能保证用户和银行都没有损失
```





- 回滚

  即在事务运行的过程中发生了**某种故障**，事务**不能继续执行**，系统将事务中**对数据库的所有已完成的操作全部撤销**，**滚回到事务开始时的状态**。（在提交之前执行）  







## 模拟转账操作  



```mysql
-- 创建账户表
CREATE TABLE account(
    -- 主键
    id INT PRIMARY KEY AUTO_INCREMENT,
    -- 姓名
    NAME VARCHAR(10),
    -- 余额
    money DOUBLE
);


-- 添加两个用户
INSERT INTO account (NAME, money) VALUES ('tom', 1000), ('jack', 1000);
```



模拟tom 给 jack 转 500 元钱，一个转账的业务操作最少要执行下面的 2 条语句  

```mysql
-- tom账户 -500元
UPDATE account SET money = money - 500 WHERE NAME = 'tom';
-- jack账户 + 500元
UPDATE account SET money = money + 500 WHERE NAME = 'jack';
```



> 假设当tom 账号上 -500 元,服务器崩溃了。jack 的账号并没有+500 元，数据就出现问题了。
>
> 我们要**保证整个事务执行的完整性,要么都成功, 要么都失败**. 这个时候我们就要学习如何操作事务.  





## MySql事务操作  



MYSQL 中可以有两种方式进行事务的操作：

- 手动提交事务
- 自动提交事务  



### 手动提交事务  



**语法格式  **

| 功能     | 语句                           |
| -------- | ------------------------------ |
| 开启事务 | start transaction; 或者 BEGIN; |
| 提交事务 | commit;                        |
| 回滚事务 | rollback;                      |



- START TRANSACTION
  - 这个语句显式地标记一个**事务的起始点。**
- COMMIT
  - 表示**提交事务**，即提交事务的所有操作，具体地说，就是将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。
- ROLLBACK
  - 表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操**作全部撤销**，**回滚到事务开始时的状态**  



---

**手动提交事务流程  **

- 执行成功的情况： 开启事务 -> 执行多条 SQL 语句 -> 成功提交事务
- 执行失败的情况： 开启事务 -> 执行多条 SQL 语句 -> 事务的回滚  



不去提交事务 **直接关闭窗口**,**发生回滚操作**,数据没有改变  













----

- **自动提交事务  **



MySQL 默认**每一条 DML(增删改)语句都是一个单独的事务**，***每条语句都会自动开启一个事务***，语句执行完毕 **自动提交事务**，MySQL 默认开始自动提交事务

MySQL默认是自动提交事务  



**取消自动提交  **

MySQL默认是自动提交事务,设置为手动提交.  

![image-20210331204916466](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331204916466.png)

| on ：自动提交  |
| -------------- |
| off : 手动提交 |

```
SET @@autocommit=off;
```





## 事务的四大特性 ACID  



| 特性   | 含义                                                         |
| ------ | :----------------------------------------------------------- |
| 原子性 | 每个事务都是一个整体，**不可再拆分**，事务中所有的 SQL 语句要么都执行成功， 要么都 失败。 |
| 一致性 | 事务在执行前数据库的状态与执行后数据库的**状态保持一致**。如：转账前2个人的 总金额 是 2000，转账后 2 个人总金额也是 2000. |
| 隔离性 | **事务与事务之间不应该相互影响，执行时保持隔离的状态.**         事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。 |
| 持久性 | 一旦事务执行成功，对数据库的**修改是持久的**。就算关机，数据也是要保存下来的 |







## Mysql 事务隔离级别  





### 数据并发访问  

一个数据库可能拥有**多个访问客户端**,这些客户端都可以**并发方式访问数据库**. 数据库的相同数据可能被**多个事务同时访问**,如果**不采取隔离措施,就会导致各种问题, 破坏数据的完整性**  





### 并发访问会产生的问题  



事务在操作时的理想状态： **所有的事务之间保持隔离，互不影响**。因为并发操作，多个用户同时访问同一个 数据。可能引发并发访问的问题  



| 并发访问的问题 | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 脏读           | 一个事务读取到了另一个事务中**尚未提交的数据**               |
| 不可重复 读    | 一个事务中***两次读取的数据内容不一致***  , **要求的是在一个事务中多次读取时数据是一 致的**. 这是进行 **update 操作**时引发的问题 |
| 幻读           | 一个事务中,某一次的 select 操作**得到的结果所表征的数据状态**, **无法支撑后续的业务 操作（在这期间数据库该条数据的状态进行了改变，并发访问导致的问题）**. 查询得到的数据状态不准确,导致幻读 |





### 四种隔离级别  

通过设置隔离级别,可以防止上面的三种并发问题.
MySQL数据库有四种隔离级别 上面的级别最低，下面的级别最高。

✔ 会出现问题
✘ 不会出现问题  



| 级 别 | 名字      | 隔离级别         | 脏 读 | 不可重复 读 | 幻 读 | 数据库的默认隔离级 别 |
| ----- | --------- | ---------------- | ----- | ----------- | ----- | --------------------- |
| 1     | 读未提 交 | read uncommitted | ✔     | ✔           | ✔     |                       |
| 2     | 读已提 交 | read committed   | ✘     | ✔           | ✔     | Oracle和SQLServer     |
| 3     | 可重复 读 | repeatable read  | ✘     | ✘           | ✔     | MySql                 |
| 4     | 串行化    | serializable     | ✘     | ✘           | ✘     |                       |





### 隔离级别相关命令  



查看隔离级别  

```
select @@tx_isolation;
SELECT @@transaction_isolation;  新版
```

mysql默认：可重复读，可以   防止脏读和不可重复读

![image-20210331210756380](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331210756380.png)



设置事务隔离级别，需要退出 MySQL 再重新登录才能看到隔离级别的变化  

```
set global transaction isolation level 级别名称;
read uncommitted 读未提交
read committed 读已提交
repeatable read 可重复读
serializable 串行化

set global transaction isolation level read uncommitted;
```





## 隔离性问题演示  



###  脏读演示  

脏读: 一个事务读取到了另一个事务中尚未提交的数据  



![image-20210331211719186](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331211719186.png)



A进行回滚：

![image-20210331211901701](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331211901701.png)

B再次查询，发现数据又变回去了。——**脏读！！！！**



### 解决脏读问题  



脏读非常危险的，比如张三向李四购买商品，张三开启事务，向李四账号转入 500 块，然后打电话给李四说钱 已经转了。李四一查询钱到账了，发货给张三。张三收到货后回滚事务，李四的再查看钱没了  。。。。。



将**全局的隔离级别进行提升为: read committed**  



```mysql
set global transaction isolation level read committed;
SELECT @@transaction_isolation;
```

![image-20210331212152870](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331212152870.png)



演示略~~





### 不可重复读演示  



不可重复读: 同一个事务中,进行查询操作,但是每次读取的数据内容是不一样的  



这时候就不会出现脏读

![image-20210331212544628](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331212544628.png)





此时对A进行提交？B读到的数据还是发生了改变！

![image-20210331212621969](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331212621969.png)



两次查询输出的结果不同，到底哪次是对的？  



**不知道以哪次为准**。 很多人认为这种情况就对了，无须困惑， **当然是后面的为准？？×**

我们可以考虑这样一种情况:  

> 比如银行程序需要将**查询结果**分别输出到电脑屏幕和发短信给客户，结果在一个事务中针对不同的输出目的地进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作 人员就不知道以哪个为准了  







### 解决不可重复读问题  

将全局的隔离级别进行提升为： repeatable read  

```
-- 设置事务隔离级别为 repeatable read
set global transaction isolation level repeatable read;
```



演示略~~









### 幻读演示  



幻读: select 某记录是否存在，不存在，**准备插入此记录，但执行 insert 时发现此记录已存在**，
**无法插入**，此时就发生了幻读。   

**虽然解决了不可重复读的问题，在当前事务中：本地查询到没有插入这条数据，这不会改变。但其他的事务可能已经插入了这条数据，但本事务并不知道——因为设置了可重复读的隔离级别。在插入时会发现无法插入！**





![image-20210331213756969](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331213756969.png)

明明刚才读的时候没有？为什么会重复呢？？？



### 解决幻读问题  



将事务隔离级别设置到最高 **SERIALIZABLE** ，以挡住幻读的发生  



如果一个事务，使用了SERIALIZABLE——**可串行化隔离级别**时，**在这个事务没有被提交之前 , 其他的线程，只能等到当前操作完成之后**，**才能进行操作**，这样会**非常耗时**，而且，影响数据库的性能，数据库不会使用这种隔离级别  

```
set global transaction isolation level SERIALIZABLE;
```



——>在一个事务未提交时，另一个事务无法执行操作，会被停滞，**直到上一个事务提交后，才能进行操作**







串行化就相当于给操作的记录上一个**共享锁（读写锁）**，即当读某条记录时就占用这条记录的读锁，此时其它事务一样可以申请到这条记录的读锁来读取，**但是不能写**（**读锁被占的话，写锁就不能被占**；**读锁可以被多个事务同时占有**）



串行化相当于加 **共享锁**，别的事务只是不能 update insert delete， 但还是可以读的





![image-20210331214738021](../picture/MySQL%E5%9F%BA%E7%A1%80/image-20210331214738021.png)











































































































































































































































































# TIP



## **CHAR(M), VARCHAR(M)不同之处**



CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检 索到CHAR值时，***尾部的空格被删除掉***。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，**CHAR字段上的索引效率级高**，比如定义 char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。

VARCHAR(M)定义的列的长度为**可变长字符串**，M取值可以为0~65535之间，(VARCHAR的最大有效长度由**最大行大小**和**使用 的字符集**确定。**整体最大长度是65,532字节**）。VARCHAR值保存时只保存需要的**字符数**，另加一个字节来**记录长度**(如果列声明的长度超过255，则 **使用两个字节**)。VARCHAR值保存时**不进行填充**。当值保存和检索时**尾部的空格仍保留**，符合标准SQL。varchar存储变长数据，但存储效率没有 CHAR高。如果一个字段可能的值是**不固定长度的**，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的**实际长度是它的值的实际长度+1**。为什么"+1"呢？这一个字节**用于保存实际使用了多大的长度**。 从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。



CHAR和VARCHAR最大的不同就是一个是固定长度，一个是可变长度。由于是可变长度，因此实际存储的时候是实际字符串再加上一个记录 **字符串长度的字节**(如果超过255则需要两个字节)。如果分配给CHAR或VARCHAR列的值超过列的最大长度，则对值进行裁剪以使其适合。如果被裁掉 的字符不是空格，则会产生一条警告。如果裁剪非空格字符，则**会造成错误**(而不是警告)并**通过使用严格SQL模式禁用值的插入。**





## mysql 事务中如果有sql语句出错，会导致自动回滚吗





 一、如果事务中，有某条sql语句执行时报错了，我们没有手动的commit，那整个事务会自动回滚吗？

答案：会。

![img](https://img2018.cnblogs.com/blog/140030/201812/140030-20181227132544138-1829140247.png)

当我们**直接把窗口关掉**，新开窗口再去查询表name时，表中没有第一次插入的记录，说明整个事务被回滚了。

 

二、如果事务中，有某条sql语句执行时报错了，我们手动的commit，那整个事务还会回滚吗？

答案：不会。

事务中如果**有sql执行错误**，但是我们**commit了**，mysql**仍然会执行成功的语句**，**并不会把整个事务自动回滚。**





三、如果事务中，有某条sql语句执行时报错了，我们重新又开启一个事务，那之前事务还会回滚吗？

答案：不会。

![img](../picture/MySQL%E5%9F%BA%E7%A1%80/140030-20181227134149465-1132416156.png)

我们在该会话中，重新用 begin; 开启了一个新事务，新开的事务会将该会话中未提交的事务提交(相当于commit)，所以上一个事务被提交了，导致语句一记录写入表中。













































































































































































































