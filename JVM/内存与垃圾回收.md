JVM学习路线：

![image-20210321154529797](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321154529797.png)



# 内存与垃圾回收







# JVM和Java体系结构







![image-20210319184628767](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319184628767.png)

始终是在软件层面进行操作。需要去了解底层

**内功修炼！**



高级语言->汇编语言->机器指令->CPU



![image-20210319190029581](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319190029581.png)

垃圾回收机制，大大提高了开发效率，但也不是万能的，懂得JVM内部的**内存结构，工作机制**，是设计高扩展性应用和诊断运行时问题的基础。



## Java及JVM简介



跨平台的语言：

![image-20210319192535044](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319192535044.png)





JVM：跨语言的平台。只要他们的编译器编译出的字节码文件符合规范，那么就可以被java虚拟机解释运行。**它只关心字节码文件**。

![image-20210319192731453](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319192731453.png)



字节码->**jvm字节码**

多语言混合编程，他们最终都运行在一个虚拟机之上。





## 虚拟机与java虚拟机



系统虚拟机和程序虚拟机。

系统虚拟机完全是对物理计算机的仿真，提供可运行完整操作系统的软件平台。

程序虚拟机，如java虚拟机，专门为执行单个计算机程序而设计。

Java虚拟机：执行**java字节码**的虚拟计算机，**跨平台+优秀的垃圾回收器+可靠的即时编译器**



作用：java虚拟机就是**二进制字节码的运行环境**。

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能





**JVM的位置**：





![image-20210319183620188](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319183620188.png)

JVM是运行在操作系统之上的，**与硬件没有直接的交互**



javac：前端编译器。

![image-20210319183811985](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319183811985.png)







## JVM的整体结构



HotSpot VM是目前市面上高性能虚拟机的代表作之一

采用**解释器与即时编译器**并存的架构

- 字节码文件输入->类加载器->生成class对象

- 共享方法区和堆

- 每个线程独享程序计数器，本地方法栈和虚拟机栈
- 执行引擎：高级语言->机器语言

![image-20210319200058541](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200058541.png)



**更详细的图：**

![image-20210319200616290](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200616290.png)



![image-20210319200630907](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200630907.png)







## Java代码执行流程



![image-20210319201439951](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319201439951.png)





## JVM架构模型



基于栈的指令集架构，基于寄存器的指令集架构



==hotspot是基于栈的指令集架构==

- 设计和实现更简单
- 避开了寄存器的分配难题，使用零地址指令方式分配
- 执行过程依赖于操作栈，指令集更小，编译器更容易实现
- 不需要硬件支持，可移植性更好，更好实现跨平台



基于寄存器架构：

- x86的二进制指令集
- **完全依赖硬件**，性能优秀，可移植性较差
- 花费更少的指令去完成一项操作
- 一地址指令、二地址指令、三地址指令







- 一地址指令：地址+操作数的个数

- 零地址指令：没有地址，只有操作数 



![image-20210319202114141](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319202114141.png)



```
int i = 2 + 3;
```

```
javap -v StackStruTest.class 反编译
```

![image-20210319203345499](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319203345499.png)



```
int i = 2;
int j = 3;
int k = i + j;
```

![image-20210319203550140](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319203550140.png)



总结：

**由于跨平台性的设计，java的指令都是根据栈来设计的**



栈：

- 跨平台性
- 指令集小
- 指令多
- 执行性能比寄存器差一点





## JVM的生命周期



- **虚拟机的启动**

Java虚拟机的启动是通过**引导类加载器**bootstrap class loader创建一个初始类initial class来完成的，这个类是由虚拟机的具体事先指定的

自定义的类通过系统类加载器加载

Object被引导类加载器加载

需要先加载父类，发现没有，启动虚拟机

- **虚拟机的执行**

一个运行中的Java虚拟机有着一个清晰的任务：执行java程序

程序开始执行时他才运行，程序结束时他就停止

**执行一个所谓的java程序的时候，在执行的是一个叫做java虚拟机的进程**

![image-20210319205159316](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319205159316.png)



- **虚拟机的退出**

程序正常执行结束

执行过程中遇到一场或错误而异常终止

操作系统错误

**Runtime(运行时环境)**或System的exit方法，Runtime的halt方法，并且java安全管理器也云溪这次exit或halt操作

Java Native Interface也可以来加载或卸载java虚拟机





## JVM发展历程



- Sun Classic VM

  只提供了解释器，逐行解释字节码。。。效率较低。如果为了执行效率使用 JIT 编译器，就需要进行外挂，但是一旦使用JIT编译器，就会接管虚拟机的执行系统，解释器就不再工作。解释器和编译器也**不能配合工作**

  只使用JIT，**暂停时间**较长。二者应该**搭配使用**效率才高。

  hotspot内置了此虚拟机

- Exact VM

  准确是内存管理，可以知道内存中某个位置的数据具体是什么类型

  编译器与解释器混合工作模式

  热点探测



- HotSpot VM

oracle/Open  jdk的默认虚拟机。

**hotspot：热点代码探测技术**：

​	通过计数器找到最具编译价值代码，触发即时编译（缓存起来）或栈上替换

​	通过编译器与解释器**==协同工作==**，在最优化的**==程序响应时间与最佳执行性能==**中取得平衡



- JRockit

  专注于服务器端应用

  - 不太关注程序启动速度，因此内部不包含解析器实现，都靠即时编译器编译后执行

  是世界上**最快的JVM**

  优势：

  - 提供毫秒、微妙级的JVM响应时间
  - MissionControl服务套件，监控、管理和分析生产环境中的应用程序

- IBM 的 J9

  市场定位与HotSpot接近。有影响力的三大商用虚拟机之一，号称世界上最快的jvm....



- KVM和CDC/CLDC HotSpot

  移动领域

  一次编译，到处运行

- Azul VM

  与特定硬件平台绑定，软硬件配合的专有虚拟机。

- Liquid VM

  BEA公司，运行在自家的系统上。

  不需要操作系统的支持，自己本身实现了一个专用操作系统的必要功能：线程调度、文件系统、网络支持等。

- Apache Harmony 

  它的Java类库代码吸纳进了Android SDK

- Microsoft JVM

- Taobao JVM

  基于Openjdk HotSpot深度定制且开源的高性能服务器版Java虚拟机

  降低垃圾回收的频率

  在淘宝、天猫上线，替换了Oracle JVM

- Dalvik VM

  谷歌开发。应用于Android系统。不是Java虚拟机，没有遵循Java虚拟机规范。

  不能执行Java 的Class文件

- Graal VM

  跨语言全栈虚拟机，作为任何语言的运行平台使用：Java,Scala,C,C++,JS,Python.....

  支持不同语言中混用对方的接口和对象





# 类加载子系统



## 内存结构概述





![image-20210320094037787](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320094037787.png)



使用类加载子系统将class字节码文件加载到内存中，生成大的class对象，初始化静态属性...



- 加载阶段：引导/扩展/系统  类加载器
- 链接阶段：验证、准备、解析
- 初始化阶段

![image-20210320094311385](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320094311385.png)



如果自己手写一个java虚拟机，需要考虑类加载器和执行引擎。







## 类加载器与类的加载过程



![image-20210320095232496](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320095232496.png)

- 类加载器子系统负责从文件系统或者网络中加载Class文件，ckass文件在文件开头有特定的文件标识
- `ClassLoader`只负责**class文件的加载**，至于它是否可以运行，则**由Execution Engine执行引擎来决定**
- 加载的**类信息**存放于一块称为**==方法区==**的**内存空间**。除了类的信息外，方法区中还会存放**运行时常量池信息**，可能还包括**字符串字面量和数字常量**（这部分常量信息是Class文件中常量池部分的内存映射）







![image-20210320095640068](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320095640068.png)

- class file 存在于本地硬盘上，根据这个文件**实例化**出n个一模一样的实例。
- class file 加载到JVM中，被称为DNA元数据模板，放在方法区

- Car Class调用 `getClassLoader`获取类加载器
- 通过具体的类对象还可以 `getClass()`获取到是哪个Class创建的对象

- 在.class文件 ->JVM -> 最终成为**==元数据模板==**，此过程就要一  个运输工具：类装载器Class Loader，扮演一个快递员的角色



类的加载过程：

![image-20210320100106181](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320100106181.png)



### 类的加载过程

---

**加载：Loading**

- 通过一个类的全限定名获取定义此类的**二进制字节流**（网络、本地、jar/war压缩包、动态地里、jsp）
- *将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构***
- **在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种**数据的访问入口



---

**链接**

验证Verify：

- 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证部IE加载类的枕骨且行，不会危害虚拟机自身安全。"CAFEBABE"
- 文件格式验证、元数据验证、字节码验证、符号引用验证



准备Prepare：

- 为类变量分配内存并且设置该类变量的默认初始值：**==零值==**
- **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化**
- **这里不会为实例变量分配初始化**，**==类变量会分配在方法区==**中，而**==实例变量是会随着对象一起分配到Java堆中==**



![image-20210320101330889](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320101330889.png)



解析Resolve：

- 将常量池中的符号引用转换为常量引用

![image-20210320102524219](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320102524219.png)

- **符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在Class文件格式中，直接引用就是直接指向目标的指针、相对偏移量**
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等



---



> 类/静态变量属于类，就像实例变量一样，它们是在类内在任何方法之外声明的，但是使用static关键字声明。
>
> 它们可以在编译时访问，您可以在实例化之前/不实例化类时进行访问，整个类中只有一个静态字段的副本可用，即，静态字段的值在所有对象中都相同。您可以使用static关键字定义一个静态字段。
>
> 如果您在类中声明了静态变量，则尚未初始化它，就像使用实例变量一样，编译器将使用默认构造函数中的默认值对其进行初始化。
> ————————————————
> 版权声明：本文为CSDN博主「圭 圭」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/weixin_29163797/article/details/114134698



**初始化**

- 就是执行类构造器方法`<clinit>()`的过程

- javac编译器自动收集类中的所有**类变量（static）的赋值动作和静态代码块（static）**中的语句合并而来

  ```java
  private static int num = 1;
  static{
  	num = 2;
  }
  ```

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103016926.png" alt="image-20210320103016926" style="zoom:150%;" />

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103120733.png" alt="image-20210320103120733" style="zoom:150%;" />

  **一开始赋值为1，后来又赋值为2，会把显示初始化和静态代码快的初始化合并在一起**

- 构造器方法中指令按语句在**源文件中出现的顺序**执行 ↑

  ```java
  static{
  	num = 2;
  	number = 20;
  }
  private static int number = 10;//在linking阶段，prepare环境，将number赋值为0，在initialization阶段，重新覆盖，按照顺序  先20  后被覆盖为10
  ```

   <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103434246.png" alt="image-20210320103434246" style="zoom:150%;" />

  ![image-20210320103545588](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103545588.png)

  **报错：非法的前向引用↑。声明的对象在后面，可以赋值但不可以调用**

- `<clinit>()`不同于类的构造器（关联：构造器是虚拟机视角下的`<init>()`）

  ==**如果类中没有静态代码块或者静态变量，那么不存在`<clinit>()`类构造器方法**== 

- <`init`>是类构造器函数

  **任何类声明以后，内部至少存在一个类的构造器（系统默认提供 -> 默认父类Object构造器）**

- 若该类具有父类，JVM会在子类的clinit执行前，父类的clinit已经执行完毕

  **首先会加载father类，其次加载son类  B=2**

  ![image-20210320105010950](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105010950.png)

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105346224.png" alt="image-20210320105346224" style="zoom:150%;" />

- 虚拟机必须保证一个类的 `<clinit>()`方法在多线程下被**同步加锁**。**一个类只需要加载一次就可以，加载到内存中，以后都是使用的内存中的类本身。**

  如果是多线程，

  ![image-20210320105544125](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105544125.png)

  不让这个类加载完成。。。

  ![image-20210320105628138](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105628138.png)

  两个线程都需要初始化DeadThread类：

  ![image-20210320105824928](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105824928.png)

​	**只有一个类可以进到 `<clinit>()`方法来初始化这个类**，实现了同步加锁







## 类加载器的分类



- 引导类加载器 Bootstrap

   C和C++编写

- 自定义类加载器 User-Defined

   将所有继承自抽象类ClassLoader的类加载器都划分为自定义类加载器



![image-20210320110405264](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110405264.png)

不是继承关系，等级关系。**ExtClassLoader是AppClassLoader的父加载器**

```java
public static void main(String[] args) {
    //获取系统类加载器
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
    
    //获取其上层：扩展类加载器
    ClassLoader extClassLoader = systemClassLoader.getParent();
    System.out.println("extClassLoader = " + extClassLoader);
    //extClassLoader = sun.misc.Launcher$ExtClassLoader@1b6d3586
    
    //试图继续获取上层，获取不到引导类加载器
    ClassLoader parent = extClassLoader.getParent();
    System.out.println(parent);//null
    
    System.out.println("用户自定义类的类加载器：" + ClassLoaderTest.class.getClassLoader());
    //用户自定义类的类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2
    //和上面AppClassLoader是一个对象，使用系统类加载器进行加载
}
```

`String.class.getClassLoader`：null，获取不到类加载器。**证明了String类使用引导类加载器进行加载的。——>java的核心类库都是使用引导类加载器**

**Bootstrap Class Loader没法获取到，非常高端....只加载核心类库，c和c++编写，拿不到对象**

![image-20210320110437650](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110437650.png)



**ExtClassLoader是AppClassLoader的父加载器**：

```java
private ClassLoader(Void unused, ClassLoader parent) {
    this.parent = parent;
```

**在构造AppClassLoader时传入了ExtClassLoader对象，在ClassLoader类中将其设置为AppClassLoader的parent，==其实就是一个属性值，并不是继承关系==，二者都继承自URLClassLoader**

```java
Launcher.ExtClassLoader var1;
try {
    var1 = Launcher.ExtClassLoader.getExtClassLoader();
} catch (IOException var10) {
    throw new InternalError("Could not create extension class loader", var10);
}

try {
    this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
} catch (IOException var9) {
    throw new InternalError("Could not create application class loader", var9);
}

```







### 虚拟机自带的类加载器：



**启动类加载器（引导类加载器 Bootstrap ClassLoader）**

- 使用C/C++语言实现，嵌套在JVM内部
- 用来接下载Java核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar），用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader，没有父加载器
- 启动类加载器  **加载扩展类和应用程序类加载器**，并指定他们的父类加载器
- Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类





**扩展类加载器（Extention ClassLoader）**

- **==Java语言编写==**，sun.misc.Luncher.ExtClassLoader
- 派生于ClassLoader类
- 父加载器为启动类加载器
- java.ext.dirs，jre/lib/ext子目录下加载类库。**如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载**



**应用程序类加载器（系统类加载器，AppClassLoader）**

- **==Java语言编写==**，sun.misc.Luncher.AppClassLoader
- 派生于ClassLoader类
- 父加载器为扩展类加载器
- 复杂加载环境变量**==classpath==**或系统属性  java.class.path指定路径下的类库
- **该类加载器是程序中默认的类加载器**，一般来说，Java应用都是由它来完成加载
- 通过`getSystemClassLoader()`方法来获取



![image-20210320113959039](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320113959039.png)

  ![image-20210320114013328](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114013328.png)

其中String也是在rt.jar下

```
sout:Provider.class.getClassLoader()  //null 表明他的加载器是引导类加载器
```



![image-20210320114545334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114545334.png)

 ![image-20210320114357922](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114357922.png)

```
sout:CurveDB.class.getClassLoader() //ExtClassLoader
```







### 用户自定义类加载器



为什么要自定义类加载器：

- 隔离加载类，隔离中间件和应用的jar包

- 修改类加载的方式
- 扩展加载源，扩展数据库....字节码的来源
- 防止源码泄露，加密解密



实现步骤：

1. 通过集成抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，满足一些特殊的需求
2. 1.2之后，不建议覆盖loadClass()方法，写在findClass()中
3. 如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作
4. 可以直接继承URLClassLoader类，避免编写**findClass()**和**获取字节码流**的方式，







## 关于ClassLoader

是一个**抽象类**，其后所有的类加载器都继承自ClassLoader，**不包括启动类加载器**

 

![image-20210320130632001](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320130632001.png)





![image-20210320110437650](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110437650.png)



获取ClassLoader的途径：

![image-20210320130821877](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320130821877.png)







## 双亲委派机制



Java虚拟机对class文件才用的是 **按需加载**的方式，当需要使用该类是才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机才用的是 **==双亲委派模式==**，即**把请求交由父类处理，它是一种任务委派模式**







例：

```java
package java.lang;

public class String {
    //初始化阶段 clinit
    static {
        System.out.println("我是自定义的String类！");
    }
}
```

```java
public class StringTest {
    public static void main(String[] args) {
        java.lang.String str = new java.lang.String();//不是自定义的String，用的还是核心api中的String类
        System.out.println("hello");
        System.out.println(str.getClass().getClassLoader());//null 使用的是启动类加载器
    }
}
```



**工作原理**：

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委**托给父类的加载器**去执行，使用AppClassLoader的parent：ExtClassLoader

2. 如果父类加载器化存在其父类加载器，则**进一步向上委托**，依次递归，**==请求最终将到达顶层的启动类加载器==**

3. 如果**父类加载器可以完成类加载任务**，就成功返回，倘若父类加载器无法完成此加载任务，**子加载器才会尝试自己去加载**，**这就是双亲委派模式**

   **（启动类加载器只加载包名为java,javax,sun开头的类）**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320132335504.png" alt="image-20210320132335504" style="zoom:150%;" />



若此时在java.lang.String中写一个main方法

![image-20210320133952868](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320133952868.png)

**最终加载的是核心包中String类，但这里面并没有main方法。完全不会加载自定义的String类**



---

栗子：



![image-20210320134115501](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320134115501.png)

接口是核心类，接口的实现类是第三方jar包



优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被随意修改
  - 自定义类java.lang.String 

找到引导类加载器，发现是java开头包名，加载这个类，直接报错

![image-20210320134613853](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320134613853.png)





---

 **沙箱安全机制**：

自定义String类，但是在加载自定义String的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程会先加载jdk自带的文件（rt.jar中java/lang/String.class），报错说没有main方法。这样可以**保证对java核心源代码的保护**，**这就是沙箱安全机制**





## 其他



JVM中表示两个class对象是否为同一个类存在两个必要条件：

- 类的完整类名必须一致，包括包名
- 加载这个类的ClassLoader（ClassLoader实例对象）必须相同



在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也不同





---

**类加载器的引用**

如果一个类型是由用户类加载器加载的，**那么JVM会将这个==类加载器的一个引用作为类型信息==的一部分保存在==方法区==中**，当解析一个类型到另一个类型的引用时，JVM需要保证这两个类型的类加载器是相同的。





---

类的主动使用和被动使用



主动使用：

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（Class.forName()）
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- 动态语言支持invoke.MethodHandle....



**其他都是对类的被动使用，都不会导致类的初始化**







# 运行时数据区



## 运行时数据区内部结构

 执行引擎执行的过程中也都**用到了运行时数据区**

![image-20210320142938272](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320142938272.png)



 内存是非常重要的系统资源，承载操作系统和应用程序的实时运行。JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。

**不同的JVM对于内存的划分方式和管理机制存在着部分差异。**



![image-20210320143430824](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143430824.png)

![image-20210320143505089](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143505089.png)





![image-20210320143518524](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143518524.png)



Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而出阿年，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着县城开始和结束而创建和销毁



![image-20210320144015179](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320144015179.png)

灰色为单独线程私有的：程序计数器、本地方法栈、虚拟机栈

红色为多个线程共享的，堆heap、堆外内存（元空间/方法区、代码缓存）





![image-20210320144608624](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320144608624.png)

**每个JVM只有一个Runtime实例，即运行时数据区，内存结构中的运行时环境**





## 线程



JVM允许一个应用有**多个线程并行执行**

在HotSpot JVM里，**==每个线程都与操作系统的本地线程直接映射==**。

- **当一个Java线程准备好执行以后**，此时一个**操作系统的本地线程也同时创建**，java线程执行终止后，本地线程也会回收

操作系统负责所有线程的安排调度到一个可用的CPU上。一旦本地线程初始化成功，就会**调用java线程中的`run()`方法**



后台系统线程（HotSpot JVM）

- 虚拟机线程，JVM达到安全点才会出现，stop-the-world
- 周期任务线程
- GC线程，垃圾回收
- 编译线程，字节码编译成本地代码
- 信号调度线程







## 程序计数器（PC寄存器）



### PC Register介绍



![image-20210320145806983](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320145806983.png)



Program Counter Register程序计数寄存器。

这里并非是广义上所指的物理寄存器，JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟



**作用：**

**PC寄存器用来存储指向下一条指令的地址，就是即将要执行的指令代码。由执行引擎读取下一条指令**



![image-20210320150032281](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320150032281.png)



- 是一块**很小的内存空间**，非常小，运行速度最快！

- 每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

- 任何时间一个线程都只有一个方法在执行，**当前方法**。程序计数器会存储**==当前线程正在执行的Java方法的JVM指令地址==**；或者如果是在执行native方法，则是未指定值（undefined）

- 是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取**下一条需要执行的字节码指令**
- 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域



**==GC和OOM都不会发生在程序计数器中==**

 





### 栗子



```java
public class PCRegister {
    public static void main(String[] args) {
        int i = 10;
        int j  = 20;
        int k = i + j;
    }
}
```

第一列就是**==指令地址/偏移地址==**

第二列是**==操作指令==**

```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 return
```





```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 ldc #2 <abc>  常量池中取常量  两个操作
12 astore 4
14 getstatic #3 <java/lang/System.out>  也在常量池中
17 iload_1
18 invokevirtual #4 <java/io/PrintStream.println>
21 getstatic #3 <java/lang/System.out>
24 iload_3
25 invokevirtual #4 <java/io/PrintStream.println>
28 return
```

常量池：

![image-20210320151518571](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320151518571.png)







![image-20210320152113344](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320152113344.png)

地址5存储的是 istore_2操作指令，执行引擎通过PC寄存器找到下一个需要执行的指令的地址：**5**，再去局部变量表LV、操作数栈OS**使用这个地址**获取**操作指令**，编译成机器指令进行操作.....



### 两个常见问题



**使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**



因为CPU需要**不停地切换**各个线程，这时候**切换回来**以后，就得知道接着**从哪开始继续执行**

JVM的**字节码解释器**就需要通过**改变PC寄存器的值**来明确**下一条应该执行什么样的字节码指令**

![image-20210320153646579](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320153646579.png)





---



**PC寄存器为什么会被设定为线程私有**

肯定不能共用啊！不能让多个线程共用PC寄存器

多线程在一个特定的时间段内只会执行其中某一个线程的方法，Cpu会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？***为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。***



> CPU时间片限制，中多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器的一个内核，只会执行某个线程的一条指令

![image-20210320154234725](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320154234725.png)



> CPU时间片：
>
> CPU分配给各个程序的时间，每个线程被分配一个时间段-时间片。每个程序轮流执行
>
> 并行：(和串行相反)，同时在执行，一个时间点切面上多个程序在执行
>
> 并发：一个核快速切换，（伪并行）。



---



方法A调用方法B的时候，PC寄存器会跟着移动到B方法去。当B执行完后，要能返回A继续执行，就需要A当时执行到的那条指令的地址。所以，在B的栈帧中保存A当时的指令地址(当时PC寄存器的值)，当B执行完后，根据此返回地址跳回A。

**没有PC寄存器，执行器也会按照指令的顺序一条条正常执行**。PC寄存器的作用在于**多线程切换**的时候，能找到每个线程执行的位置，所以它是线程私有的。



当执行native方法时，原生的CPU上的对应的线程接管。若此时线程切换是原生CPU的PC寄存器管理，能确保native方法执行完。

当native方法执行完后，会出栈(栈帧pop)，返回到被调用的地方继续执行程序。









## 虚拟机栈

Java Virtual Machine Stack



### 虚拟机栈概述



由于跨平台性的设计，Java的指令根据栈来设计。

**优点是跨平台，指令小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令**



内存只有堆栈？？？？



**栈是运行时的单位，而堆是存储的单位**

> 栈解决程序的**运行问题**，即程序如何执行，或者说如何处理数据
>
> 栈中存放变量...对变量执行指令...都是栈来做的   局部变量表、操作数栈
>
> 
>
> 堆解决的是**数据存储**的问题，即数据怎么放、放在哪儿



  **Java虚拟机栈是什么？**

每个线程在创建时都会创建一个**==虚拟机栈==**，内部保存一个个的**栈帧Stack Frame**，对应着一次次的***Java方法调用***，且是线程私有的

![image-20210320162739765](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320162739765.png)

栈顶B：当前方法。出栈，A变成当前方法



**生命周期**

​	和线程一致

**作用：**

​	主管Java程序的运行，**保存方法的局部变量（8种基本数据类型、对象的==引用地址==(对象本身存放在==堆空间==)）、部分结果，并参与方法的调用和返回**

​	局部变量 vs 成员变量/属性

​	基本数据变量 vs 引用类型变量





---

栈的特点（优点）

- 栈是一种快速有效的分配存储方式，**访问速度**仅次于程序计数器

- JVM直接对Java栈的操作只有两个：

  - 每个***方法执行***，伴随着**进栈**（入栈、压栈）
  - 执行结束后的**出栈工作**

- 对于栈来说**不存在垃圾回收问题**

  栈不存在GC，存在OOM，会溢出





### 面试题：开发中遇到的异常有哪些



**栈中可能出现的异常**

- Java虚拟机规范允许**==*Java栈的大小是动态的或者是固定不变的*==**
  - 如果采用**固定大小的java虚拟机栈**，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果**线程请求分配的栈容量**超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个`StackOverflowError`异常
  - 如果Java虚拟机栈可以**动态扩展**，并且尝试扩展的时候**无法申请到足够的内存**，或者在创建新的线程时**没有足够的内存区**创建对应的虚拟机栈，那Java虚拟机将会抛出一个 `OutOfMemoryError`异常

```java
public static void main(String[] args) {
    main(args);
}
```

![image-20210320164505903](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320164505903.png)



- **设置栈内存大小**

  是用参数-Xss选项来设置爱线程的最大栈空间，栈的大小直接决定了函数调用的最大深度

![image-20210320164914785](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320164914785.png)



```java
private static int count = 1;
public static void main(String[] args) {
    System.out.println(count++);//默认count=9830
    main(args);
}
```

![image-20210320165200489](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320165200489.png)

修改虚拟机栈的大小：count=2263，设置的栈的大小起作用了

**栈的大小直接决定了函数调用的最大深度！**





### 栈的存储单位



**栈中存储什么？**

- 每个线程都有自己的栈，栈中的数据都是以**栈帧Stack Frame**的格式存在
- 这个线程上正在执行的**每个方法都各自对应一个栈帧**，**==方法和栈帧一一对应==**
- 栈帧就是一个**内存区块**，是一个**数据集**，维系着方法**执行过程中**的各种数据信息

> 类，对象
>
> field（属性、字段、域），method（方法）

- JVM直接对Java栈的操作只有两个，就是对栈帧的 **压栈 & 出栈**，FIFO原则
- 在**一条活动线程**中，一个时间点上，只会有**一个活动的栈帧**。即当前在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为 **当前栈帧Current Frame**，与当前栈帧对应的是当前方法Current Method，定义这个方法的类就是 **当前类Current Class**
- 执行引擎运行的所有字节码指令**只针对当前栈帧进行操作**

- 如果在该方法中**调用了其他方法**，对应的新的栈帧就会被其创建出来，放在栈的顶端，成为新的栈帧

![image-20210320170059505](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320170059505.png)

> Debug左侧显示的Frames就是栈帧结构显示
>
> ![image-20210320170834142](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320170834142.png)





- 不同线程中所包含的栈帧是**不允许存在相互引用**的，即不可能在一个栈帧之中引用**另一个线程**的栈帧，**相互隔离！**
- 如果当前方法调用了其他方法，方法返回之际，**==当前栈帧会传回此方法的执行结果给前一个栈帧==**，接着，虚拟机会**丢弃**当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式，
  - **一种是正常的函数返回，使用return指令**
  - **另一种是抛出异常Throw Exception(不是try-catch)，不管使用哪种方式，都会导致栈帧被弹出**，把异常抛给上一层的栈帧，看能不能处理？继续往上抛.....

> 返回值void写return也没问题，因为方法返回的指令最后都会有return，不过是可以省略







### 栈帧的内部结构

 

**每个栈帧**中存储着：

- **局部变量表Local Variables**
- **操作数栈Operand Stack 或表达式栈**

- 动态链接Dynamic Linking（或指向运行时常量池的方法引用）
- 方法返回地址Return Address 或方法正常退出或者异常退出的定义
- 一些附加信息



![image-20210320181056054](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320181056054.png)





![image-20210320181851764](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320181851764.png)



### 局部变量表



Local Variables



局部变量数组/本地变量表

- **定义为一个==数字数组==，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括八种基本类型数据，对象引用reference，以及returnAddress类型
- 由于局部边来那个表是建立在线程的栈上，是线程的**私有数据**，因此**不存在数据安全问题**
- **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的

↓

这个容量指的就是最大容量，编译的时候确定了**有几个变量**。局部变量表的大小就为这个值。并且在运行时不会改变

![image-20210320182800335](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320182800335.png)

![image-20210320182807852](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320182807852.png)



<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320183226961.png" alt="image-20210320183226961" style="zoom:150%;" />



- **方法嵌套调用的次数由栈的大小决定。**一般来说，**栈越大，方法掐按套调用次数越多**。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀。它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。今儿函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少
- **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成  参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁。局部变量表也会随之销毁**



代码中的行号和字节码指令的行号对应

![image-20210320194445112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194445112.png)

局部变量表：

![image-20210320194620054](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194620054.png)

![image-20210320194641417](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194641417.png)

![image-20210320194705460](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194705460.png)

每个变量都有相应的索引

Start PC：字节码指令的行号

Length：当前变量作用域范围->长度范围，声明完后就可以用了





#### 关于Slot的理解

- 参数值的存放总是在局部变量数组的index0开始 ，到length-1结束
- **局部变量表，最基本的存储单元就是Slot（变量槽）**
- 局部边来那个表中存放编译器可知的各种基本数据类型（8种），引用类型和returnAddress类型的变量
- 在局部变量表里，**32位以内的类型只占用一个slot，包括引用和returnAddress，64位（long&double都是8个字节 8*8）占用两个slot **
  - byte、short、char转换为int

- JVM会为局部变量表中的每一个Slot分配一个**访问索引**，通过这个索引即可成功访问到局部变量表中指定的局部变量值，long和double使用他们的**起始索引，即前一个索引**
- 当一个实例方法被调用的时候，它的方法参数和方法体内定义的局部变量将会 **按照顺序被赋值**到局部便能量表中的每一个slot上
- 如果当前帧是由构造方法或者实例方法创建的，那么 **该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列**



构造方法：

![image-20210320201303871](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201303871.png)

如果是在构造器中对类变量进行赋值，那么不会在lv中保存，因为都是属于this实例的值，局部变量表中放入一个this就够了

静态方法：

```java
public static void test(){
    int i = 1;
    int j = 2;
}
```

![image-20210320201712970](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201712970.png)

非静态方法：

```java
public void test(){
    int i = 1;
    int j = 2;
}
```

![image-20210320201745604](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201745604.png)

说明如果不是static方法，那么在该方法栈帧的局部变量表中，一定是有this这个变量的，才可以调用。**在static方法中就无法使用this，因为局部变量表中没有！**



```java
public void test(){
    long i = 1;
    double j = 2.55;
}
```

![image-20210320202848079](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320202848079.png)

this引用使用一个槽，**long和double各用两个槽**



---



**Slot的重复利用**



**栈帧中的局部变量表中的槽位是可以重用的**，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会**复用**过期局部变量的槽位，从而 **达到节省资源的目的**

![image-20210320203702951](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203702951.png)

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203747030.png" alt="image-20210320203747030" style="zoom:150%;" />

**重复利用**，数组的这个位置已经开辟了，不能浪费，查看是否有变量在该变量声明之前过期了，如果有，就直接使用那个变量的槽位

![image-20210320203813288](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203813288.png)

```java
public void test(){
    int x = 1;
    {
        long i = 1;
    }
    int y = 2;
}
```

![image-20210320204131679](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320204131679.png)

this+x+y+long = 5 但由于long过期了，y使用了slot的槽位

![image-20210320205336743](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320205336743.png)



---



**静态变量与局部变量的对比**



> 变量分类：
>
> - 数据类型：基本数据类型 & 引用数据类型
>
> - 按照在类中声明的位置：成员变量（类变量  & 实例变量(归具体的实例所有) ）  &  局部变量
>   - 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并默认赋值
>   - **成员变量在使用前，都经历过初始化默认值**，**linking的prepare阶段**，给类变量默认赋值零值，initialization给类变量显式赋值以及静态代码块赋值
>   - 局部变量：在使用前**必须要显式赋值**。否则编译不通过
>     - 每一个方法都有一个栈帧，其中的局部变量表保存局部变量，不会有默认赋值，必须要显式赋值



- 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配
- **准备阶段，执行系统初始化，对类变量设置零值，初始化阶段，赋予静态变量初始值和静态代码快中的初始值**
- 局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用



---

**补充说明：**

- 在栈帧中，与**性能调优**关系最为密切的部分就是前面提到的**局部变量表**。在方法执行时，虚拟机使用**局部变量表**完成**方法的传递**

  

- **局部变量表中的变量也是重要的垃圾回收    根节点，只要被局部变量表中直接或间接引用的对象都    不会被回收**







### 操作数栈



Operand Stack



> 栈：可以使用数组，链表来实现



- 每一个独立的栈帧中，除了包含局部变量表意外，还包含一个操作数栈，也可以称之为表达式栈
- **操作数栈，再方法执行的过程中，根据字节码指令，可以往栈中写入数据或提取数据，即入栈出栈**
  - 某些字节码指令将值**压入**操作数栈，其余的字节码指令将操作数**取出栈**。使用它们后把结果压入栈 
  - 比如：执行复制、交换、求和等操作
- **这个过程需要根据字节码指令来进行从操作**

![image-20210320213854275](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320213854275.png)



![image-20210320214147145](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320214147145.png)



- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量   ->  临时的存储空间**

- 操作数栈就是JVM执行引擎的一个工作去，当一个方法刚开始执行的时候，一个新的栈帧也会随着被创建出来，**这个方法的操作数栈是空的**  --->  但其实是有空间的，只是没有值，数组一旦确定，长度是确定的！

- 每一个操作数栈都会拥有一个**明确的栈深度用于存储数值（编译期）**，其所需的**最大深度在编译期就定义好了**，保存咋地方法的Code属性中，为max_stack值

  ![image-20210320214511808](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320214511808.png)

- 栈中任何一个元素都是可以任意的Java数据类型：

  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用2个栈单位深度

- 操作数栈 **并非采用访问缩印的女方是来进行数据访问的**，而是只能通过标准的入栈/出栈操作来完成一次数据访问



- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新**PC寄存器**中**下一条**需要执行的字节码指令

![image-20210320223916346](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320223916346.png)

​	**iload压入操作栈**

**aload_0 获取上一个栈帧返回的结果，并保存在操作数栈上**

> .aload_0是装载第一个(0)局部变量引用的对象

​	![image-20210320224117168](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320224117168.png)





- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
- java虚拟机 **解释引擎是基于栈的执行引擎**





### 代码追踪

```java
public test() {
    byte i = 15;
    int j = 8;
    int k = i + j;
}
```

解析class文件：

![image-20210320221007882](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320221007882.png)

> JVM中 int 类型数值，根据 取值范围将 入栈的 **字节码指令** 就分为4类：
>
> 取值 **-1~5** 采用 `iconst` 指令；
>
> 取值 **-128~127** 采用 `bipush` 指令； byte 2 int
>
> 取值 **-32768~32767** 采用 `sipush`指令； short 2 int
>
> 取值 **-2147483648~2147483647** 采用 `ldc` 指令。
>
> i2l：Convert `int` to `long`





```
 0 bipush 15  # 压入操作数栈中
 2 istore_1   # 从操作数栈中取出值15，压入局部变量表中。局部变量表0位置放的是this引用
 3 bipush 8
 5 istore_2   # ..
 6 iload_1 	  # 在局部变量表中把1和2的位置的数据依次取出
 7 iload_2
 8 iadd
 9 istore_3
10 return
```

istore操作使操作数栈中的数弹出并放入局部变量表中

**每进行一次操作，PC寄存器都会调整**

![image-20210320222648067](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320222648067.png)



iload：将局部变量表中的数压入操作数栈中，

![image-20210320222831550](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320222831550.png)

iadd

![image-20210320223012477](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320223012477.png)

再存储到局部变量表中



**操作数栈自始至终用两个空间就够了！**







### i++和++i的区别



```
int i1 = 10;i1++;
int i2 = 10;++i2;
这两个是一样的
-------------------------

int i3 = 10;
int i4 = i3++;

int i5 = 10;
int i6 = ++i5;

-------------------------

int i7 = 10;
i7 = i7++;

int i8 = 10;
i8 = ++i8;


-------------------------

int i9 = 10;
int i10 = i9++ + ++i9;

```





```
 0 bipush 10
 2 istore_1
 3 iinc 1 by 1
 6 bipush 10
 8 istore_2
 9 iinc 2 by 1
 ----------------------
12 bipush 10
14 istore_3
15 iload_3
16 iinc 3 by 1
19 istore 4

21 bipush 10
23 istore 5
25 iinc 5 by 1
28 iload 5
30 istore 6
---------------------------
32 bipush 10
34 istore 7
36 iload 7
38 iinc 7 by 1  #对局部变量表中的数+1，然后放回去的是没+1的数
41 istore 7

43 bipush 10
45 istore 8
47 iinc 8 by 1
50 iload 8
52 istore 8
---------------------------
54 bipush 10
56 istore 9
58 iload 9
60 iinc 9 by 1
63 iinc 9 by 1
66 iload 9
68 iadd
69 istore 10
71 return

```





### 栈顶缓存



Top-of-Stack Caching



基于栈式架构的虚拟机所使用的的**零地址指令**更加紧凑，但完成一项操作的时候必要需要使用更多的入栈和出栈指令，这通水也就意味着将需要更多的指令分派次数和内存读写次数



由于操作数是存储在内存中的，会因此频繁的执行内存读写操作必然会影响执行速度。为了解决这个问题，JVM的设计者们提出了栈顶缓存技术，**将   栈顶元素  全部缓存在==物理CPU的寄存器==中，以此降低对内存的读写次数，提升执行引擎的执行效率**







### 动态链接

**指向运行时常量池的方法引用**

Dynamic Linking

帧数据区：一些附加信息+动态链接+方法返回地址



- 一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。

- 每一个栈帧内部都包含指向 **运行时常量池**中   **==该栈帧所需 方法的引用，其实就是指向运行时常量池的方法引用==**。包含这个引用的目的就是为了支持当前方法的代码能够实现 **动态链接**。比如：invokedynamic指令

- 在Java源文件被编译到字节码文件中时，==**所有的变量和方法引用**都作为**符号引用保存在class文件的常量池里**==。比如：描述一个方法调用另外的方法时，就是通过常量池中指向方法的符号引用来表示的，**那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**



![image-20210320234339008](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234339008.png)



完整类名、名字、描述符。

![image-20210320234354501](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234354501.png)



![image-20210320234406910](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234406910.png)





栈帧中存储的地址->运行时常量池中这个方法的引用

Current Class Constant Pool

![image-20210321000915057](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321000915057.png)

只要用到了这个方法，那么就直接指向运行时常量池中的这个方法地址来进行调用！



![image-20210321002749115](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321002749115.png)



![image-20210321002806814](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321002806814.png)







---



为什么需要常量池呢？

字节码文件需要很多文件、数据的支持。

提供一些符号和常量，便于指令的识别





### 方法的调用



在JVM中，将**符号引用**（#7、#8.....）转换为调用方法的**直接引用**与方法的绑定机制相关。



- **静态链接**

  当一个字节码文件被装载进JVM内部时，如果被调用的 **目标方法在编译期可知，**且**运行期保持不变**时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

- **动态链接**

  **如果被调用的方法在编译器无法被确定下来**，也就是说，只能够在**程序运行期将调用方法的符号引用转换为直接引用**，由于这种引用转换过程具备**动态性**，因此被称为动态链接



----



对应的方法的绑定机制为 早起绑定、晚期绑定。

**绑定是一个字段、方法或者类在   ==符号引用被替换为直接引用==   的过程，这仅仅发生一次**

- **早期绑定**

  被调用的目标方法如果在**编译期可知**，且**运行期保持不变**，将这个方法与所属的类型进行绑定。明确了被调用的目标方法究竟是哪一个，可以使用静态链接的方式将**符号引用转化为直接引用。**

  如：this(),super()

- **晚期绑定**

  **如果被调用的方法在编译器无法被确定下来**，**只能够在程序==运行期==根据 ==实际的类型== 绑定相关的方法**



----

**封装、继承、多态。具备多态特性，那么自然也就具备早起绑定和晚期绑定两种绑定方式**

Java中任何一个普通的方法都具备虚函数的特征——>**运行期才能确定**。在Java中不希望某个方法拥有虚函数的特征时，可以使用**关键字final**来标记这个方法，就不能进行重写了！





---



**非虚方法：**

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，称为非虚方法
- **静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**，
  - 静态方法、私有方法、**final方法**都不能被重写
    - final方法如果在父类中定义过，那么子类中不能出现与父类的final方法签名（方法名+参数）相同的final方法，会被视为重写，**而final方法不允许重写**
  - 实例构造器`this()`，通过重载已经确定调用哪一个构造器。而且构造器也不能被重写
  - 父类方法，`super()，super.xxx()`，也很确定，可以直接绑定
- 其他方法称为虚方法





虚拟机中提供了几条方法调用指令：

普通调用指令：

1. **invokestatic：调用静态方法，解析阶段确定唯一方法版本**
2. **invokespecial：调用 `<init>`方法、私有及父类方法，解析阶段确定唯一方法版本**
3. invokevirtual：调用所有虚方法（final方法除外）
4. invokeinterface：调用接口方法->肯定是进行重写的方法

动态调用指令：

5. invokedynamic：动态解析出需要调用的方法，然后执行
   - 支持由用户胡确定方法版本

1，2调用的方法称为非虚方法，再加一个invokevirtual调用的final方法



- 注意：子类中调用父类中的final方法，如果不加super.showFinal()，会使用 `invokevirtual`指令来调用，**但实际也是调用的父类的final方法，因为final方法不允许重写**。如果加了`super.`那么就使用 `invokespecial`指令，这个方法是确定的，所以final方法也是虚方法
- 如果在子类中调用父类的**普通方法并且没有重写**，不显式加`super.`  使用指令`invokevirtual`，编译期间无法确定是否有重写，虚方法！



---

关于invokedynamic指令

- JVM字节码指令集一直比较稳定，jdk7中增加了invokedynamic指令，这是 **java为了实现【动态类型语言】支持而做的一种改进**
- jdk7中需要借助ASM这种底层字节码工具来产生invokedynamic指令。jdk8的Lambda表达式的出现，invokedynamic指令的生成在java中才有了直接的生成方式
- java7中增加的动态语言类型支持的本质是**对java虚拟机规范的修改**，而不是对java语言规则的修改。增加了虚拟机中的方法调用



---

动态类型语言 和 静态类型语言

区别在于对**类型的检查**是在编译器还是在运行期，满足前者就是静态类型语言，反之是动态类型语言

java是静态类型语言，必须制定类型int/String/double/......

js：var name="...";  var name = 10;所有的变量都叫var

python：info = 130.99; info = "xxx";

- **静态类型语言是判断==变量==自身的类型信息**

- **动态类型语言是判断==变量值==的类型信息，变量没有类型信息，变量值才有类型信息**



```java
public class lambdaTest {
    public void lambda(Func func){
        return;
    }

    public static void main(String[] args) {
        lambdaTest labmdaTest = new lambdaTest();
        Func func = str -> {
            return true;
        };
        labmdaTest.lambda(func);
        labmdaTest.lambda(s -> {
            return true;
        });
    }
}
interface Func{
    public boolean func(String str);
}
```

` invokedynamic #4 <func, BootstrapMethods #0>`

在编译期并不知道是继承/实现谁的对象，只有在运行期才能确定下来是Func接口的实现类，根据对象的值来确定





---



Java语言中方法重写的本质：

1. 找到**操作数栈顶**的第一个元素所执行的**对象的实际类型**，记作  C
2. 如果在类型 C 中找到与常量中**描述符  简单名称都相符**的方法，则进行**访问权限校验**，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError` 异常
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
4. 如果最终没有找到合适的方法，则抛出 `java.lang.AbstractMethodError`异常



`java.lang.IllegalAccessError` ：

程序视图访问或修改一个属性或调用一个方法，这个属性或方法你**没有权限访问**。

一般会引起编译器异常，这个错误如果发生在运行时，说明一个类发生了不兼容的改变->maven jar包冲突





---

**虚方法表**

- 频繁的使用到动态分派，每次动态分派的过程中都要重新在类的方法**元数据**中搜索合适的目标的话就可能影响到执行效率。**为了提高性能，jvm采用在类的方法区建立一个虚方法表来实现。使用索引表来代替查找**

- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
- 什么时候被创建？
  - 在类加载的链接阶段（**解析阶段：将常量池内的符号引用转换为直接引用**）被创建并开始初始化，类的变量初始化准备完成之后，jvm会把该类

栗子：

![image-20210321125217469](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125217469.png)

直接将Son中的toString()指向Object中的方法，而不会往上层去查找



栗子：

![image-20210321125413756](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125413756.png)



![image-20210321125545726](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125545726.png)





![image-20210321125901481](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125901481.png)





![image-20210321130117470](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321130117470.png)





### 方法返回地址



Return Address



- 存放调用该方法的pc寄存器的值
- 一个方法的结束，有两种方式：
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种方式退出，在方法退出后都**返回到该方法被调用的位置**。方法正常退出时，**==调用者的PC计数器的值作为返回地址==，即调用该方法的指令的==下一条指令的地址==**。而通过异常退出的，返回地址是要通过**异常表**来确定，栈帧中一般不会保存这部分信息



方法的退出就是当前栈帧出栈的过程，需要**恢复上层方法的局部变量表、操作数栈、==将返回值压入调用者栈帧的操作数栈==、==设置PC寄存器值==**等，让调用者方法**继续执行下去**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321131225375.png" alt="image-20210321131225375" style="zoom:150%;" />



**异常完成出口退出的不会给他的上层调用者产生任何的返回值**





---



一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令return，会有返回值传递给上层的方法调用者，**正常完成出口**

   - ireturn/lreturn/freturn/dreturn/areturn（引用类型）/return(void，实例初始化方法，类和接口的初始化方法)

2. 遇到了异常，并且这个异常没有在方法内进行处理，在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。**异常完成出口**

   抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码

![image-20210321134220154](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134220154.png)



![image-20210321134625057](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134625057.png)

指令索引4-9间   出现异常就跳转到指令12进行catch处理，然后goto 17继续执行程序

![image-20210321134630982](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134630982.png)

![image-20210321134640762](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134640762.png)







### 一些附加信息



栈帧中还允许携带与java虚拟机实现相关的一些附加信息。如：对程序调试提供支持的信息





### 栈的相关面试题



- 距离栈溢出的情况？StackOverflowError
  - 通过-Xss来设置栈的大小，但还是会出现 OOM
- 调整栈的大小，就能保证不出现溢出吗？ 
  - 只要递归够深，栈帧够大，肯定可以溢出~~
- 分配的栈内存越大越好吗？
  - 延缓StackOverflowError时间，但无法彻底避免
  - 占用其他线程空间/其他区域空间，
- 垃圾回收是否会涉及到虚拟机栈？
  - 不会。只是出栈入栈，不需要垃圾回收
- 方法中定义的局部变量是否线程安全？
  - 具体问题具体分析
  - 

> 线程安全？
>
> 只有一个线程才可以操作此数据，则肯定是线程安全的
>
> 如果有多个线程操作此数据，则此数据是 共享数据，如果不考虑同步机制的话，会存在线程安全问题。

**局部变量不会存在线程不安全的问题，其他变量无法访问到**

![image-20210321142036549](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142036549.png)



----

变量不归当前方法所有，多个线程都可以调用这个方法来对该变量进行操作，就是线程不安全的

![image-20210321142316902](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142316902.png)

![image-20210321142510261](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142510261.png)



---

针对s1的操作是线程不安全的（**间接不安全**），返回以后可能会被其他的多个线程获取到进行操作，进而导致线程不安全

![image-20210321142557192](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142557192.png)

 

> **将局部变量封闭在方法内，不要传出去。。。。是最安全的**

---

**因为String的值在初始化的时候确定（final），无法进行改变，只能读取。s1是线程安全的，其实String也是线程安全的**

![image-20210321142804178](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142804178.png)





运行时数据区各部分：

|            | Error   | GC     |
| ---------- | ------- | ------ |
| 程序计数器 | 不存在  | 不存在 |
| 虚拟机栈   | 存在    | 不存在 |
| 本地方法栈 | 存在    | 不存在 |
| 方法区     | 存在OOM | 存在   |
| 堆         | 存在OOM | 存在GC |







## 本地方法接口



![image-20210321150310455](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321150310455.png)



本地方法：

一个 Native方法就是一个Java调用非java代码的接口。该方法的实现由非java语言实现，比如C，这

在定义一个native Method时，并不提供实现体，因为其实现体是由非java语言在外面实现的

本地接口的作用是融合不同的编程语言为java所用，融合C/C++程序

```java
public final native Class<?> getClass();
```





**native和abstract是不共用**的。native是有方法体！

**native可以和权限public/private ，static ，synchronized 等配合使用。**



---



**为什么要使用native Method？**

有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了

- **与java环境外交互**

  **有时java应用需要与java应用外面的环境交互，这是本地方法存在的主要原因。**java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。使我们无需去了解java应用之外的繁琐的细节。

- **与操作系统交互**

  jvm不是一个完整的系统，经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。**使用本地方法，我们得以用java实现了jre的底层系统的交互，甚至ijvm的一些部分就是用c写的。**使用一些java语言本身没有提供封装的操作系统的特性时，也需要使用本地方法

- **Sun's Java**

  **Sun的解释器使用C实现的，使得它能像一些普通的C一样与外部交互**。jre大部分是用java实现的，也通过一些本地方法与外界交互。比如start0(), setPriority0()方法，被植入JVM内部，由java方法来进行调用，最终进行调用操作系统的API。这个方法的具体实现由JVM提供，更多的情况是本地方法由**外部的动态链接库**提供，然后被JVM调用





**目前该方法的而是用越来越少了，除非是与硬件有关的应用**，比如通过java程序驱动打印机或者java系统管理生产设备....





## 本地方法栈



![image-20210321152451743](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321152451743.png)



- **Java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用。**

- 本地方法栈，也是线程私有的
- 允许被是线程固定或者是可动态扩展的内存大小（和jvm栈一样。。内存溢出方面也相同）
  - StackOverflowError
  - OOM Error
- 本地方法是使用C语言实现的
- 具体做法是 Native Method Stack中登记native方法，在Execution Engine执行引擎执行时加载本地方法库



![image-20210321152846425](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321152846425.png)



- **当某个线程调用一个本地方法时，它就进入了一个全新的并且==不再受虚拟机限制==的世界，*它和虚拟机拥有同样的权限***
  - 本地方法可以通过**本地方法接口**来访问**虚拟机内部的运行时数据区，堆/方法区/.....**
  - 它甚至可以**直接**使用***本地处理器中的寄存器 -> cpu寄存器***
  - 直接存**本地内存 -> 物理内存**的堆中分配任意数量的内存



- **并不是所有的JVM都支持本地方法。因为java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等**。如果jvm产品不打算支持native方法，也可以无需实现本地方法栈
- 在HotSpot JVM中，直接将**本地方法栈和虚拟机栈合二为一**
  - 调用java方法中，内部调用了本地方法，本地方法栈使用动态链接指向本地方法，由执行引擎执行













## 堆



### 堆的核心概述



方法区和堆对于一个进程（JVM实例）来说是唯一的。可被多个线程共享。



- 一个**JVM实例只存在一个堆内存（不同的java进程，即每一个main方法）**，堆也是java内存管理的核心区域
- java堆区在jvm启动的时候即被创建，其**空间大小**也就确定了。是jvm管理的最大一块内存
  - ***堆内存的大小是可以调节的***
  - -Xms10m  -Xmx10m
- 堆可以处于物理上**不连续的内存空间**中，但在**逻辑上**它应该被视为连续的
- **所有的线程共享java堆**，在这里还可以划分**线程私有的缓冲区**（**Thread Loacl Allocation Buffer  ——>  TLAB**）共享内存，线程安全问题，并发性很差。每个线程私有缓冲区，不需要考虑线程安全，并发性更好。

- **所有的对象实例以及数组都应当在运行时分配在堆上**
  - **几乎**所有的对象都在这里分配内存——实际使用角度....
- 数组和对象**可能永远都不会存储在栈上**，因为***栈帧中保存引用***，这个引用**指向**对象或者数组在***堆中的位置***
- 在方法结束后，没有引用指向堆中的对象，但堆中的**对象不会马上被移除**，仅仅在**垃圾收集的时候才会被移除**
  - 减少垃圾回收线程执行的频率
- 堆，是GC（Garbage  Collection，垃圾收集器）**执行垃圾回收的重点区域**，回收对象、数组

- 创建对象的指令：new newarray，anewarray，创建对象，开辟空间



工具jvisualvm.exe：

![image-20210321160706866](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321160706866.png)

相加是设置的堆内存空间



栈中变量指向堆中实例，实例来调用方法区中的方法。

![image-20210321170339618](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170339618.png)



---

**堆的核心概述：内存细分**

**现代垃圾收集器大部分是基于分代收集理论设计，堆空间细分为**



![image-20210321170532129](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170532129.png)



![image-20210321170713334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170713334.png)



----

设置堆空间为10M，设置的参数只负责新生代和老年代，**不负责元空间的大小**

![image-20210321171816078](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321171816078.png)





![image-20210321171959684](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321171959684.png)



---

jdk8中为元空间：

`-XX:+PrintGCDetails`

![image-20210321172202663](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321172202663.png)



修改为jdk7版本：

永久代

![image-20210321172411632](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321172411632.png)









### 设置堆内存大小与OOM



- java堆区用于cunchujava对象实例，那么堆的大小在jvm启动时就已经设定好了，可以通过选项：-Xmx和-Xms来进行设置
  - -Xms用于表示堆区（年轻代+老年代）的**起始内存**，等价于-XX:InitialHeapSize
    - -X: jvm的运行参数
    - ms：memory start
  - -Xmx用于表示堆区的**最大内存**，等价于-XX:MaxHeapSize



- 一旦堆区的内存大小超过-Xmx所指定的最大内存时，将会抛出OutOfMemoryError异常
- 通常会将-Xms和-Xmx两个参数配置相同的值，**其目的是为了能够在java垃圾回收**



- **默认**情况下，初始内存大小：物理电脑内存大小 / 64; 最大内存大小：物理内存大小 / 4

![image-20210321173040544](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321173040544.png)



```java
public static void main(String[] args) throws InterruptedException {

    long totalMemory = Runtime.getRuntime().totalMemory()/1024/1024;
    long maxMemory = Runtime.getRuntime().maxMemory()/1024/1024;

    System.out.println(totalMemory + "    " + maxMemory);
    System.out.println("系统内存大小："+totalMemory * 64.0 / 1024 + "G");
    System.out.println("系统内存大小："+maxMemory * 4.0 / 1024.0 + "G");

}
```

![image-20210321173627585](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321173627585.png)

**开发中建议将初始堆内存和最大的堆内存设置成相同的值，频繁扩容和释放消耗资源。**



手动设置时，也会比实际设置的值要小一点

`-Xmx600m -Xms600m`

实际打印：`575    575`

  

---



**查看设置的参数**：

（或者直接使用jvisual来看  或者 `-XX:+PrintGCDetails`）

![image-20210321174438815](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321174438815.png)

![image-20210321174425741](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321174425741.png)

```
25600 * 2 + 153600 + 409600  /  1024 = 600

25600 + 153600 + 409600  /  1024 = 575
```

????

伊甸园区+survivor区两个区只有一个区能使用。始终有一个survivor空间是空的。





-----



OOM：

![image-20210321175656555](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321175656555.png)

广义上的异常，`Error&Exception extends Throwable`

```java
List<String> list = new ArrayList<>();
while (true){
    list.add(new String("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"));
}
```

![image-20210321175616109](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321175616109.png)

看到溢出原因

![image-20210321180447859](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180447859.png)













### 年轻代与老年代



- 存储在JVM中的java对象可以被划分为两类
  - 一类是生命周期较短的顺势对象，这类对象的创建和消亡都非常迅速！
  - 另外一类对象的生命周期缺非常长，在某些极端的情况下还能够与jvm的生命周期保持一致
- Java堆区进一步细分的话，可以划分为年轻代YoungGen和老年代OldGen
- 其中**年轻代又可以划分为Eden空间(java最先创建的位置)、Survivor0空间和Survivor1空间**（from区、to区）

![image-20210321180926805](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180926805.png)



下面这参数开发中一般不会调：

![image-20210321180954210](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180954210.png)



- 配置新生代与老年代在堆结构的占比
  - -XX:NewRatio=2，表示新生代占1/3，老年代占2/3

- **如果生命周期长的对象多，将老年代调大一些**



- 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8:1:1

- 通过  -XX:SurvivorRatio=?  具体调整比例
- 但实际并不是8   1:1:7  
- **自适应机制**
- -XX:-UseAdaptiveSizePolicy关闭自适应内存分配策略。暂时没有用。。。 



- **几乎所有的java对象都是在Eden区被new出来的**
- 绝大部分的java对象的销毁都在新生代进行了
  - 新生代80%的对象都是"朝生夕死"的
- 可以使用选项-Xmn来设置新生代最大内存大小
  - 一般使用默认值



![image-20210321191620860](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321191620860.png)















### 对象分配过程



对象分配过程：

1. new的对象**先放在伊甸园区**，此区有大小限制
2. 当伊甸园的空间填满时，程序又需要创建对象，jvm的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC/Young GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区
3. 然后将伊甸园区中的**剩余对象移动到幸存者0区**
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的对象，如果没有被回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区
6. 什么时候能去养老区呢？可以设置次数。默认是15次
   - **设置参数：`-XX:MaxTenuringThreshold=<N>`**
7. 在养老区，相对悠闲，当养老区内存不足时，再次触发GC，Major GC，进行养老区的内存清理
8. 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生**OOM异常**



**幸存者区满了不会触发YGC，当Eden区满了后，YGC会将幸存者区和Eden区一起进行回收。被动回收**





红色的对象是被垃圾回收掉的

每一次垃圾回收都倒一下S0、S1中对象的位置

![image-20210321192654404](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321192654404.png)

---

- **针对幸存者s0，s1区的总结：复制之后有交换，谁空谁就是to(另一个是from)**

- **关于垃圾回收：频繁在新生区收集垃圾，很少在养老区收集，几乎不在永久区/元空间收集**



----

特殊情况：

YGC之后伊甸园区一定是空的

Eden放不下，一步到位，放到老年代。。。

Full GC老年代垃圾回收

**总之：放不下就放到老年代中。**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321194355936.png" alt="image-20210321194355936" style="zoom:150%;" />



![image-20210321200900344](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321200900344.png)

老年代满了——> OOM





### 常用调优工具



- jdk命令行
- Eclipse：Memory Analyzer Tool
- Jconsole
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy







### Minor GC、Major GC、Full GC



JVm再进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代

针对HotSpot VM，里面的GC按照回收区域又分为两大种类型：部分收集Partial GC，整堆收集Full GC



- 部分收集：不是完整收集整个java堆的垃圾收集
  - 新生代收集（Minor GC / Young GC），只是新生代的垃圾收集
  - 老年代收集（Major GC / Old GC），**只是老年代的垃圾收集**
    - 目前，只有**CMS GC**会有单独收集老年代的行为
    - **很多时候Major GC会和 Full GC混淆使用需要具体分辨是老年代回收还是整堆回收**
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    - 目前，只有**G1 GC**会有这种行为
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集







----



**年轻代GC触发机制**

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会触发GC，而每次Minor GC满会清理年轻代的内存
- 因为java对象大多都具备朝生夕死的特性，所以Minor GC；非常频繁，一般回收速度也比较快

- **Minor GC会引发STW（stop the word），暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行**

![image-20210321204631767](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321204631767.png)





---

**老年代GC（Major/ Full GC）触发机制**

- 指发生在老年代的GC，对象从老年代消失时，这两个GC会被触发
- 出现了Major GC 经常会伴随至少一次的MinorGC  (非绝对的，在Parallel Scavenge收集器的收集策略里有直接进行Major GC的策略选择过程)
  - 老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC
- **Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长** 
  - **调优：减少Major GC的次数**
- 如果Major GC后，内存还不足，就报OOM了



---

**Full GC触发机制**

1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor、space0区向survivor space1区复制时，对象大小大于To Space可用内存，则吧该对象转存到老年代，且老年代的可用内存小于该对象大小



**Full GC是开发或调优中尽量要避免的，这样暂停的时间会短一些。**

----

栗子：

```java
List<String> list = new ArrayList<>();
String a = "hcrhcrhcr";
while (true){
    list.add(a);
    a = a + a;
}
```



```
[GC (Allocation Failure) [PSYoungGen: 2017K->506K(2560K)] 2017K->830K(9728K), 0.0033778 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2078K->512K(2560K)] 2402K->1986K(9728K), 0.0005180 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2317K->480K(2560K)] 7247K->6027K(9728K), 0.0007253 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 480K->512K(2560K)] 6027K->6075K(9728K), 0.0005772 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 512K->0K(2560K)] [ParOldGen: 5563K->4129K(7168K)] 6075K->4129K(9728K), [Metaspace: 3316K->3316K(1056768K)], 0.0044339 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[GC (Allocation Failure) [PSYoungGen: 39K->32K(2560K)] 6472K->6465K(9728K), 0.0003212 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

[Full GC (Ergonomics) [PSYoungGen: 32K->0K(2560K)] [ParOldGen: 6433K->5281K(7168K)] 6465K->5281K(9728K), [Metaspace: 3316K->3316K(1056768K)], 0.0032575 secs] [Times: user=0.16 sys=0.00, real=0.00 secs] 


[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 5281K->5281K(8704K), 0.0006357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] [ParOldGen: 5281K->5259K(7168K)] 5281K->5259K(8704K), [Metaspace: 3316K->3316K(1056768K)], 0.0066352 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 


Heap
 PSYoungGen      total 1536K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 1024K, 6% used [0x00000000ffd00000,0x00000000ffd118e0,0x00000000ffe00000)
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 7168K, used 5259K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb22e18,0x00000000ffd00000)
 Metaspace       used 3348K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K
```

老年代逐渐变大，当Full GC后还没有剩余空间的时候，就OOM了

**元空间没有改变**

```
[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 5281K->5281K(8704K), 0.0006357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] [ParOldGen: 5281K->5259K(7168K)] 5281K->5259K(8704K), [Metaspace: 3316K->3316K(1056768K)], 0.0066352 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
```

**字符串越来越大，最后直接就放不下了  先进性YGC，再进行一次Full GC 还是装不下啊！——> OOM**









### 堆空间分代思想



***为什么需要把Java堆分代？不分代就不能正常工作了吗？***



- 不同对象的生命周期不同，70%-99%的对象是临时对象
- 新生代：有Eden、两块大小相同的Survivor（from/to）构成，to总为空
- 老年代：存放新生代中经历多次GC仍然存活的对象（或者放不下的对象）



- 其实不分代完全可以。**分代的唯一理由就是优化GC性能。**如果没有分代，所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建爱你的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来





![image-20210321211331349](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321211331349.png)









### 内存分配策略



如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设置为1.对象在Survivor区中每经历过一次Minor GC，年龄就+1，当它的年龄增加到一定程度（默认为15，可以设置，每个JVM的每个GC都有所不同）时，就会被晋升为老年代中

对象晋升老年代的年龄阈值，通过选项   `-XX:MaxTenuringThreshold`来设置



---

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- **大对象直接分配到老年代**
  - 尽量避免程序中出现过多的**大对象**——>更糟糕的是都是“朝生夕死”的.........折磨堆
- **长期存活**的对象分配到老年代
- **动态对象年龄判断**
  - 如果Survivor区中**相同年龄**的所有对象大小的综合**大于Survivor空间的一半**，年龄**大于或等于**该年龄的对象可以***直接进入老年代***，**免得两个Survivor来回倒腾**，无须等到MaxTenuringThreshold中要求的年龄

- **空间分配担保**
  - 大量的对象在GC后都还是存活的，把Survivor中无法容纳的放到老年代
  - `-XX:HandlePromotionFailure`





```
-Xmx60m -Xms60m -XX:+PrintGCDetails

byte[] buffer = new byte[1024*1024*20];//20m
```



![image-20210321213343955](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321213343955.png)

***↑ 这里直接放入到老年代中——20m大小***











### 为对象分配内存：TLAB

**线程私有的缓冲区**

**为什么有TLAB（Thread Local Allocation Buffer）**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在**并发环境**下从堆区中划分内存空间是**线程不安全**的
- 为避免多个线程操作同一地址，需要使用加锁等级制，进而影响分配速度执行效率



----

**什么是TLAB？**

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为 **每个线程分配了一个私有缓存区域，它包含在Eden空间内**

- 多线程同时分配内存时，使用TLAB**可以避免一系列的线程安全问题** ，同时还能够**提升内存分配的吞吐量**，因此我们可以将这种内存分配方式称之为 **快速分配策略**

- 所有Openjdk衍生出来的JVM都提供了TLAB的设计



![image-20210321213831842](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321213831842.png)



- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
- 可以通过选项  `-XX:UseTLAB`设置是否开启TLAB空间。**默认开启**
  - `jinfo -flag UseTLAB port`
-  默认TLAB占用的空间非常小，**仅占有整个Eden区的1%**，可以通过 `-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden恐案件的百分比大小
- 一旦对象在TLAB空间分配失败时，JVM就会尝试着通过 **使用加锁机制（在Eden区域）** 确保数据操作的原子性，从而**直接在Eden空间中分配内存**



![对象分配过程：TLAB](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321214439882.png)











### 小结堆空间的参数设置



- -XX:+PrintFlagsInitial：查看所有参数的默认值
- -XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）
- -Xms：初始堆空间内存（物理内存的1/64）
- -Xmx：最大堆空间内存（物理内存的1/4）
- -Xmn：设置新生代的大小（初始值以及最大值）
- -XX:NewRatio：设置新生代与老年代在堆结构中的占比
- -XX:SurvivorRatio：新生代中伊甸园区和survivor 0/1区的比例
  - 如果比例很大，经过YGC后，伊甸园区的对象直接进入养老区，幸存者区满了。**Minor GC就没有意义了**
  - 如果比例很小，伊甸园区比较小，YGC出现的频率变高，影响用户进程

- -XX:MaxTrnuringThreshold：设置新生代垃圾的最大年龄
- -XX:+PrintGCDetails：输出详细的GC处理日志
- 打印gc简要信息：-XX:+PrintGC     ;    -verbose:gc
- -XX:HandlePromotionFailure：是否设置空间分配担保



具体查看某个参数的指令:

- jps查看当前运行中的进程  端口
- `jinfo -flag SurvivorRatio port`

----

-XX:HandlePromotionFailure：

在发生Minor GC之前，**虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**

- 若大于，则此次Minor GC是安全的
- 若小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
  - 如果XX:HandlePromotionFailure=true，那么会继续 **检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**
    - 如果大于，则尝试**进行一次Minor GC**，但这次Minor GC**依然是有风险的**
    - 如果小于，则改为进行一次 **Full GC**
  - 如果XX:HandlePromotionFailure=false，则改为进行一次Full GC



jdk7后，这个参数失效了，不会影响空间分配担保策略。

**只要老年代的连续空间大于新生代对象总大小   或者   历次晋升的平均大小 ---->  就会进行Minor GC，否则将进行Full GC**











### 堆是分配对象的唯一选择吗？



new的对象默认是分配在堆空间中吗？

随着JIT编译器的发展与 **逃逸分析技术**逐渐成熟，**栈上分配，标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了



对象是在java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，**那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配**，这样就**无需在堆上分配内存，也无须进行垃圾回收了——>提升性能**。堆外存储技术



TaobaoVM，创新的GC invisible heap技术实现off-heap，将**生命周期较长**的java对象从heap中移至heap外，并且**GC不能管理**GCIH内部的Java对象，以此达到**降低GC的回收频率**和提**升GC的回收效率**的目的



---



**逃逸分析**

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段
- 一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
- 通过逃逸分析，Java HotSpot编译器能够**分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上**
- 逃逸分析的基本行为就是分析对象动态作用域：
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  - 当一个对象在方法中被定义后，被外部方法所引用，则认为发生逃逸。**例如作为调用参数传递到其他地方中**

![image-20210322102227937](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102227937.png)

**栈空间：每个线程一个栈空间，每个方法一个栈帧，栈内变量随着弹出栈而自动销毁了，不存在GC**





![image-20210322102238315](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102238315.png)

**进行返回！另一个方法对它进行了调用！返回引用，发生了逃逸**

返回的不是sb对象的引用，sb还是可以在栈上分配。





![image-20210322102513708](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102513708.png)

![image-20210322102553241](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102553241.png)

![image-20210322102659268](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102659268.png)

![image-20210322102722619](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102722619.png)

这个实体可能是在getInstance()中new的对象，也可能是成员变量obj，从外边传进来的引用，那当然也发生了逃逸。。。**对象从一个方法的栈帧中逃逸到了另一个方法中**



**如何快速判断是否发生了逃逸：就看new的对象是否有可能在方法外被调用**



jdk7后，HotSpot默认开启逃逸分析

-XX:+DoEscapeAnalysis

-XX:+PrintEscapeAnalysis



> **在开发中能使用局部变量的，就不要在方法外定义**



----



**使用逃逸分析，编译器可以对代码进行如下优化**

- **栈上分配**。将堆分配转化为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

- **同步省略**。如果一个对象被发现**只能从一个线程被访问到**，那么对于这个对象的操作可以考虑**不同步**
-  **分离对象或标量替换**。有的对象可能**不需要作为一个连续的内存结构**存在也可以被访问到，那么对象的部分（全部）可以**不存储在内存，而是存储在CPU寄存器（栈空间）**中



具体分析↓

---

栈上分配：

编译期根据逃逸分析的结果优化成分配到栈上，分配完成以后，继续在**调用栈内**执行，最后线程结束，栈空间被回收，局部变量对象也被回收。**无须进行垃圾回收了。**

逃逸出方法的场景：**给成员变量（类变量）赋值、方法返回值、实例引用传递**

栗子：

![image-20210322104244152](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104244152.png)

先不开启逃逸分析，

![image-20210322104335724](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104335724.png)

**内存中存了10000000个对象**



改为“+”,开启逃逸分析：

![image-20210322104427714](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104427714.png)

内存中的个数少了很多。

**并且开启逃逸分析后，不会发生GC——在栈上不会发生GC**







---

同步省略：

- 线程同步的代价很高，降低并发性和性能
- 在动态编译同步块时，JIT借助逃逸分析来 **判断同步块锁使用的锁对象   是否只能够被一个线程访问   而没有被    发布到其他线程**。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步，这样就能大大提高并发性和性能。***同步省略，也叫锁消除***



**使用的锁对象没有发生逃逸**

**多个线程需要使用同一个锁，否则就没有意义了。。。。**

**本身多个线程来操作这个代码也是无效的。。。。每次都new一个新的锁。。。。**

![image-20210322104903562](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104903562.png)



字节码文件中还是有加锁的操作。**运行时去掉这个操作**

![image-20210322105209021](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322105209021.png)



----



分离对象或标量替换



**标量scalar，指一个无法再分解成更小的数据的数据，java总的原始数据类型就是标量**

那些可以分解的数据叫做**聚合量（aggregate）**，**java中的对象就是聚合量**，因为可以分解成其他聚合量和标量

JIT阶段，如果经过逃逸分析，发现一个对象**不会被外界访问**的话，那么经过JIT优化，就会把这个对象**拆解**成若干个其中**包含若干个成员变量**来代替——**标量替换**

![image-20210322105617104](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322105617104.png)



参数：`-XX:+EliminateAllocation`默认是打开的，允许将对象打散分配到栈上



不开启标量替换：

**会进行很多次GC操作**

![image-20210322110929804](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322110929804.png)



开启标量替换：

**花费的时间明显降低，并且没有发生GC——因为都从堆上拆到了栈上**

![image-20210322110956081](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322110956081.png)





----

![image-20210322111136390](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322111136390.png)



**并不是很成熟。。**

![image-20210322111223766](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322111223766.png)

Oracle HotSpot没有开启逃逸分析？？主要还是 **标量替换**



 

小结：

![image-20210322112807672](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322112807672.png)













## 方法区



### 堆、栈、方法区的交互关系



从线程共享与否的角度来看：

![image-20210322152351112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322152351112.png)



整个类的结构（对象**类型数据**...）加载到元空间/方法区，new的对象放在堆空间，引用放在jvm栈中

**到对象类型数据的指针——>哪个类new的，类结构**

![image-20210322152647834](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322152647834.png)









### 方法区的理解



方法区在哪？

尽管所有的方法区**在逻辑上属于堆的一部分**，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap非堆，就是要和堆分开

**所以，方法区看作是一款独立于java堆的空间**



![image-20210322153920078](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322153920078.png)

**堆中存放new的对象，类本身存放在方法区**



---



- 方法区和java堆一样，是**各个线程共享的内存区域**
- 方法区在jvm启动的时候被创建，并且它的实际的物理内存空间中和java堆区一样都**可以是不连续的**
- 方法区的大小，可以选择**固定大小或者可扩展**
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，OOMError：PermGen space   或者OOMError：Metaspace
  - 加载了**大量的第三方的jar包**，Tomcat部署的工程过多->导致方法区溢出；大量动态的生成反射类
- 关闭jvm（一个进程 -- main方法）就会释放这个区域的内存



每次程序运行会加载非常多的类：

![image-20210322154528908](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322154528908.png)



----



方法区的演进：

- jdk7以前，习惯上把方法区称为永久代，jdk8开始，使用元空间取代了永久代
- 本质上，**==方法区和永久代并不等价==**。仅是对HotSpot而言。规范：对如何实现方法区，不作统一要求。例如JRockit中不存在永久代
  - 当年使用永久代，不是好的idea，导致java程序**更容易OOM**（超过XX:MaxPermSize上限）



**元空间使用本地内存，不使用jvm运行时数据区**

![image-20210322154952687](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322154952687.png)



![image-20210322155722533](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322155722533.png)



jdk8，完全废弃了永久代的概念，在本地内存中实现的元空间metaspace来替代



![image-20210322155808112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322155808112.png)

- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代最大的区别在于：***元空间不在虚拟机设置的内存中，而是使用本地内存***
- 内部结构也调整了
- 如果无法满足元空间新的内存分配需求时，将抛出OOM:Metaspace异常













### 设置方法区大小与OOM



方法区的大小不必是固定的，jvm可以根据应用的需要动态调整



jdk7及以前：

- 通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M
- -XX:MaxPermSize来设定永久代最大可分配空间，32位默认是64M，64位机器是82M

- 当JVM加载的类信息容量超过了这个值，会报异常：OOMError:PermGen space

![image-20210322160940371](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322160940371.png)







jdk8中替换成MetasoaceSize

![image-20210322161046663](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322161046663.png)



---

jdk8以后：

- 元数据去大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述两个参数
- 默认值依赖于平台，**-XX:MetaspaceSize是21M**，-XX:MaxMetaspaceSize的值是-1，**即没有限制**
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会好近所有可用系统内存，如果元数据区发生溢出，虚拟机一样会抛出异常OOM:Metaspace

- XX:MetaspaceSize设置初始的元空间大小，默认值21M是初始的高水位线，一旦触及这个水位线，**Full GC将会被触发并卸载没用的类**（即**这些类对应的类加载器不再存活**），然后这个高水位线将会重置。新的高水位线的值**取决于GC后释放了多少元空间**。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值
- 如果初始化的高水位线设置过低，上述高水位线**调整情况会发生很多次**，通过垃圾回收器的日志可以观察到Full GC多次调用，**为了避免频繁的GC，建议将-XX:MetaspaceSize设置为一个相对较高的值**



设置方法：`-XX:(Max)MetaspaceSize=size`

![image-20210322161344221](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322161344221.png)



-----

OOM的栗子

jdk7：

![image-20210322162835244](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322162835244.png)

jdk8：

![image-20210322162719213](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322162719213.png)



**如何解决OOM？**

- 一般是通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了**内存泄漏还是内存溢出**

- 如果是内存泄漏，可进一步通过工具查看泄露对象到GC Roots的引用链，就能找到**泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的**。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置
- 如果不存在内存泄漏，换句话说就是内存中的对象确实都还**必须存活着**，那就应当**检查虚拟机的堆参数-Xms -Xmx与机器物理内存**对比看是否还可以调大，从代码上检查是否存在某些**对象生命周期过长、持有状态时间过长**的情况，尝试**减少程序运行期的内存消耗**













### 方法区的内部结构



![image-20210322163603860](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322163603860.png)



**它用于存储已被虚拟机加载的类型信息、常量、静态变量(移出)、即时编译器编译后的代码缓存等**

![image-20210322164022967](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322164022967.png)



----



**类型信息：**

**可以理解为  就是这个java class的基本属性**

对每个加载的类型（类Class、接口、枚举enum、注解anno），JVM必须在方法区中存储以下类型信息：

1. 这个类型的**完整有效名称**（全名=包名.类名）
2. 这个类型**直接父类**的完整有效名
3. **修饰符** public,abstract,final
4. 这个类型**直接接口**的一个有序列表（继承了哪些接口）



**域Field信息**：

- JVM必须在方法区中保存类型的**所有域的相关信息**以及域的**==声明顺序==**
- 域的相关信息包括：域名称、类型、修饰符(pulic,protected,static,final,volatile,transient....)



**方法Method信息**：

- 方法名称
- 方法的返回类型
- 方法参数的数量和类型
- 方法的修饰符(public,static,final,synchronized,native,abstract...)
- 方法的字节码bytecodes，**操作数栈，局部变量表**及大小
- **异常表**
  - 每个异常处理的开始位置、结束为止、代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引





`javap -v -p`   -p显示权限小的如private。

![image-20210322165122884](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165122884.png)

![image-20210322165352071](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165352071.png)

**加载到方法区的类中记录了是被哪个ClassLoader加载的，在class文件中看不到类加载器，因为还没被加载到运行时数据区**



![image-20210322165605949](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165605949.png)



自动生成的构造方法：

![image-20210322165733096](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165733096.png)



方法的字节码：操作数栈深度、局部变量表大小，参数列表（形参或者this引用），操作指令....

![image-20210322165844638](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165844638.png)



![image-20210322170001315](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170001315.png)

异常表：

![image-20210322170041728](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170041728.png)

如果能执行到指令9：那么跳过异常处理继续执行，否则去target：12处进行异常处理！

![image-20210322170300545](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170300545.png)





**non-ninal的类变量**

- 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分
- 类变量表被类的所有实例共享，即使没有类实例时也可以访问他

**直接通过类名来访问：**

**此时对象的引用为null，不会出现空指针异常，都能访问！**

![image-20210322170508939](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170508939.png)



***全局常量  static final：被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了***



![image-20210322171006775](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322171006775.png)



![image-20210322171032990](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322171032990.png)

 **final值在编译期就写入了它的值**，所以final变量一定要指定值。

**而static需要在类加载器阶段，准备prepare环节给它默认赋零值，初始化时`<clinit>`才会执行赋值操作**   







----



**运行时常量池 vs 常量池**



![image-20210322171547482](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322171547482.png)



- 方法区，内部包含了运行时常量池
- **字节码文件，内部包含了常量池**——>通过类加载器将**类信息**加载到方法区中，字节码文件中的常量池加载到方法区以后——>运行时常量池
- 要弄懂方法区，先理解**ClassFile**，因为**加载类的信息都在方法区**
- 要弄懂方法区的运行时常量池，先理解**ClassFile中的常量池**



ClassFile文件：

![image-20210322172056884](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322172056884.png)



![image-20210322180921563](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322180921563.png)



一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含了一想信息那就是常量池表

包括各种字面量和对类型、域和方法的**符号引用->`system.out.println()`这些都是符号引用，常量池中存储的是他们的名称、描述符等信息**

![image-20210322181041717](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322181041717.png)



---

**为什么需要常量池？**

一个java源文件中的类、接口，编译后产生一个字节码文件。而java中的字节码需要数据支持，通常这种**数据会很大以至于不能直接存到字节码里**，换另一种方式，可以**存到常量池**，这个**字节码包含了指向常量池的引用**。在**动态链接**的时候会用到**运行时常量池**，



![image-20210322181530774](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322181530774.png)

虽然只有194字节，但是里面却使用了String、system、printstream及object等结构，这里代码量其实已经很小了。如果代码多，引用到的结构会更多！又或者重复出现的一些引用，只需要加载一遍。



需要使用某个类的方法，去常量池中寻找**它的引用**即可



几种在常量池内的数据类型包括：

- **数量值**
- **字符串值**
- **类引用**
- **字段引用**
- **方法引用**



例如下面这段代码：

![image-20210322182720815](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322182720815.png)

![image-20210322183055695](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322183055695.png)



**常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型** 





---



**字面量：如直接给sout中传入一个字符串，这就是字面量 `System.out.println("xxxxxxxx");`**

只有在这个int数值足够大（多少忘了....）才会存进常量池中

![image-20210322190335715](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322190335715.png)



![image-20210322190347398](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322190347398.png)





**运行时常量池**



- 运行时常量池是方法区的一部分
- 常量池表示Class文件的一部分，**用于存放编译期生成的各种==字面量和符号引用==，这部分内容将在类加载后存放到方法区的运行时常量池中**
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池
- JVM为***每一个已加载的类型（类/接口）都维护一个常量池***。池中的数据项  像数组项一样，是通过**索引访问**的
- 运行时常量池中包含**多种不同的常量**，包括编译器就已经明确的**数值字面量**，也包括到运行期解析后才能获得的**方法或者字段引用**。此时**不再是常量池中的符号地址了**，这里换为真实地址
  - **运行时常量池，相对于Class文件常量池的领域重要特征是：具备动态性！**
    - String.intern()放入常量池中
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OOM异常









----

常量池存储数据：

**除了保存一些数值、字符串等字面量以外，对于类、方法等都是保存引用——>包名、名称、描述符**

![image-20210322191415641](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322191415641.png)













### 方法区使用实例



![image-20210322195337457](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322195337457.png)



![image-20210322195740207](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322195740207.png)





![image-20210322200620256](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322200620256.png)

**执行的时候，会通过常量池中给出的完整包名、类名、描述符  符号引用，来看方法区中System/...类是否被加载过，没有就加载进来，然后这个符号引用转为真实内存中的System类的直接引用，现在还只是==字符串形式==，用的时候是一个类**

**将符号引用转换为直接引用！！！**



![image-20210322202600751](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322202600751.png)





**调用方法的参数    ——>  从操作数栈中弹出，**

invokevirtual调用方法，如果解析出来的方法不是native的，***所有的参数和this从操作数栈中弹出***。在JVM栈上***为当前准备调用的方法创建一个新的栈帧***。
   * this和所有参数被按照如下顺序***作为新栈帧的局部变量***，**this占slot0**，arg1即55占slot1(如果arg1为long或double类型，则占slot1和slot2)，
        此时本线程的**PC寄存器指向本条语句，即：invokevirtual #3**，
   * 新的栈帧成为当前栈帧，当前线程的PC寄存器压入**即将调用方法的第一条指令的操作码**，程序执行从第一条指令继续进行。
   * 当前println方法执行完成后，栈帧弹出jvm栈，PC寄存器继续执行上一个调用该方法的方法，此时的PC寄存器值为调用方法的下一个指令地址：25

**程序计数器一直在记录当前线程执行到的操作指令的地址，与jvm栈顶的栈帧方法对应。**

![image-20210322202739935](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322202739935.png)

















### 方法区的演进细节



![image-20210323090659984](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323090659984.png)



- 只有HotSpot才有永久代。 

- HotSpot中方法区的变化：

  ![image-20210323090743963](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323090743963.png)



**静态成员变量？**



![image-20210323092804998](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323092804998.png)



永久代为什么要被元空间替代？



- 类的元数据信息被移到了一个与 **堆不相连的本地内存区域，这个区域叫做元空间**
- 元空间的最大可分配空间就是系统可用内粗农建



原因：

1. **为永久代设置空间大小是很难确定的**

   如果动态加载类过多，容易产生Perm区的OOM。在运行过程中，要不断动态加载很多类

   ![image-20210323093736395](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323093736395.png)

2. 对永久代进行调优是很困难的



----

**为什么要把字符串常量池和静态变量移除？**



Stringtable为什么要调整？

jdk7中间StringTable放入到了堆空间中，因为永久代的回收效率很低，在full gc的时候才会出发，而full gc是老年代的空间不足、永久代不足时才会出发。

开发中会有大量的字符串被创建，回收效率低导致永久代内存不足，放到堆中，能及时回收内存。



---



**静态变量放在哪里**

![image-20210323095500129](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323095500129.png)



在1.7中：

![image-20210323095651835](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323095651835.png)

**放在了堆中的老年代中**

1.6中也在老年代中

8：也在老年代中



为什么6.7.8都在堆空间中？

**结论：静态引用的对象本身始终存放在堆中！变量arr这个引用名存放有所变化！**



使用JHSDB工具进行分析



![image-20210323100256047](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323100256047.png)



![image-20210323100355606](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323100355606.png)

**对象的数据都在堆中。但三个引用有不同：**

- **成员变量的引用instanceobj随着对象一起放在堆空间中**
- 局部变量的引用放在方法栈帧的局部变量表中



静态成员变量的引用呢？存放在哪？

在Class实例中，而**所有的实例对象都在堆中**。

![image-20210323100840593](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323100840593.png)

把静态变量与类型与Class对象存放在一起，存储在Java堆中 





















### 方法区的垃圾回收



规范对方法取得约束非常宽松，不要求虚拟机在方法区中实现垃圾收集。

事实行业确实有没实现方法区类型卸载的收集器存在（ZGC收集器不支持类卸载）

**这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。**但是这部分区域的回收有时又确实是必要的。

**方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量  和  不再使用的类型**





- 方法区内常量池之中主要存放的是两大类常量：字面量和符号引用

  字面量：如文本字符串、被声明为final的常量值等。

  符号引用属于编译原理方面的概念：

  - 类和接口的**全限定名**
  - 字段的**名称和描述符**
  - 方法的名称和描述符



- HotSpot虚拟机对常量池的回收策略很明确，**只要常量池中的常量没有被任何地方引用，就可以被回收**

- 回收废弃常量与回收java堆中的对象非常类似



判定一个常量是否“废弃”还是相对简单，而要判断一个类型是否属于“不再被使用的类”的条件就比较苛刻：

![image-20210323102750104](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323102750104.png)

**字节码文件使用类加载器加载进内存中，这时方法区记录了这个类的类加载器**



![image-20210323102833827](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323102833827.png)











### 总结



![image-20210323103333748](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/VU7T3mYBpg4sNiG.png)





![image-20210323104708920](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323104708920.png)



![image-20210323104900210](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323104900210.png)





## 对象的实例化内存布局与访问定位



![image-20210323105226864](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323105226864.png)





### 对象的实例化





![image-20210323105259036](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323105259036.png)



#### 创建对象的方式



- new：
  - 最常见的方式+构造器  
  - 单例模式 xxx的静态方法（构造器不暴露在外）
  - xxxBuilder/Factory 内部静态方法返回对象
- Class的newInstance() 
  - 反射的方式，调用的空参构造器，权限必须是public
- Constructor的newInstance(Xxx)
  - 反射，可以调用无参/带参构造器，权限没有要求
- 使用clone()
  - 不调用任何构造器，当前类需要去实现Cloneable接口，需要实现clone()方法
- 使用反序列化
  - 从文件/网络中获取对象的二进制流，还原为对象
- 第三方库Objenesis





#### 创建对象的步骤



---

从字节码角度来看：

```
Object o = new Object();
```



```
0 new #2 <java/lang/Object>
3 dup
4 invokespecial #1 <java/lang/Object.<init>>
7 astore_1
8 return
```



1. 调用new操作符，判断方法区中是否已经加载Object类，没加载就使用类加载器进行加载。然后在堆空间中开辟空间，零值初始化

2. dup：复制，操作数栈
3. invokespecial #1 **调用Object类中的`<init>`构造器方法**。如果构造器有形参，也需要及时放到操作数栈中（可能也需要初始化，赋值）

如：

```java
class Person{
    public int age;

    public Person(int age) {
        this.age = age;
    }
}

public static void main(String[] args)  {
    int age = 20;
    Person person = new Person(age);
}
```

![image-20210323111159513](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323111159513.png)

iload_1是先将局部变量表中的参数压入操作数栈中，再将其传递给Person的构造器



4. 将这个对Object对象的引用 o 放入局部变量表中



---

**从执行步骤的角度来分析：**

1. 判断对象对应的类是否加载、连接、初始化。加载类元信息

   虚拟机遇到一条new指令，首先去检查这个指令的参数能否在**Metaspace的常量池中定位到一个类的符号引用**，并且检查这个**符号引用代表的类是否已经被加载、解析、初始化**。（即判断类元信息是否存在）。如果没有，那么在**双亲委派模式**下，使用当前类加载器以***ClassLoader+包名+类名为Key进行查找对应的class文件***。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则**进行类加载，并生成对应的Class类对象**。



2. 为对象分配内存

   首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象，**此时该对象占用的堆空间已经可以确定了！**如果实例成员变量是引用变量，**仅分配引用变量空间即可**——>4个字节大小

   - 如果内存规整

     - **指针碰撞**

       Bump The Pointer，所有用过的内存在一遍，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用**带有compact（整理）过程的收集器时，使用指针碰撞**

   - 如果内存不规整

     - 虚拟机需要维护一个列表--**空闲列表**

       已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存

       列表记录了**哪些内存块是可用的**，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并**更新列表上的内容**

   - 说明

     选择哪种分配方式由**Java堆是否规整**决定，而java堆是否规整又由所采用的的**垃圾收集器**是否带有**压缩整理功能**来决定



3. 处理**并发安全问题**
   - 采用CAS失败重试、区域加锁保证更新的原子性
   - 每个线程预先分配一块TLAB——通过-XX:+/-UseTLAB参数来设定



4. **初始化分配到的空间**——所有属性设置**默认值（零值）**，保证对象实例字段在不赋值时可以直接使用，



> 1. 默认初始化--零值
> 2. 显示初始化
> 3. 代码块中初始化
> 4. 构造器初始化



5. 设置对象的**对象头**

   将对象的所属类（类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。**指向方法区/元空间的类元信息**



6. 执行**init方法(构造器)**进行初始化

   java程序的视角看来：初始化才正式开始。初始化成员变量，执行实例化代码块，**调用类的构造方法**，并把**堆内对象的首地址赋值给引用变量**

   new指令之后会接着就是执行方法，把对象按照我们的意愿进行初始化，这样一个真正可用的对象才算完全创建出来

   **显示初始化、代码块中初始化、构造器初始化都是在最后一步中实现的**



```java
class Person{
    public int age = 20;

    public Person(int age) {
        this.age = age;
    }
}
```

![image-20210323130618874](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323130618874.png)

aload_0：从局部变量表中加载this引用，对age进行显式赋值。

iload_1：从局部变量表中获得构造器传入的age参数（调用者的操作数栈age->被调用者的局部变量表），构造函数方法进行赋值



---

new还是构造器才是造对象？

都是！

- new是加载类、开辟空间分配内存、默认零值、对象头

- 构造器来进行属性显式初始化

**二者共同协作创造一个对象实例**







### 对象的内存布局





![image-20210323131629703](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323131629703.png)



**对象头**：

- 运行时元数据

  哈希值：堆中对象首地址——>引用变量

  GC分代年龄（进入老年代）

  锁状态标志

  ...

- **类型指针**

  指向类元数据InstanceClass，元空间中的类型信息，**确定该对象所属的类型**

  `getClass（）`

- 数组也是一个对象，还需要记录**数组的长度**

---

**实例数据**：

- 是对象真正存储的有效信息，包括**程序代码中定义的各种类型的字段**（包括从父类继承下来的和本身拥有的字段）
- **相同宽度**的字段总是被分配在一起
- **父类中定义的变量会出现在子类之前**
- 如果CompactFields参数为true，**子类的窄变量可能插入到父类变量的空隙**



---

对齐填充padding：起到**占位符**的作用



![image-20210323132520448](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323132520448.png)







### 小结图示



从new一个Customer类的实例cust开始：

主线程的   jvm栈的   main()方法栈帧的   局部变量表：0:args; 1:cust

cust指向堆空间中的实例信息：1.对象头（运行时元数据+类型指针）2.实例数据 3.对齐填充

实例数据如：acct实例、name值都存在堆空间中，将地址传给引用

类型指针指向   元空间/方法区中的类元信息——>类型信息

![image-20210323132532977](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323132532977.png)









### 对象的访问定位



![image-20210323134854452](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323134854452.png)



**java虚拟机是如何通过栈帧中的局部变量 -> 对象引用访问到其内部的对象实例的呢？**

![image-20210323134902194](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323134902194.png)



1. 创建对象的目的就是为了使用它

2. jvm如何通过栈帧中的对象引用访问到其内部的对象实例的呢？

   **定位，通过栈上reference访问**

3. 对象访问方式主要有两种：

   1. 句柄访问

      ![image-20210323135225631](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323135225631.png)

    **对象的句柄  由两部分组成：对象实例数据  &  对象类型数据**

   

   实现：

   

   优缺点：效率低，需要专门开辟空间保存句柄。reference中存储稳定句柄地址，对象被移动时（**垃圾收集时移动对象很普遍**）只会**改变句柄中实例数据指针**即可，**reference本身不需要被修改**

   

   

   2. 直接指针(HotSpot采用)

   ![image-20210323135245740](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323135245740.png)

   **对象实例数据中包含了到对象类型数据的指针，指向方法区中的对象类型数据**

   

​	优缺点：效率高，不需要专门开辟空间记录句柄。在垃圾回收改变实例地址后需要对栈中的	引用地址进行修改。



















































































































# Tip



## aload_n的解释



<n>必须是当前帧的**局部变量数组的索引**（第2.6节）。 <n>处的局部变量必须包含**一个引用**。 <n>处的局部变量中的objectref被压入操作数堆栈。



![image-20210321132146922](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132146922.png)



string栈帧的局部变量表：

![image-20210321132201032](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132201032.png)

**这里加载局部变量表中索引为0位置的引用：即this，将this加载到操作数堆栈中，再对这个this方法调用本地的虚方法，将方法的返回值x存储到局部变量表中**



main栈帧的局部变量表：

![image-20210321132717373](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132717373.png)

![image-20210321132305846](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132305846.png)

**如果是static方法，那么就不需要通过this引用实例  来进行调用，直接调用常量池中的引用即可。再将返回值引用保存到局部变量表中**

但接下来调用string()方法，就需要使用到局部变量表中索引为1的实例，aload_1将其加载进操作数栈，然后调用-保存。











## int在运行时常量池



```java
System.out.println(32767);
```

对应的字节码指令：`sipush 32767`

**并且还发现，这个字面量并没有存在常量池中？怎么回事呢？**



> ldc: 将int, float或String型常量值从常量池中推送至栈顶。
>
> ldc_w: 将int, float或String型常量值从常量池中推送至栈顶（宽索引）
>
> ldc2_w: 将long或double型常量值从常量池中推送至栈顶（宽索引）
>
> 这三个指令是属于ldc系列的指令，该系列的指令负责将**数值常量或String常量值从常量池中推送到栈顶**。该命令后面需要给一个表示常量在常量池中位置(编号)的参数。



bipush 将单字节的常量值(-128~127)推送至栈顶
sipush 将一个短整型常量值(-32768~32767)推送至栈顶
该系列命令**负责把一个整形数字（长度比较小）送到到栈顶**。该系列命令**有一个参数，用于指定要送到栈顶的数字。**
注意该系列命令只能操作**一定范围**内的整形数值，**超出该范围的使用将使用ldc命令系列。**

***原来JVM字节码的指令是可以存储一定范围的值的，不需要将该范围内的值放置到常量池当中，然后搞个索引指向常量池中。***



这样，Integer值就存在了常量池中！从常量池中获取引用。**如果太小的int值，就直接赋值了，无需使用引用从常量池中获取**

` ldc #9 <32768>`

![image-20210322191312638](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322191312638.png)











## 符号引用



解析阶段会有一个步将常量池当中二进制数据当中的符号引用转化为直接引用的过程



符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能**无歧义地定位到目标**即可，符号引用和虚拟机的布局无关。

个人理解为：在编译的时候一个**每个java类都会被编译成一个class文件**，但在编译的时候虚拟机**并不知道所引用类的地址**，多以就用**符号引用来代替**，而在这个解析阶段就是为了把这个***符号引用转化成为真正的地址***  的阶段。



**比如，将PrintStream类加载进内存中，符号引用转为直接引用来调用后，执行其方法println()，将其加载进当前线程的栈帧进行执行.....**



如果有了直接引用，那么直接引用的目标一定被加载到了内存中。

直接引用可以是： 

1：直接指向目标的指针。（个人理解为：指向对象，类变量和类方法的**指针，就是直接指向内存地址**）

2：相对偏移量。    （指向实例的变量，方法的指针）

3：一个间接定位到对象的句柄。









## String



在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。
常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。
直接使用双引号声明出来的String对象会直接存储在常量池中。
比如： String info = “abc” ；
如果不是用双引号声明的String对象，可以使用String提供的intern()方法。

```java
/**
     * intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找等值的对象，
     * 如果没有找到则在常量池中开辟一片空间存放字符串并返回该对应String的引用，否则直接返回常量池中已存在String对象的引用。
     * @return
     */
    public native String intern();

```





- 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。





```java
class Memory {
    public static void main(String[] args) {
        int i = 1;
        Object obj = new Object();
        Memory mem = new Memory();
        mem.foo(obj);
    }

    private void foo(Object param) {
        String str = param.toString();
        System.out.println(str);
    }
}
```

![image-20210323103736505](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323103736505.png)





如果不是用双引号声明的String对象，可以使用String提供的intern方法： intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。



---



如何保证**变量s指向的是字符串常量池中的数据**呢？
 * 有两种方式：
 * 方式一： String s = "shkstart";//字面量定义的方式
 * 方式二： 调用intern()
    *         String s = new String("shkstart").intern();
    *         String s = new StringBuilder("shkstart").toString().intern();


![image-20210323104000539](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323104000539.png)



![image-20210323104017146](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323104017146.png)





总结String的intern（）的使用:

jdk1.6中，将这个字符串对象尝试放入串池。

​	➢如果字符串常量池中有，则并不会放入。**返回已有的串池中的对象的地址**
​	➢如果没有，会把此**对象复制一份，放入串池**，**并返回**串池中的对象地址



Jdk1.7起，将这个字符串对象尝试放入串池。

​	➢如果字符串常量池中有，则并不会放入。返回已有的串池中的对象的地址
​	➢如果没有，则会把对象的**引用地址**复制一份，放入串池，并返回**串池中的引用地址**





