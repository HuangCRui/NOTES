JVM学习路线：

![image-20210321154529797](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321154529797.png)



# 内存与垃圾回收







# JVM和Java体系结构







![image-20210319184628767](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319184628767.png)

始终是在软件层面进行操作。需要去了解底层

**内功修炼！**



高级语言->汇编语言->机器指令->CPU



![image-20210319190029581](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319190029581.png)

垃圾回收机制，大大提高了开发效率，但也不是万能的，懂得JVM内部的**内存结构，工作机制**，是设计高扩展性应用和诊断运行时问题的基础。



## Java及JVM简介



跨平台的语言：

![image-20210319192535044](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319192535044.png)





JVM：跨语言的平台。只要他们的编译器编译出的字节码文件符合规范，那么就可以被java虚拟机解释运行。**它只关心字节码文件**。

![image-20210319192731453](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319192731453.png)



字节码->**jvm字节码**

多语言混合编程，他们最终都运行在一个虚拟机之上。





## 虚拟机与java虚拟机



系统虚拟机和程序虚拟机。

系统虚拟机完全是对物理计算机的仿真，提供可运行完整操作系统的软件平台。

程序虚拟机，如java虚拟机，专门为执行单个计算机程序而设计。

Java虚拟机：执行**java字节码**的虚拟计算机，**跨平台+优秀的垃圾回收器+可靠的即时编译器**



作用：java虚拟机就是**二进制字节码的运行环境**。

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能





**JVM的位置**：





![image-20210319183620188](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319183620188.png)

JVM是运行在操作系统之上的，**与硬件没有直接的交互**



javac：前端编译器。

![image-20210319183811985](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319183811985.png)







## JVM的整体结构



HotSpot VM是目前市面上高性能虚拟机的代表作之一

采用**解释器与即时编译器**并存的架构

- 字节码文件输入->类加载器->生成class对象

- 共享方法区和堆

- 每个线程独享程序计数器，本地方法栈和虚拟机栈
- 执行引擎：高级语言->机器语言

![image-20210319200058541](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200058541.png)



**更详细的图：**

![image-20210319200616290](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200616290.png)



![image-20210319200630907](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200630907.png)







## Java代码执行流程



![image-20210319201439951](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319201439951.png)





## JVM架构模型



基于栈的指令集架构，基于寄存器的指令集架构



==hotspot是基于栈的指令集架构==

- 设计和实现更简单
- 避开了寄存器的分配难题，使用**零地址指令方式分配**
- 执行过程依赖于操作栈，指令集更小，编译器更容易实现
- 不需要硬件支持，可移植性更好，更好实现跨平台



基于寄存器架构：

- x86的二进制指令集
- **完全依赖硬件**，性能优秀，可移植性较差
- 花费更少的指令去完成一项操作
- 一地址指令、二地址指令、三地址指令







- 一地址指令：地址+操作数的个数

- 零地址指令：没有地址，只有操作数 



![image-20210319202114141](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319202114141.png)



```
int i = 2 + 3;
```

```
javap -v StackStruTest.class 反编译
```

![image-20210319203345499](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319203345499.png)



```
int i = 2;
int j = 3;
int k = i + j;
```

![image-20210319203550140](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319203550140.png)



总结：

**由于跨平台性的设计，java的指令都是根据栈来设计的**



栈：

- 跨平台性
- 指令集小
- 指令多
- 执行性能比寄存器差一点





## JVM的生命周期



- **虚拟机的启动**

Java虚拟机的启动是通过**引导类加载器**bootstrap class loader创建一个初始类initial class来完成的，这个类是由虚拟机的具体事先指定的

自定义的类通过系统类加载器加载

Object被引导类加载器加载

需要先加载父类，发现没有，启动虚拟机

- **虚拟机的执行**

一个运行中的Java虚拟机有着一个清晰的任务：执行java程序

程序开始执行时他才运行，程序结束时他就停止

**执行一个所谓的java程序的时候，在执行的是一个叫做java虚拟机的进程**

![image-20210319205159316](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319205159316.png)



- **虚拟机的退出**

程序正常执行结束

执行过程中遇到一场或错误而异常终止

操作系统错误

**Runtime(运行时环境)**或System的exit方法，Runtime的halt方法，并且java安全管理器也允许这次exit或halt操作

Java Native Interface也可以来加载或卸载java虚拟机





## JVM发展历程



- Sun Classic VM

  只提供了解释器，逐行解释字节码。。。效率较低。如果为了执行效率使用 JIT 编译器，就需要进行外挂，但是一旦使用JIT编译器，就会接管虚拟机的执行系统，解释器就不再工作。解释器和编译器也**不能配合工作**

  只使用JIT，**暂停时间**较长。二者应该**搭配使用**效率才高。

  hotspot内置了此虚拟机

- Exact VM

  准确是内存管理，可以知道内存中某个位置的数据具体是什么类型

  编译器与解释器混合工作模式

  热点探测



- HotSpot VM

oracle/Open  jdk的默认虚拟机。

**hotspot：热点代码探测技术**：

​	通过计数器找到最具编译价值代码，触发即时编译（缓存起来）或栈上替换

​	通过编译器与解释器**==协同工作==**，在最优化的**==程序响应时间与最佳执行性能==**中取得平衡



- JRockit

  专注于服务器端应用

  - 不太关注程序启动速度，因此内部不包含解析器实现，都靠即时编译器编译后执行

  是世界上**最快的JVM**

  优势：

  - 提供毫秒、微妙级的JVM响应时间
  - MissionControl服务套件，监控、管理和分析生产环境中的应用程序

- IBM 的 J9

  市场定位与HotSpot接近。有影响力的三大商用虚拟机之一，号称世界上最快的jvm....



- KVM和CDC/CLDC HotSpot

  移动领域

  一次编译，到处运行

- Azul VM

  与特定硬件平台绑定，软硬件配合的专有虚拟机。

- Liquid VM

  BEA公司，运行在自家的系统上。

  不需要操作系统的支持，自己本身实现了一个专用操作系统的必要功能：线程调度、文件系统、网络支持等。

- Apache Harmony 

  它的Java类库代码吸纳进了Android SDK

- Microsoft JVM

- Taobao JVM

  基于Openjdk HotSpot深度定制且开源的高性能服务器版Java虚拟机

  降低垃圾回收的频率

  在淘宝、天猫上线，替换了Oracle JVM

- Dalvik VM

  谷歌开发。应用于Android系统。不是Java虚拟机，没有遵循Java虚拟机规范。

  不能执行Java 的Class文件

- Graal VM

  跨语言全栈虚拟机，作为任何语言的运行平台使用：Java,Scala,C,C++,JS,Python.....

  支持不同语言中混用对方的接口和对象





# 类加载子系统



## 内存结构概述





![image-20210320094037787](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320094037787.png)



使用类加载子系统将class字节码文件加载到内存中，生成大的class对象，初始化静态属性...



- 加载阶段：引导/扩展/系统  类加载器
- 链接阶段：验证、准备、解析
- 初始化阶段

![image-20210320094311385](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320094311385.png)



如果自己手写一个java虚拟机，需要考虑类加载器和执行引擎。







## 类加载器与类的加载过程



![image-20210320095232496](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320095232496.png)

- 类加载器子系统负责从文件系统或者网络中加载Class文件，ckass文件在文件开头有特定的文件标识
- `ClassLoader`只负责**class文件的加载**，至于它是否可以运行，则**由Execution Engine执行引擎来决定**
- 加载的**类信息**存放于一块称为**==方法区==**的**内存空间**。除了类的信息外，方法区中还会存放**运行时常量池信息**，可能还包括**字符串字面量和数字常量**（**==这部分常量信息是Class文件中常量池部分的内存映射==**）







![image-20210320095640068](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320095640068.png)

- class file 存在于本地硬盘上，根据这个文件**实例化**出n个一模一样的实例。
- class file 加载到JVM中，被称为DNA***元数据模板***，放在方法区

- Car Class调用 `getClassLoader`获取类加载器
- 通过具体的类实例对象还可以 `getClass()`获取到是哪个Class创建的对象

- 在.class文件 ->JVM -> 最终成为**==元数据模板==**，此过程就要一个   运输工具：类装载器Class Loader，扮演一个快递员的角色



类的加载过程：

![image-20210320100106181](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320100106181.png)



### 类的加载过程

---

**加载：Loading**

- 通过一个类的全限定名获取定义此类的**二进制字节流**（网络、本地、jar/war压缩包、动态代练、jsp）
- *将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构***
- **在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种**数据的访问入口



---

**链接**

验证Verify：

- 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证加载类的正确运行，不会危害虚拟机自身安全。"CAFEBABE"
- 文件格式验证、元数据验证、字节码验证、符号引用验证



准备Prepare：

- 为类变量**「分配内存」**并且设置该类变量的默认初始值：**==零值==**
- ***这里不包含用 final修饰的 static，因为final在编译的时候就会分配了——>保存在class文件中的常量池，准备prepare阶段会显式初始化***
- **这里不会为实例变量分配初始化**，**==类变量会分配在方法区==**中，而**==实例变量是会随着对象一起分配到Java堆中==**



![image-20210320101330889](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320101330889.png)



解析Resolve：

- 将常量池中的***符号引用转换为直接引用***

![image-20210320102524219](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320102524219.png)

- **符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在Class文件格式中，直接引用就是直接指向目标的指针、相对偏移量**
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等，本来只是一堆字符串名字，将他们指向真正的引用



---



> 类/静态变量属于类，就像实例变量一样，它们是在类内在任何方法之外声明的，但是使用static关键字声明。不使用static声明的是实例变量。
>
> 它们可以在编译时访问，您可以在实例化之前/不实例化类时进行访问，整个类中只有一个静态字段的副本可用，即，静态字段的值在所有对象中都相同。您可以使用static关键字定义一个静态字段。
>
> 如果您在类中声明了静态变量，则尚未初始化它，就像使用实例变量一样，编译器将使用默认构造函数中的默认值对其进行初始化。



**初始化**

- 就是执行类构造器方法`<clinit>()`的过程

- javac编译器自动收集类中的所有**类变量（static）的赋值动作和静态代码块（static）**中的语句合并而来

  ```java
  private static int num = 1;
  static{
  	num = 2;
  }
  ```

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103016926.png" alt="image-20210320103016926" style="zoom:150%;" />

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103120733.png" alt="image-20210320103120733" style="zoom:150%;" />

  **一开始赋值为1，后来又赋值为2，会把显示初始化和静态代码快的初始化合并在一起**

- 构造器方法中指令按语句在**源文件中出现的顺序**执行 ↑

  ```java
  static{
  	num = 2;
  	number = 20;
  }
  private static int number = 10;//在linking阶段，prepare环境，将number赋值为0，在initialization阶段，重新覆盖，按照---顺序---  先20  后被覆盖为10
  ```

   <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103434246.png" alt="image-20210320103434246" style="zoom:150%;" />

  ![image-20210320103545588](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103545588.png)

  **报错：非法的前向引用↑。声明的对象在后面，可以赋值但不可以调用**

- `<clinit>()`不同于类的构造器（关联：构造器是虚拟机视角下的`<init>()`）

  ==**如果类中没有静态代码块或者静态变量，那么不存在`<clinit>()`类构造器方法**== 

- <`init`>是类构造器函数

  **任何类声明以后，内部至少存在一个类的构造器（系统默认提供 -> 默认父类Object构造器）**

- 若该类具有父类，JVM会在子类的clinit执行前，父类的clinit已经执行完毕

  **首先会加载father类，其次加载son类  B=2**

  ![image-20210320105010950](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105010950.png)

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105346224.png" alt="image-20210320105346224" style="zoom:150%;" />

- 虚拟机必须保证一个类的 `<clinit>()`方法在多线程下被**同步加锁**。**一个类只需要加载一次就可以，加载到内存中，以后都是使用的内存中的类本身。**

  如果是多线程情况下，

  ![image-20210320105544125](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105544125.png)

  while循环，不让这个类加载完成

  ![image-20210320105628138](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105628138.png)

  两个线程都需要初始化DeadThread类：

  ![image-20210320105824928](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105824928.png)

​	**只有一个类可以进到 `<clinit>()`方法来初始化这个类**，说明  实现了**同步加锁**







## 类加载器的分类



- 引导类加载器 Bootstrap

   C和C++编写

- 自定义类加载器 User-Defined

   将所有继承自抽象类ClassLoader的类加载器都划分为自定义类加载器



![image-20210320110405264](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110405264.png)

不是继承关系，等级关系。**ExtClassLoader是AppClassLoader的父加载器**，而不是父类

```java
public static void main(String[] args) {
    //获取系统类加载器
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
    
    //获取其上层：扩展类加载器
    ClassLoader extClassLoader = systemClassLoader.getParent();
    System.out.println("extClassLoader = " + extClassLoader);
    //extClassLoader = sun.misc.Launcher$ExtClassLoader@1b6d3586
    
    //试图继续获取上层，获取不到引导类加载器
    ClassLoader parent = extClassLoader.getParent();
    System.out.println(parent);//null
    
    System.out.println("用户自定义类的类加载器：" + ClassLoaderTest.class.getClassLoader());
    //用户自定义类的类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2
    //和上面AppClassLoader是一个对象，使用系统类加载器进行加载
}
```

`String.class.getClassLoader`：null，获取不到类加载器。**证明了String类使用引导类加载器进行加载的。——>java的核心类库都是使用引导类加载器**

**Bootstrap Class Loader没法获取到，非常高端....只加载核心类库，c和c++编写，拿不到对象**

![image-20210320110437650](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110437650.png)



**ExtClassLoader是AppClassLoader的父加载器**：

```java
private ClassLoader(Void unused, ClassLoader parent) {
    this.parent = parent;
```

**在构造AppClassLoader时传入了ExtClassLoader对象，在ClassLoader类中将其设置为AppClassLoader的parent，==其实就是一个属性值，并不是继承关系==，二者都继承自URLClassLoader**

```java
Launcher.ExtClassLoader var1;
try {
    var1 = Launcher.ExtClassLoader.getExtClassLoader();
} catch (IOException var10) {
    throw new InternalError("Could not create extension class loader", var10);
}

try {
    this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
} catch (IOException var9) {
    throw new InternalError("Could not create application class loader", var9);
}

```







### 虚拟机自带的类加载器：



**启动类加载器（引导类加载器 Bootstrap ClassLoader）**

- 使用C/C++语言实现，嵌套在JVM内部
- 用来接下载Java核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar），用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader，没有父加载器
- 启动类加载器  **加载扩展类和应用程序类加载器**，并指定他们的父类加载器
- Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类





**扩展类加载器（Extention ClassLoader）**

- **==Java语言编写==**，sun.misc.Luncher.ExtClassLoader
- 派生于ClassLoader类
- 父加载器为启动类加载器
- java.ext.dirs，jre/lib/ext子目录下加载类库。**如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载**



**应用程序类加载器（系统类加载器，AppClassLoader）**

- **==Java语言编写==**，sun.misc.Luncher.AppClassLoader
- 派生于ClassLoader类
- 父加载器为扩展类加载器
- 复杂加载环境变量**==classpath==**或系统属性  java.class.path指定路径下的类库
- **该类加载器是程序中默认的类加载器**，一般来说，Java应用都是由它来完成加载
- 通过`getSystemClassLoader()`方法来获取



![image-20210320113959039](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320113959039.png)

  ![image-20210320114013328](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114013328.png)

其中String也是在rt.jar下

```
sout:Provider.class.getClassLoader()  //null 表明他的加载器是引导类加载器
```



![image-20210320114545334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114545334.png)

 ![image-20210320114357922](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114357922.png)

```
sout:CurveDB.class.getClassLoader() //ExtClassLoader
```







### 用户自定义类加载器



为什么要自定义类加载器：

- 隔离加载类，隔离中间件和应用的jar包

- 修改类加载的方式
- 扩展加载源，扩展数据库....字节码的来源
- 防止源码泄露，加密解密



实现步骤：

1. 通过集成抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，满足一些特殊的需求
2. 1.2之后，不建议覆盖loadClass()方法，写在findClass()中
3. 如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作
4. 可以直接继承URLClassLoader类，避免编写**findClass()**和**获取字节码流**的方式，







## 关于ClassLoader

是一个**抽象类**，其后所有的类加载器都继承自ClassLoader，**不包括启动类加载器**

 

![image-20210320130632001](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320130632001.png)





![image-20210320110437650](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110437650.png)



获取ClassLoader的途径：

![image-20210320130821877](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320130821877.png)







## 双亲委派机制



Java虚拟机对class文件才用的是 **按需加载**的方式，当需要使用该类是才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机才用的是 **==双亲委派模式==**，即**把请求交由父类处理，它是一种任务委派模式**







例：

```java
package java.lang;

public class String {
    //初始化阶段 clinit
    static {
        System.out.println("我是自定义的String类！");
    }
}
```

```java
public class StringTest {
    public static void main(String[] args) {
        java.lang.String str = new java.lang.String();//不是自定义的String，用的还是核心api中的String类
        System.out.println("hello");
        System.out.println(str.getClass().getClassLoader());//null 使用的是启动类加载器
    }
}
```



**工作原理**：

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委**托给父类的加载器**去执行，使用AppClassLoader的parent：ExtClassLoader

2. 如果父类加载器化存在其父类加载器，则**进一步向上委托**，依次递归，**==请求最终将到达顶层的启动类加载器==**

3. 如果**父类加载器可以完成类加载任务**，就成功返回，倘若父类加载器无法完成此加载任务，**子加载器才会尝试自己去加载**，**这就是双亲委派模式**

   **（启动类加载器只加载包名为java,javax,sun开头的类）**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320132335504.png" alt="image-20210320132335504" style="zoom:150%;" />



若此时在java.lang.String中写一个main方法

![image-20210320133952868](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320133952868.png)

**最终加载的是核心包中String类，但这里面并没有main方法。完全不会加载自定义的String类**



---

栗子：



![image-20210320134115501](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320134115501.png)

接口是核心类，接口的实现类是第三方jar包



优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被随意修改
  - 自定义类java.lang.String 

找到引导类加载器，发现是java开头包名，加载这个类，直接报错

![image-20210320134613853](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320134613853.png)





---

 **沙箱安全机制**：

自定义String类，但是在加载自定义String的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程会先加载jdk自带的文件（rt.jar中java/lang/String.class），报错说没有main方法。这样可以**保证对java核心源代码的保护**，**这就是沙箱安全机制**





## 其他



JVM中表示两个class对象是否为同一个类存在两个必要条件：

- 类的完整类名必须一致，包括包名
- 加载这个类的ClassLoader（ClassLoader实例对象）必须相同



在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也不同





---

**类加载器的引用**

如果一个类型是由用户类加载器加载的，**那么JVM会将这个==类加载器的一个引用作为类型信息==的一部分保存在==方法区==中**，当解析一个类型到另一个类型的引用时，JVM需要保证这两个类型的类加载器是相同的。





---

类的主动使用和被动使用



主动使用：

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（Class.forName()）
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- 动态语言支持invoke.MethodHandle....



**其他都是对类的被动使用，都不会导致类的初始化**







# 运行时数据区



## 运行时数据区内部结构

 执行引擎执行的过程中也都**用到了运行时数据区**

![image-20210320142938272](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320142938272.png)



 内存是非常重要的系统资源，承载操作系统和应用程序的实时运行。JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。

**不同的JVM对于内存的划分方式和管理机制存在着部分差异。**



![image-20210320143430824](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143430824.png)

![image-20210320143505089](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143505089.png)





![image-20210320143518524](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143518524.png)



Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁



![image-20210320144015179](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320144015179.png)

> **灰色为单独线程私有的：程序计数器、本地方法栈、虚拟机栈**
>
> **红色为多个线程共享的，堆heap、堆外内存（元空间/方法区、代码缓存）**





![image-20210320144608624](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320144608624.png)

**每个JVM只有一个Runtime实例，即运行时数据区，内存结构中的运行时环境**





## 线程



JVM允许一个应用有**多个线程并行执行**

在HotSpot JVM里，**==每个线程都与操作系统的本地线程直接映射==**。

- **当一个Java线程准备好执行以后**，此时一个**操作系统的本地线程也同时创建**，java线程执行终止后，本地线程也会回收

操作系统负责所有线程的安排调度到一个可用的CPU上。一旦本地线程初始化成功，就会**调用java线程中的`run()`方法**



后台系统线程（HotSpot JVM）

- 虚拟机线程，JVM达到安全点才会出现，stop-the-world
- 周期任务线程
- GC线程，垃圾回收
- 编译线程，字节码编译成本地代码
- 信号调度线程







## 程序计数器（PC寄存器）



### PC Register介绍



![image-20210320145806983](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320145806983.png)



Program Counter Register程序计数寄存器。

这里并非是广义上所指的物理寄存器，JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟



**作用：**

**PC寄存器用来存储指向下一条指令的地址，就是即将要执行的指令代码。由执行引擎读取下一条指令**



![image-20210320150032281](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320150032281.png)



- 是一块**很小的内存空间**，非常小，运行速度最快！

- 每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

- 任何时间一个线程都只有一个方法在执行，**当前方法**。程序计数器会存储**==当前线程正在执行的Java方法的JVM指令地址==**；或者如果是在执行native方法，则是未指定值（undefined）

- 是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取**下一条需要执行的字节码指令**
- 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域



**==GC和OOM都不会发生在程序计数器中==**

 





### 栗子



```java
public class PCRegister {
    public static void main(String[] args) {
        int i = 10;
        int j  = 20;
        int k = i + j;
    }
}
```

第一列就是**==指令地址/在字节码文件中的偏移地址==**

第二列是**==操作指令==**

```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 return
```





```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 ldc #2 <abc>  常量池中取常量  两个操作
12 astore 4
14 getstatic #3 <java/lang/System.out>  也在常量池中
17 iload_1
18 invokevirtual #4 <java/io/PrintStream.println>
21 getstatic #3 <java/lang/System.out>
24 iload_3
25 invokevirtual #4 <java/io/PrintStream.println>
28 return
```

常量池：

![image-20210320151518571](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320151518571.png)







![image-20210320152113344](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320152113344.png)

地址5存储的是 istore_2操作指令，执行引擎通过PC寄存器找到下一个需要执行的指令的地址：**5**，再去局部变量表LV、操作数栈OS**使用这个地址**获取**操作指令**，编译成机器指令进行操作.....



### 两个常见问题



**使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**



因为CPU需要**不停地切换**各个线程，这时候**切换回来**以后，就得知道接着**从哪开始继续执行**

JVM的**字节码解释器**就需要通过**改变PC寄存器的值**来明确**下一条应该执行什么样的字节码指令**

![image-20210320153646579](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320153646579.png)





---



**PC寄存器为什么会被设定为线程私有**

肯定不能共用啊！不能让多个线程共用PC寄存器

多线程在一个特定的时间段内只会执行其中某一个线程的方法，Cpu会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？***为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。***



> CPU时间片限制，中多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器的一个内核，只会执行某个线程的一条指令

![image-20210320154234725](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320154234725.png)



> CPU时间片：
>
> CPU分配给各个程序的时间，每个线程被分配一个时间段-时间片。每个程序轮流执行
>
> 并行：(和串行相反)，同时在执行，一个时间点切面上多个程序在执行
>
> 并发：一个核快速切换，（伪并行）。



---



方法A调用方法B的时候，PC寄存器会跟着移动到B方法去。当B执行完后，要能返回A继续执行，就需要A当时执行到的那条指令的地址。所以，在B的栈帧中保存A当时的指令地址(当时PC寄存器的值)，当B执行完后，根据此返回地址跳回A。

**没有PC寄存器，执行器也会按照指令的顺序一条条正常执行**。PC寄存器的作用在于**多线程切换**的时候，能找到每个线程执行的位置，所以它是线程私有的。



当执行native方法时，原生的CPU上的对应的线程接管。若此时线程切换是原生CPU的PC寄存器管理，能确保native方法执行完。

当native方法执行完后，会出栈(栈帧pop)，返回到被调用的地方继续执行程序。









## 虚拟机栈

Java Virtual Machine Stack



### 虚拟机栈概述



由于跨平台性的设计，Java的指令根据栈来设计。

**优点是跨平台，指令小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令**



内存只有堆栈？？？？



**栈是运行时的单位，而堆是存储的单位**

> 栈解决程序的**运行问题**，即程序如何执行，或者说如何处理数据
>
> 栈中存放变量...对变量执行指令...都是栈来做的   局部变量表、操作数栈
>
> 
>
> 堆解决的是**数据存储**的问题，即数据怎么放、放在哪儿



  **Java虚拟机栈是什么？**

每个线程在创建时都会创建一个**==虚拟机栈==**，内部保存一个个的**栈帧Stack Frame**，对应着一次次的***Java方法调用***，且是线程私有的

![image-20210320162739765](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320162739765.png)

栈顶B：当前方法。出栈，A变成当前方法



**生命周期**

​	和线程一致

**作用：**

​	主管Java程序的运行，**保存方法的局部变量（8种基本数据类型、对象的==引用地址==(对象本身存放在==堆空间==)）、部分结果，并参与方法的调用和返回**

​	局部变量 vs 成员变量/属性

​	基本数据变量 vs 引用类型变量





---

栈的特点（优点）

- 栈是一种快速有效的分配存储方式，**访问速度**仅次于程序计数器

- JVM直接对Java栈的操作只有两个：

  - 每个***方法执行***，伴随着**进栈**（入栈、压栈）
  - 执行结束后的**出栈工作**

- 对于栈来说**不存在垃圾回收问题**

  栈不存在GC，存在OOM，会溢出





### 面试题：开发中遇到的异常有哪些



**栈中可能出现的异常**

- Java虚拟机规范允许**==*Java栈的大小是动态的或者是固定不变的*==**
  - 如果采用**固定大小的java虚拟机栈**，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果**线程请求分配的栈容量**超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个`StackOverflowError`异常
  - 如果Java虚拟机栈可以**动态扩展**，并且尝试扩展的时候**无法申请到足够的内存**，或者在创建新的线程时**没有足够的内存区**创建对应的虚拟机栈，那Java虚拟机将会抛出一个 `OutOfMemoryError`异常

```java
public static void main(String[] args) {
    main(args);
}
```

![image-20210320164505903](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320164505903.png)



- **设置栈内存大小**

  是用参数-Xss选项来设置爱线程的最大栈空间，栈的大小直接决定了函数调用的最大深度

![image-20210320164914785](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320164914785.png)



```java
private static int count = 1;
public static void main(String[] args) {
    System.out.println(count++);//默认count=9830
    main(args);
}
```

![image-20210320165200489](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320165200489.png)

修改虚拟机栈的大小：count=2263，设置的栈的大小起作用了

**栈的大小直接决定了函数调用的最大深度！**





### 栈的存储单位



**栈中存储什么？**

- 每个线程都有自己的栈，栈中的数据都是以**栈帧Stack Frame**的格式存在
- 这个线程上正在执行的**每个方法都各自对应一个栈帧**，**==方法和栈帧一一对应==**
- 栈帧就是一个**内存区块**，是一个**数据集**，维系着方法**执行过程中**的各种数据信息

> 类，对象
>
> field（属性、字段、域），method（方法）

- JVM直接对Java栈的操作只有两个，就是对栈帧的 **压栈 & 出栈**，FIFO原则
- 在**一条活动线程**中，一个时间点上，只会有**一个活动的栈帧**。即当前在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为 **当前栈帧Current Frame**，与当前栈帧对应的是当前方法Current Method，定义这个方法的类就是 **当前类Current Class**
- 执行引擎运行的所有字节码指令**只针对当前栈帧进行操作**

- 如果在该方法中**调用了其他方法**，对应的新的栈帧就会被其创建出来，放在栈的顶端，成为新的栈帧

![image-20210320170059505](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320170059505.png)

> Debug左侧显示的Frames就是栈帧结构显示
>
> ![image-20210320170834142](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320170834142.png)





- 不同线程中所包含的栈帧是**不允许存在相互引用**的，即不可能在一个栈帧之中引用**另一个线程**的栈帧，**相互隔离！**
- 如果当前方法调用了其他方法，方法返回之际，**==当前栈帧会传回此方法的执行结果给前一个栈帧==**，接着，虚拟机会**丢弃**当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式，
  - **一种是正常的函数返回，使用return指令**
  - **另一种是抛出异常Throw Exception(不是try-catch)，不管使用哪种方式，都会导致栈帧被弹出**，把异常抛给上一层的栈帧，看能不能处理？继续往上抛.....

> 返回值void写return也没问题，因为方法返回的指令最后都会有return，不过是可以省略







### 栈帧的内部结构

 

**每个栈帧**中存储着：

- **局部变量表Local Variables**
- **操作数栈Operand Stack 或表达式栈**

- 动态链接Dynamic Linking（或指向运行时常量池的方法引用）
- 方法返回地址Return Address 或方法正常退出或者异常退出的定义
- 一些附加信息



![image-20210320181056054](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320181056054.png)





![image-20210320181851764](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320181851764.png)



### 局部变量表



Local Variables



局部变量数组/本地变量表

- **定义为一个==数字数组==，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括八种基本类型数据，对象引用reference，以及returnAddress类型
- 由于局部边来那个表是建立在线程的栈上，是线程的**私有数据**，因此**不存在数据安全问题**
- **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的

↓

这个容量指的就是最大容量，编译的时候确定了**有几个变量**。局部变量表的大小就为这个值。并且在运行时不会改变

![image-20210320182800335](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320182800335.png)

![image-20210320182807852](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320182807852.png)



<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320183226961.png" alt="image-20210320183226961" style="zoom:150%;" />



- **方法嵌套调用的次数由栈的大小决定。**一般来说，**栈越大，方法掐按套调用次数越多**。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀。它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。今儿函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少
- **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成  参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁。局部变量表也会随之销毁**



代码中的行号和字节码指令的行号对应

![image-20210320194445112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194445112.png)

局部变量表：

![image-20210320194620054](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194620054.png)

![image-20210320194641417](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194641417.png)

![image-20210320194705460](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194705460.png)

每个变量都有相应的索引

Start PC：字节码指令的行号

Length：当前变量作用域范围->长度范围，声明完后就可以用了





#### 关于Slot的理解

- 参数值的存放总是在局部变量数组的index0开始 ，到length-1结束
- **局部变量表，最基本的存储单元就是Slot（变量槽）**
- 局部边来那个表中存放编译器可知的各种基本数据类型（8种），引用类型和returnAddress类型的变量
- 在局部变量表里，**32位以内的类型只占用一个slot，包括引用和returnAddress，64位（long&double都是8个字节 8*8）占用两个slot **
  - byte、short、char转换为int

- JVM会为局部变量表中的每一个Slot分配一个**访问索引**，通过这个索引即可成功访问到局部变量表中指定的局部变量值，long和double使用他们的**起始索引，即前一个索引**
- 当一个实例方法被调用的时候，它的方法参数和方法体内定义的局部变量将会 **按照顺序被赋值**到局部便能量表中的每一个slot上
- 如果当前帧是由构造方法或者实例方法创建的，那么 **该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列**



构造方法：

![image-20210320201303871](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201303871.png)

如果是在构造器中对类变量进行赋值，那么不会在lv中保存，因为都是属于this实例的值，局部变量表中放入一个this就够了

静态方法：

```java
public static void test(){
    int i = 1;
    int j = 2;
}
```

![image-20210320201712970](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201712970.png)

非静态方法：

```java
public void test(){
    int i = 1;
    int j = 2;
}
```

![image-20210320201745604](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201745604.png)

说明如果不是static方法，那么在该方法栈帧的局部变量表中，一定是有this这个变量的，才可以调用。**在static方法中就无法使用this，因为局部变量表中没有！**



```java
public void test(){
    long i = 1;
    double j = 2.55;
}
```

![image-20210320202848079](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320202848079.png)

this引用使用一个槽，**long和double各用两个槽**



---



**Slot的重复利用**



**栈帧中的局部变量表中的槽位是可以重用的**，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会**复用**过期局部变量的槽位，从而 **达到节省资源的目的**

![image-20210320203702951](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203702951.png)

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203747030.png" alt="image-20210320203747030" style="zoom:150%;" />

**重复利用**，数组的这个位置已经开辟了，不能浪费，查看是否有变量在该变量声明之前过期了，如果有，就直接使用那个变量的槽位

![image-20210320203813288](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203813288.png)

```java
public void test(){
    int x = 1;
    {
        long i = 1;
    }
    int y = 2;
}
```

![image-20210320204131679](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320204131679.png)

this+x+y+long = 5 但由于long过期了，y使用了slot的槽位

![image-20210320205336743](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320205336743.png)



---



#### **静态变量与局部变量的对比**



> 变量分类：
>
> - 数据类型：基本数据类型 & 引用数据类型
>
> - 按照在类中声明的位置：成员变量（类变量  & 实例变量(归具体的实例所有) ）  &   局部变量
>   - 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并默认赋值
>   - **成员变量在使用前，都经历过初始化默认值**，**linking的prepare阶段**，给类变量默认赋值零值，initialization给类变量显式赋值以及静态代码块赋值
>   - 局部变量：在使用前**必须要显式赋值**。否则编译不通过
>     - 每一个方法都有一个栈帧，其中的局部变量表保存局部变量，**不会有默认赋值，必须要显式赋值**



- 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配
- **准备prepare阶段，执行系统初始化，对类变量设置零值，初始化initialization阶段，赋予静态变量初始值和静态代码快中的初始值**
- 局部变量表不存在系统初始化的过程，一旦定义了局部变量则**必须人为的初始化**，否则无法使用



---

**补充说明：**

- 在栈帧中，与**性能调优**关系最为密切的部分就是前面提到的**局部变量表**。==在方法执行时，虚拟机使用**局部变量表**完成**方法的传递**==

  

- **局部变量表中的变量也是重要的垃圾回收    根节点GC Roots，只要被局部变量表中直接或间接引用的对象都    不会被回收**







### 操作数栈



Operand Stack



> 栈：可以使用数组，链表来实现



- 每一个独立的栈帧中，除了包含局部变量表意外，还包含一个操作数栈，也可以称之为表达式栈
- **操作数栈，再方法执行的过程中，根据字节码指令，可以往栈中写入数据或提取数据，即入栈出栈**
  - 某些字节码指令将值**压入**操作数栈，其余的字节码指令将操作数**取出栈**。使用它们后把结果压入栈 
  - 比如：执行复制、交换、求和等操作
- **这个过程需要根据字节码指令来进行从操作**

![image-20210320213854275](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320213854275.png)



![image-20210320214147145](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320214147145.png)



- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量   ->  临时的存储空间**

- 操作数栈就是JVM执行引擎的一个工作去，当一个方法刚开始执行的时候，一个新的栈帧也会随着被创建出来，**这个方法的操作数栈是空的**  --->  但其实是有空间的，只是没有值，数组一旦确定，长度是确定的！

- 每一个操作数栈都会拥有一个**明确的栈深度用于存储数值（编译期）**，其所需的**最大深度在编译期就定义好了**，保存咋地方法的Code属性中，为max_stack值

  ![image-20210320214511808](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320214511808.png)

- 栈中任何一个元素都是可以任意的Java数据类型：

  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用2个栈单位深度

- 操作数栈 **并非采用访问缩印的女方是来进行数据访问的**，而是只能通过标准的入栈/出栈操作来完成一次数据访问



- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新**PC寄存器**中**下一条**需要执行的字节码指令

![image-20210320223916346](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320223916346.png)

​	**iload压入操作栈**

**aload_0 获取上一个栈帧返回的结果，并保存在操作数栈上**

> .aload_0是装载第一个(0)局部变量引用的对象

​	![image-20210320224117168](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320224117168.png)





- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
- java虚拟机 **解释引擎是基于栈的执行引擎**





### 代码追踪

```java
public test() {
    byte i = 15;
    int j = 8;
    int k = i + j;
}
```

解析class文件：

![image-20210320221007882](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320221007882.png)

> JVM中 int 类型数值，根据 取值范围将 入栈的 **字节码指令** 就分为4类：
>
> 取值 **-1~5** 采用 `iconst` 指令；
>
> 取值 **-128~127** 采用 `bipush` 指令； byte 2 int
>
> 取值 **-32768~32767** 采用 `sipush`指令； short 2 int
>
> 取值 **-2147483648~2147483647** 采用 `ldc` 指令。
>
> i2l：Convert `int` to `long`





```
 0 bipush 15  # 压入操作数栈中
 2 istore_1   # 从操作数栈中取出值15，压入局部变量表中。局部变量表0位置放的是this引用
 3 bipush 8
 5 istore_2   # ..
 6 iload_1 	  # 在局部变量表中把1和2的位置的数据依次取出
 7 iload_2
 8 iadd
 9 istore_3
10 return
```

istore操作使操作数栈中的数弹出并放入局部变量表中

**每进行一次操作，PC寄存器都会调整**

![image-20210320222648067](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320222648067.png)



iload：将局部变量表中的数压入操作数栈中，

![image-20210320222831550](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320222831550.png)

iadd

![image-20210320223012477](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320223012477.png)

再存储到局部变量表中



**操作数栈自始至终用两个空间就够了！**







### i++和++i的区别



```
int i1 = 10;i1++;
int i2 = 10;++i2;
这两个是一样的
-------------------------

int i3 = 10;
int i4 = i3++;

int i5 = 10;
int i6 = ++i5;

-------------------------

int i7 = 10;
i7 = i7++;

int i8 = 10;
i8 = ++i8;


-------------------------

int i9 = 10;
int i10 = i9++ + ++i9;

```





```
 0 bipush 10
 2 istore_1
 3 iinc 1 by 1
 6 bipush 10
 8 istore_2
 9 iinc 2 by 1
 ----------------------
12 bipush 10
14 istore_3
15 iload_3
16 iinc 3 by 1
19 istore 4

21 bipush 10
23 istore 5
25 iinc 5 by 1
28 iload 5
30 istore 6
---------------------------
32 bipush 10
34 istore 7
36 iload 7
38 iinc 7 by 1  #对局部变量表中的数+1，然后放回去的是没+1的数
41 istore 7

43 bipush 10
45 istore 8
47 iinc 8 by 1
50 iload 8
52 istore 8
---------------------------
54 bipush 10
56 istore 9
58 iload 9
60 iinc 9 by 1
63 iinc 9 by 1
66 iload 9
68 iadd
69 istore 10
71 return

```





### 栈顶缓存



Top-of-Stack Caching



基于栈式架构的虚拟机所使用的的**零地址指令**更加紧凑，但完成一项操作的时候必要需要使用更多的入栈和出栈指令，这通水也就意味着将需要更多的指令分派次数和内存读写次数



由于操作数是存储在内存中的，会因此频繁的执行内存读写操作必然会影响执行速度。为了解决这个问题，JVM的设计者们提出了栈顶缓存技术，**将   栈顶元素  全部缓存在==物理CPU的寄存器==中，以此降低对内存的读写次数，提升执行引擎的执行效率**







### 动态链接

**指向运行时常量池的方法引用**

Dynamic Linking

帧数据区：一些附加信息+动态链接+方法返回地址



- 一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。

- 每一个栈帧内部都包含指向 **运行时常量池**中   **==该栈帧所需 方法的引用，其实就是指向运行时常量池的方法引用==**。包含这个引用的目的就是为了支持当前方法的代码能够实现 **动态链接**。比如：invokedynamic指令

- 在Java源文件被编译到字节码文件中时，==**所有的变量和方法引用**都作为**符号引用保存在class文件的常量池里**==。比如：描述一个方法调用另外的方法时，就是通过常量池中指向方法的符号引用来表示的，**那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**



![image-20210320234339008](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234339008.png)



完整类名、名字、描述符。

![image-20210320234354501](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234354501.png)



![image-20210320234406910](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234406910.png)





栈帧中存储的地址->运行时常量池中这个方法的引用

Current Class Constant Pool

![image-20210321000915057](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321000915057.png)

只要用到了这个方法，那么就直接指向运行时常量池中的这个方法地址来进行调用！



![image-20210321002749115](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321002749115.png)



![image-20210321002806814](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321002806814.png)







---



为什么需要常量池呢？

字节码文件需要很多文件、数据的支持。

提供一些符号和常量，便于指令的识别





### 方法的调用



在JVM中，将**符号引用**（#7、#8.....）转换为调用方法的**直接引用**与方法的绑定机制相关。



- **静态链接**

  当一个字节码文件被装载进JVM内部时，如果被调用的 **目标方法在编译期可知，**且**运行期保持不变**时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

- **动态链接**

  **如果被调用的方法在编译器无法被确定下来**，也就是说，只能够在**程序运行期将调用方法的符号引用转换为直接引用**，由于这种引用转换过程具备**动态性**，因此被称为动态链接



----



对应的方法的绑定机制为 早起绑定、晚期绑定。

**绑定是一个字段、方法或者类在   ==符号引用被替换为直接引用==   的过程，这仅仅发生一次**

- **早期绑定**

  被调用的目标方法如果在**编译期可知**，且**运行期保持不变**，将这个方法与所属的类型进行绑定。明确了被调用的目标方法究竟是哪一个，可以使用静态链接的方式将**符号引用转化为直接引用。**

  如：this(),super()

- **晚期绑定**

  **如果被调用的方法在编译器无法被确定下来**，**只能够在程序==运行期==根据 ==实际的类型== 绑定相关的方法**



----

**封装、继承、多态。具备多态特性，那么自然也就具备早起绑定和晚期绑定两种绑定方式**

Java中任何一个普通的方法都具备虚函数的特征——>**运行期才能确定**。在Java中不希望某个方法拥有虚函数的特征时，可以使用**关键字final**来标记这个方法，就不能进行重写了！





---



**非虚方法：**

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，称为非虚方法
- **静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**，
  - 静态方法、私有方法、**final方法**都不能被重写
    - final方法如果在父类中定义过，那么子类中不能出现与父类的final方法签名（方法名+参数）相同的final方法，会被视为重写，**而final方法不允许重写**
  - 实例构造器`this()`，通过重载已经确定调用哪一个构造器。而且构造器也不能被重写
  - 父类方法，`super()，super.xxx()`，也很确定，可以直接绑定
- 其他方法称为虚方法





虚拟机中提供了几条方法调用指令：

普通调用指令：

1. **invokestatic：调用静态方法，解析阶段确定唯一方法版本**
2. **invokespecial：调用 `<init>`方法、私有及父类方法，解析阶段确定唯一方法版本**
3. invokevirtual：调用所有虚方法（final方法除外）
4. invokeinterface：调用接口方法->肯定是进行重写的方法

动态调用指令：

5. invokedynamic：动态解析出需要调用的方法，然后执行
   - 支持由用户胡确定方法版本

1，2调用的方法称为非虚方法，再加一个invokevirtual调用的final方法



- 注意：子类中调用父类中的final方法，如果不加super.showFinal()，会使用 `invokevirtual`指令来调用，**但实际也是调用的父类的final方法，因为final方法不允许重写**。如果加了`super.`那么就使用 `invokespecial`指令，这个方法是确定的，所以final方法也是虚方法
- 如果在子类中调用父类的**普通方法并且没有重写**，不显式加`super.`  使用指令`invokevirtual`，编译期间无法确定是否有重写，虚方法！



---

关于invokedynamic指令

- JVM字节码指令集一直比较稳定，jdk7中增加了invokedynamic指令，这是 **java为了实现【动态类型语言】支持而做的一种改进**
- jdk7中需要借助ASM这种底层字节码工具来产生invokedynamic指令。jdk8的Lambda表达式的出现，invokedynamic指令的生成在java中才有了直接的生成方式
- java7中增加的动态语言类型支持的本质是**对java虚拟机规范的修改**，而不是对java语言规则的修改。增加了虚拟机中的方法调用



---

动态类型语言 和 静态类型语言

区别在于对**类型的检查**是在编译器还是在运行期，满足前者就是静态类型语言，反之是动态类型语言

java是静态类型语言，必须制定类型int/String/double/......

js：var name="...";  var name = 10;所有的变量都叫var

python：info = 130.99; info = "xxx";

- **静态类型语言是判断==变量==自身的类型信息**

- **动态类型语言是判断==变量值==的类型信息，变量没有类型信息，变量值才有类型信息**



```java
public class lambdaTest {
    public void lambda(Func func){
        return;
    }

    public static void main(String[] args) {
        lambdaTest labmdaTest = new lambdaTest();
        Func func = str -> {
            return true;
        };
        labmdaTest.lambda(func);
        labmdaTest.lambda(s -> {
            return true;
        });
    }
}
interface Func{
    public boolean func(String str);
}
```

` invokedynamic #4 <func, BootstrapMethods #0>`

在编译期并不知道是继承/实现谁的对象，只有在运行期才能确定下来是Func接口的实现类，根据对象的值来确定





---



Java语言中方法重写的本质：

1. 找到**操作数栈顶**的第一个元素所执行的**对象的实际类型**，记作  C
2. 如果在类型 C 中找到与常量中**描述符  简单名称都相符**的方法，则进行**访问权限校验**，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError` 异常
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
4. 如果最终没有找到合适的方法，则抛出 `java.lang.AbstractMethodError`异常



`java.lang.IllegalAccessError` ：

程序视图访问或修改一个属性或调用一个方法，这个属性或方法你**没有权限访问**。

一般会引起编译器异常，这个错误如果发生在运行时，说明一个类发生了不兼容的改变->maven jar包冲突





---

**虚方法表**

- 频繁的使用到动态分派，每次动态分派的过程中都要重新在类的方法**元数据**中搜索合适的目标的话就可能影响到执行效率。**为了提高性能，jvm采用在类的方法区建立一个虚方法表来实现。使用索引表来代替查找**

- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
- 什么时候被创建？
  - 在类加载的链接阶段（**解析阶段：将常量池内的符号引用转换为直接引用**）被创建并开始初始化，类的变量初始化准备完成之后，jvm会把该类

栗子：

![image-20210321125217469](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125217469.png)

直接将Son中的toString()指向Object中的方法，而不会往上层去查找



栗子：

![image-20210321125413756](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125413756.png)



![image-20210321125545726](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125545726.png)





![image-20210321125901481](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125901481.png)





![image-20210321130117470](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321130117470.png)





### 方法返回地址



Return Address



- 存放调用该方法的pc寄存器的值
- 一个方法的结束，有两种方式：
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种方式退出，在方法退出后都**返回到该方法被调用的位置**。方法正常退出时，**==调用者的PC计数器的值作为返回地址==，即调用该方法的指令的==下一条指令的地址==**。而通过异常退出的，返回地址是要通过**异常表**来确定，栈帧中一般不会保存这部分信息



方法的退出就是当前栈帧出栈的过程，需要**恢复上层方法的局部变量表、操作数栈、==将返回值压入调用者栈帧的操作数栈==、==设置PC寄存器值==**等，让调用者方法**继续执行下去**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321131225375.png" alt="image-20210321131225375" style="zoom:150%;" />



**异常完成出口退出的不会给他的上层调用者产生任何的返回值**





---



一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令return，会有返回值传递给上层的方法调用者，**正常完成出口**

   - ireturn/lreturn/freturn/dreturn/areturn（引用类型）/return(void，实例初始化方法，类和接口的初始化方法)

2. 遇到了异常，并且这个异常没有在方法内进行处理，在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。**异常完成出口**

   抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码

![image-20210321134220154](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134220154.png)



![image-20210321134625057](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134625057.png)

指令索引4-9间   出现异常就跳转到指令12进行catch处理，然后goto 17继续执行程序

![image-20210321134630982](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134630982.png)

![image-20210321134640762](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134640762.png)







### 一些附加信息



栈帧中还允许携带与java虚拟机实现相关的一些附加信息。如：对程序调试提供支持的信息





### 栈的相关面试题



- 距离栈溢出的情况？StackOverflowError
  - 通过-Xss来设置栈的大小，但还是会出现 OOM
- 调整栈的大小，就能保证不出现溢出吗？ 
  - 只要递归够深，栈帧够大，肯定可以溢出~~
- 分配的栈内存越大越好吗？
  - 延缓StackOverflowError时间，但无法彻底避免
  - 占用其他线程空间/其他区域空间，
- 垃圾回收是否会涉及到虚拟机栈？
  - 不会。只是出栈入栈，不需要垃圾回收
- 方法中定义的局部变量是否线程安全？
  - 具体问题具体分析
  - 

> 线程安全？
>
> 只有一个线程才可以操作此数据，则肯定是线程安全的
>
> 如果有多个线程操作此数据，则此数据是 共享数据，如果不考虑同步机制的话，会存在线程安全问题。

**局部变量不会存在线程不安全的问题，其他变量无法访问到**

![image-20210321142036549](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142036549.png)



----

变量不归当前方法所有，多个线程都可以调用这个方法来对该变量进行操作，就是线程不安全的

![image-20210321142316902](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142316902.png)

![image-20210321142510261](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142510261.png)



---

针对s1的操作是线程不安全的（**间接不安全**），返回以后可能会被其他的多个线程获取到进行操作，进而导致线程不安全

![image-20210321142557192](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142557192.png)

 

> **将局部变量封闭在方法内，不要传出去。。。。是最安全的**

---

**因为String的值在初始化的时候确定（final），无法进行改变，只能读取。s1是线程安全的，其实String也是线程安全的**

![image-20210321142804178](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142804178.png)





运行时数据区各部分：

|            | Error   | GC     |
| ---------- | ------- | ------ |
| 程序计数器 | 不存在  | 不存在 |
| 虚拟机栈   | 存在    | 不存在 |
| 本地方法栈 | 存在    | 不存在 |
| 方法区     | 存在OOM | 存在   |
| 堆         | 存在OOM | 存在GC |







## 本地方法接口



![image-20210321150310455](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321150310455.png)



本地方法：

一个 Native方法就是一个Java调用非java代码的接口。该方法的实现由非java语言实现，比如C，这

在定义一个native Method时，并不提供实现体，因为其实现体是由非java语言在外面实现的

本地接口的作用是融合不同的编程语言为java所用，融合C/C++程序

```java
public final native Class<?> getClass();
```





**native和abstract是不共用**的。native是有方法体！

**native可以和权限public/private ，static ，synchronized 等配合使用。**



---



**为什么要使用native Method？**

有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了

- **与java环境外交互**

  **有时java应用需要与java应用外面的环境交互，这是本地方法存在的主要原因。**java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。使我们无需去了解java应用之外的繁琐的细节。

- **与操作系统交互**

  jvm不是一个完整的系统，经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。**使用本地方法，我们得以用java实现了jre的底层系统的交互，甚至ijvm的一些部分就是用c写的。**使用一些java语言本身没有提供封装的操作系统的特性时，也需要使用本地方法

- **Sun's Java**

  **Sun的解释器使用C实现的，使得它能像一些普通的C一样与外部交互**。jre大部分是用java实现的，也通过一些本地方法与外界交互。比如start0(), setPriority0()方法，被植入JVM内部，由java方法来进行调用，最终进行调用操作系统的API。这个方法的具体实现由JVM提供，更多的情况是本地方法由**外部的动态链接库**提供，然后被JVM调用





**目前该方法的而是用越来越少了，除非是与硬件有关的应用**，比如通过java程序驱动打印机或者java系统管理生产设备....





## 本地方法栈



![image-20210321152451743](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321152451743.png)



- **Java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用。**

- 本地方法栈，也是线程私有的
- 允许被是线程固定或者是可动态扩展的内存大小（和jvm栈一样。。内存溢出方面也相同）
  - StackOverflowError
  - OOM Error
- 本地方法是使用C语言实现的
- 具体做法是 Native Method Stack中登记native方法，在Execution Engine执行引擎执行时加载本地方法库



![image-20210321152846425](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321152846425.png)



- **当某个线程调用一个本地方法时，它就进入了一个全新的并且==不再受虚拟机限制==的世界，*它和虚拟机拥有同样的权限***
  - 本地方法可以通过**本地方法接口**来访问**虚拟机内部的运行时数据区，堆/方法区/.....**
  - 它甚至可以**直接**使用***本地处理器中的寄存器 -> cpu寄存器***
  - 直接存**本地内存 -> 物理内存**的堆中分配任意数量的内存



- **并不是所有的JVM都支持本地方法。因为java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等**。如果jvm产品不打算支持native方法，也可以无需实现本地方法栈
- 在HotSpot JVM中，直接将**本地方法栈和虚拟机栈合二为一**
  - 调用java方法中，内部调用了本地方法，本地方法栈使用动态链接指向本地方法，由执行引擎执行













## 堆



### 堆的核心概述



方法区和堆对于一个进程（JVM实例）来说是唯一的。可被多个线程共享。



- 一个**JVM实例只存在一个堆内存（不同的java进程，即每一个main方法）**，堆也是java内存管理的核心区域
- java堆区在jvm启动的时候即被创建，其**空间大小**也就确定了。是jvm管理的最大一块内存
  - ***堆内存的大小是可以调节的***
  - -Xms10m  -Xmx10m
- 堆可以处于物理上**不连续的内存空间**中，但在**逻辑上**它应该被视为连续的
- **所有的线程共享java堆**，在这里还可以划分**线程私有的缓冲区**（**Thread Loacl Allocation Buffer  ——>  TLAB**）共享内存，线程安全问题，并发性很差。每个线程私有缓冲区，不需要考虑线程安全，并发性更好。

- **所有的对象实例以及数组都应当在运行时分配在堆上**
  - **几乎**所有的对象都在这里分配内存——实际使用角度....
- 数组和对象**可能永远都不会存储在栈上**，因为***栈帧中保存引用***，这个引用**指向**对象或者数组在***堆中的位置***
- 在方法结束后，没有引用指向堆中的对象，但堆中的**对象不会马上被移除**，仅仅在**垃圾收集的时候才会被移除**
  - 减少垃圾回收线程执行的频率
- 堆，是GC（Garbage  Collection，垃圾收集器）**执行垃圾回收的重点区域**，回收对象、数组

- 创建对象的指令：new newarray，anewarray，创建对象，开辟空间



工具jvisualvm.exe：

![image-20210321160706866](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321160706866.png)

相加是设置的堆内存空间



栈中变量指向堆中实例，实例来调用方法区中的方法。

![image-20210321170339618](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170339618.png)



---

**堆的核心概述：内存细分**

**现代垃圾收集器大部分是基于分代收集理论设计，堆空间细分为**



![image-20210321170532129](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170532129.png)



![image-20210321170713334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170713334.png)



----

设置堆空间为10M，设置的参数只负责新生代和老年代，**不负责元空间的大小**

![image-20210321171816078](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321171816078.png)





![image-20210321171959684](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321171959684.png)



---

jdk8中为元空间：

`-XX:+PrintGCDetails`

![image-20210321172202663](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321172202663.png)



修改为jdk7版本：

永久代

![image-20210321172411632](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321172411632.png)









### 设置堆内存大小与OOM



- java堆区用于cunchujava对象实例，那么堆的大小在jvm启动时就已经设定好了，可以通过选项：-Xmx和-Xms来进行设置
  - -Xms用于表示堆区（年轻代+老年代）的**起始内存**，等价于-XX:InitialHeapSize
    - -X: jvm的运行参数
    - ms：memory start
  - -Xmx用于表示堆区的**最大内存**，等价于-XX:MaxHeapSize



- 一旦堆区的内存大小超过-Xmx所指定的最大内存时，将会抛出OutOfMemoryError异常
- 通常会将-Xms和-Xmx两个参数配置相同的值，**其目的是为了能够在java垃圾回收**



- **默认**情况下，初始内存大小：物理电脑内存大小 / 64; 最大内存大小：物理内存大小 / 4

![image-20210321173040544](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321173040544.png)



```java
public static void main(String[] args) throws InterruptedException {

    long totalMemory = Runtime.getRuntime().totalMemory()/1024/1024;
    long maxMemory = Runtime.getRuntime().maxMemory()/1024/1024;

    System.out.println(totalMemory + "    " + maxMemory);
    System.out.println("系统内存大小："+totalMemory * 64.0 / 1024 + "G");
    System.out.println("系统内存大小："+maxMemory * 4.0 / 1024.0 + "G");

}
```

![image-20210321173627585](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321173627585.png)

**开发中建议将初始堆内存和最大的堆内存设置成相同的值，频繁扩容和释放消耗资源。**



手动设置时，也会比实际设置的值要小一点

`-Xmx600m -Xms600m`

实际打印：`575    575`

  

---



**查看设置的参数**：

（或者直接使用jvisual来看  或者 `-XX:+PrintGCDetails`）

![image-20210321174438815](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321174438815.png)

![image-20210321174425741](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321174425741.png)

```
25600 * 2 + 153600 + 409600  /  1024 = 600

25600 + 153600 + 409600  /  1024 = 575
```

????

伊甸园区+survivor区两个区只有一个区能使用。始终有一个survivor空间是空的。





-----



OOM：

![image-20210321175656555](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321175656555.png)

广义上的异常，`Error&Exception extends Throwable`

```java
List<String> list = new ArrayList<>();
while (true){
    list.add(new String("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"));
}
```

![image-20210321175616109](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321175616109.png)

看到溢出原因

![image-20210321180447859](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180447859.png)













### 年轻代与老年代



- 存储在JVM中的java对象可以被划分为两类
  - 一类是生命周期较短的顺势对象，这类对象的创建和消亡都非常迅速！
  - 另外一类对象的生命周期缺非常长，在某些极端的情况下还能够与jvm的生命周期保持一致
- Java堆区进一步细分的话，可以划分为年轻代YoungGen和老年代OldGen
- 其中**年轻代又可以划分为Eden空间(java最先创建的位置)、Survivor0空间和Survivor1空间**（from区、to区）

![image-20210321180926805](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180926805.png)



下面这参数开发中一般不会调：

![image-20210321180954210](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180954210.png)



- 配置新生代与老年代在堆结构的占比
  - -XX:NewRatio=2，表示新生代占1/3，老年代占2/3

- **如果生命周期长的对象多，将老年代调大一些**



- 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8:1:1

- 通过  -XX:SurvivorRatio=?  具体调整比例
- 但实际并不是8   1:1:7  
- **自适应机制**
- -XX:-UseAdaptiveSizePolicy关闭自适应内存分配策略。暂时没有用。。。 



- **几乎所有的java对象都是在Eden区被new出来的**
- 绝大部分的java对象的销毁都在新生代进行了
  - 新生代80%的对象都是"朝生夕死"的
- 可以使用选项-Xmn来设置新生代最大内存大小
  - 一般使用默认值



![image-20210321191620860](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321191620860.png)















### 对象分配过程



对象分配过程：

1. new的对象**先放在伊甸园区**，此区有大小限制
2. 当伊甸园的空间填满时，程序又需要创建对象，jvm的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC/Young GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区
3. 然后将伊甸园区中的**剩余对象移动到幸存者0区**
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的对象，如果没有被回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区
6. 什么时候能去养老区呢？可以设置次数。默认是15次
   - **设置参数：`-XX:MaxTenuringThreshold=<N>`**
7. 在养老区，相对悠闲，当养老区内存不足时，再次触发GC，Major GC，进行养老区的内存清理
8. 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生**OOM异常**



**幸存者区满了不会触发YGC，当Eden区满了后，YGC会将幸存者区和Eden区一起进行回收。被动回收**





红色的对象是被垃圾回收掉的

每一次垃圾回收都倒一下S0、S1中对象的位置

![image-20210321192654404](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321192654404.png)

---

- **针对幸存者s0，s1区的总结：复制之后有交换，谁空谁就是to(另一个是from)**

- **关于垃圾回收：频繁在新生区收集垃圾，很少在养老区收集，几乎不在永久区/元空间收集**



----

特殊情况：

YGC之后伊甸园区一定是空的

Eden放不下，一步到位，放到老年代。。。

Full GC老年代垃圾回收

**总之：放不下就放到老年代中。**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321194355936.png" alt="image-20210321194355936" style="zoom:150%;" />



![image-20210321200900344](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321200900344.png)

老年代满了——> OOM





### 常用调优工具



- jdk命令行
- Eclipse：Memory Analyzer Tool
- Jconsole
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy







### Minor GC、Major GC、Full GC



JVm再进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代

针对HotSpot VM，里面的GC按照回收区域又分为两大种类型：部分收集Partial GC，整堆收集Full GC



- 部分收集：不是完整收集整个java堆的垃圾收集
  - 新生代收集（Minor GC / Young GC），只是新生代的垃圾收集
  - 老年代收集（Major GC / Old GC），**只是老年代的垃圾收集**
    - 目前，只有**CMS GC**会有单独收集老年代的行为
    - **很多时候Major GC会和 Full GC混淆使用需要具体分辨是老年代回收还是整堆回收**
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    - 目前，只有**G1 GC**会有这种行为
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集







----



**年轻代GC触发机制**

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会触发GC，而每次Minor GC满会清理年轻代的内存
- 因为java对象大多都具备朝生夕死的特性，所以Minor GC；非常频繁，一般回收速度也比较快

- **Minor GC会引发STW（stop the word），暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行**

![image-20210321204631767](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321204631767.png)





---

**老年代GC（Major/ Full GC）触发机制**

- 指发生在老年代的GC，对象从老年代消失时，这两个GC会被触发
- 出现了Major GC 经常会伴随至少一次的MinorGC  (非绝对的，在Parallel Scavenge收集器的收集策略里有直接进行Major GC的策略选择过程)
  - 老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC
- **Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长** 
  - **调优：减少Major GC的次数**
- 如果Major GC后，内存还不足，就报OOM了



---

**Full GC触发机制**

1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor、space0区向survivor space1区复制时，对象大小大于To Space可用内存，则吧该对象转存到老年代，且老年代的可用内存小于该对象大小



**Full GC是开发或调优中尽量要避免的，这样暂停的时间会短一些。**

----

栗子：

```java
List<String> list = new ArrayList<>();
String a = "hcrhcrhcr";
while (true){
    list.add(a);
    a = a + a;
}
```



```
[GC (Allocation Failure) [PSYoungGen: 2017K->506K(2560K)] 2017K->830K(9728K), 0.0033778 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2078K->512K(2560K)] 2402K->1986K(9728K), 0.0005180 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2317K->480K(2560K)] 7247K->6027K(9728K), 0.0007253 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 480K->512K(2560K)] 6027K->6075K(9728K), 0.0005772 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 512K->0K(2560K)] [ParOldGen: 5563K->4129K(7168K)] 6075K->4129K(9728K), [Metaspace: 3316K->3316K(1056768K)], 0.0044339 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[GC (Allocation Failure) [PSYoungGen: 39K->32K(2560K)] 6472K->6465K(9728K), 0.0003212 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

[Full GC (Ergonomics) [PSYoungGen: 32K->0K(2560K)] [ParOldGen: 6433K->5281K(7168K)] 6465K->5281K(9728K), [Metaspace: 3316K->3316K(1056768K)], 0.0032575 secs] [Times: user=0.16 sys=0.00, real=0.00 secs] 


[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 5281K->5281K(8704K), 0.0006357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] [ParOldGen: 5281K->5259K(7168K)] 5281K->5259K(8704K), [Metaspace: 3316K->3316K(1056768K)], 0.0066352 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 


Heap
 PSYoungGen      total 1536K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 1024K, 6% used [0x00000000ffd00000,0x00000000ffd118e0,0x00000000ffe00000)
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 7168K, used 5259K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb22e18,0x00000000ffd00000)
 Metaspace       used 3348K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K
```

老年代逐渐变大，当Full GC后还没有剩余空间的时候，就OOM了

**元空间没有改变**

```
[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 5281K->5281K(8704K), 0.0006357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] [ParOldGen: 5281K->5259K(7168K)] 5281K->5259K(8704K), [Metaspace: 3316K->3316K(1056768K)], 0.0066352 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
```

**字符串越来越大，最后直接就放不下了  先进性YGC，再进行一次Full GC 还是装不下啊！——> OOM**









### 堆空间分代思想



***为什么需要把Java堆分代？不分代就不能正常工作了吗？***



- 不同对象的生命周期不同，70%-99%的对象是临时对象
- 新生代：有Eden、两块大小相同的Survivor（from/to）构成，to总为空
- 老年代：存放新生代中经历多次GC仍然存活的对象（或者放不下的对象）



- 其实不分代完全可以。**分代的唯一理由就是优化GC性能。**如果没有分代，所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建爱你的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来





![image-20210321211331349](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321211331349.png)









### 内存分配策略



如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设置为1.对象在Survivor区中每经历过一次Minor GC，年龄就+1，当它的年龄增加到一定程度（默认为15，可以设置，每个JVM的每个GC都有所不同）时，就会被晋升为老年代中

对象晋升老年代的年龄阈值，通过选项   `-XX:MaxTenuringThreshold`来设置



---

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- **大对象直接分配到老年代**
  - 尽量避免程序中出现过多的**大对象**——>更糟糕的是都是“朝生夕死”的.........折磨堆
- **长期存活**的对象分配到老年代
- **动态对象年龄判断**
  - 如果Survivor区中**相同年龄**的所有对象大小的综合**大于Survivor空间的一半**，年龄**大于或等于**该年龄的对象可以***直接进入老年代***，**免得两个Survivor来回倒腾**，无须等到MaxTenuringThreshold中要求的年龄

- **空间分配担保**
  - 大量的对象在GC后都还是存活的，把Survivor中无法容纳的放到老年代
  - `-XX:HandlePromotionFailure`





```
-Xmx60m -Xms60m -XX:+PrintGCDetails

byte[] buffer = new byte[1024*1024*20];//20m
```



![image-20210321213343955](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321213343955.png)

***↑ 这里直接放入到老年代中——20m大小***











### 为对象分配内存：TLAB

**线程私有的缓冲区**

**为什么有TLAB（Thread Local Allocation Buffer）**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在**并发环境**下从堆区中划分内存空间是**线程不安全**的
- 为避免**多个线程操作同一地址**，需要使用**加锁**等级制，进而影响分配速度执行效率



----

**什么是TLAB？**

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为 **每个线程分配了一个私有缓存区域，它包含在Eden空间内**

- 多线程同时分配内存时，使用TLAB**可以避免一系列的线程安全问题** ，同时还能够**提升内存分配的吞吐量**，因此我们可以将这种内存分配方式称之为 **快速分配策略**

- 所有Openjdk衍生出来的JVM都提供了TLAB的设计



![image-20210321213831842](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321213831842.png)



- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是***将TLAB作为内存分配的首选***

- 可以通过选项  `-XX:UseTLAB`设置是否开启TLAB空间。**默认开启**

  - `jinfo -flag UseTLAB port`

-  默认TLAB占用的空间非常小，**仅占有整个Eden区的1%**，可以通过 `-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden的百分比大小

- 一旦对象在TLAB空间分配失败时，JVM就会尝试着通过 **使用加锁机制（在Eden区域）** 确保数据操作的原子性，从而**直接在Eden空间中分配内存**

  

![对象分配过程：TLAB](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321214439882.png)











### 小结堆空间的参数设置



- -XX:+PrintFlagsInitial：查看所有参数的默认值
- -XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）
- -Xms：初始堆空间内存（物理内存的1/64）
- -Xmx：最大堆空间内存（物理内存的1/4）
- -Xmn：设置新生代的大小（初始值以及最大值）
- -XX:NewRatio：设置新生代与老年代在堆结构中的占比
- -XX:SurvivorRatio：新生代中伊甸园区和survivor 0/1区的比例
  - 如果比例很大，经过YGC后，伊甸园区的对象直接进入养老区，幸存者区满了。**Minor GC就没有意义了**
  - 如果比例很小，伊甸园区比较小，YGC出现的频率变高，影响用户进程

- -XX:MaxTrnuringThreshold：设置新生代垃圾的最大年龄
- -XX:+PrintGCDetails：输出详细的GC处理日志
- 打印gc简要信息：-XX:+PrintGC     ;    -verbose:gc
- -XX:HandlePromotionFailure：是否设置空间分配担保



具体查看某个参数的指令:

- jps查看当前运行中的进程  端口
- `jinfo -flag SurvivorRatio port`

----

-XX:HandlePromotionFailure：

在发生Minor GC之前，**虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**

- 若大于，则此次Minor GC是安全的
- 若小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
  - 如果XX:HandlePromotionFailure=true，那么会继续 **检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**
    - 如果大于，则尝试**进行一次Minor GC**，但这次Minor GC**依然是有风险的**
    - 如果小于，则改为进行一次 **Full GC**
  - 如果XX:HandlePromotionFailure=false，则改为进行一次Full GC



jdk7后，这个参数失效了，不会影响空间分配担保策略。

**只要老年代的连续空间大于新生代对象总大小   或者   历次晋升的平均大小 ---->  就会进行Minor GC，否则将进行Full GC**











### 堆是分配对象的唯一选择吗？



new的对象默认是分配在堆空间中吗？

随着JIT编译器的发展与 **逃逸分析技术**逐渐成熟，**栈上分配，标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了



对象是在java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，**那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就有可能被优化成栈上分配**，这样就**无需在堆上分配内存，也无须进行垃圾回收了——>提升性能**。堆外存储技术



TaobaoVM，创新的GC invisible heap技术实现off-heap，将**生命周期较长**的java对象从heap中移至heap外，并且**GC不能管理**GCIH内部的Java对象，以此达到**降低GC的回收频率**和提**升GC的回收效率**的目的



---



**逃逸分析**

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段
- 一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法
- 通过逃逸分析，Java HotSpot编译器能够**分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上**
- 逃逸分析的基本行为就是分析对象动态作用域：
  - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
  - 当一个对象在方法中被定义后，被外部方法所引用，则认为发生逃逸。**例如作为调用参数传递到其他地方中**

![image-20210322102227937](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102227937.png)

**栈空间：每个线程一个栈空间，每个方法一个栈帧，栈内变量随着弹出栈而自动销毁了，不存在GC**





![image-20210322102238315](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102238315.png)

**进行返回！另一个方法对它进行了调用！返回引用，发生了逃逸**

返回的不是sb对象的引用，sb还是可以在栈上分配。





![image-20210322102513708](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102513708.png)

![image-20210322102553241](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102553241.png)

![image-20210322102659268](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102659268.png)

![image-20210322102722619](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322102722619.png)

这个实体可能是在getInstance()中new的对象，也可能是成员变量obj，从外边传进来的引用，那当然也发生了逃逸。。。**对象从一个方法的栈帧中逃逸到了另一个方法中**



**如何快速判断是否发生了逃逸：就看new的对象是否有可能在方法外被调用**



jdk7后，HotSpot默认开启逃逸分析

-XX:+DoEscapeAnalysis

-XX:+PrintEscapeAnalysis



> **在开发中能使用局部变量的，就不要在方法外定义**



----



**使用逃逸分析，编译器可以对代码进行如下优化**

- **栈上分配**。将堆分配转化为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

- **同步省略**。如果一个对象被发现**只能从一个线程被访问到**，那么对于这个对象的操作可以考虑**不同步**
-  **分离对象或标量替换**。有的对象可能**不需要作为一个连续的内存结构**存在也可以被访问到，那么对象的部分（全部）可以**不存储在内存，而是存储在CPU寄存器（栈空间）**中



具体分析↓

---

栈上分配：

编译期根据逃逸分析的结果优化成分配到栈上，分配完成以后，继续在**调用栈内**执行，最后线程结束，栈空间被回收，局部变量对象也被回收。**无须进行垃圾回收了。**

逃逸出方法的场景：**给成员变量（类变量）赋值、方法返回值、实例引用传递**

栗子：

![image-20210322104244152](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104244152.png)

先不开启逃逸分析，

![image-20210322104335724](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104335724.png)

**内存中存了10000000个对象**



改为“+”,开启逃逸分析：

![image-20210322104427714](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104427714.png)

内存中的个数少了很多。

**并且开启逃逸分析后，不会发生GC——在栈上不会发生GC**







---

同步省略：

- 线程同步的代价很高，降低并发性和性能
- 在动态编译同步块时，JIT借助逃逸分析来 **判断同步块锁使用的锁对象   是否只能够被一个线程访问   而没有被    发布到其他线程**。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步，这样就能大大提高并发性和性能。***同步省略，也叫锁消除***



**使用的锁对象没有发生逃逸**

**多个线程需要使用同一个锁，否则就没有意义了。。。。**

**本身多个线程来操作这个代码也是无效的。。。。每次都new一个新的锁。。。。**

![image-20210322104903562](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322104903562.png)



字节码文件中还是有加锁的操作。**运行时去掉这个操作**

![image-20210322105209021](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322105209021.png)



----



分离对象或标量替换



**标量scalar，指一个无法再分解成更小的数据的数据，java总的原始数据类型就是标量**

那些可以分解的数据叫做**聚合量（aggregate）**，**java中的对象就是聚合量**，因为可以分解成其他聚合量和标量

JIT阶段，如果经过逃逸分析，发现一个对象**不会被外界访问**的话，那么经过JIT优化，就会把这个对象**拆解**成若干个其中**包含若干个成员变量**来代替——**标量替换**

![image-20210322105617104](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322105617104.png)



参数：`-XX:+EliminateAllocation`默认是打开的，允许将对象打散分配到栈上



不开启标量替换：

**会进行很多次GC操作**

![image-20210322110929804](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322110929804.png)



开启标量替换：

**花费的时间明显降低，并且没有发生GC——因为都从堆上拆到了栈上**

![image-20210322110956081](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322110956081.png)





----

![image-20210322111136390](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322111136390.png)



**并不是很成熟。。**

![image-20210322111223766](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322111223766.png)

Oracle HotSpot没有开启逃逸分析？？主要还是 **标量替换**



 

小结：

![image-20210322112807672](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322112807672.png)













## 方法区



### 堆、栈、方法区的交互关系



从线程共享与否的角度来看：

![image-20210322152351112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322152351112.png)



整个<类的结构>（对象**类型数据**...）加载到元空间/方法区，new的对象放在堆空间，引用放在jvm栈中

**到<对象类型数据>的指针——>哪个类new的，类结构**

![image-20210322152647834](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322152647834.png)









### 方法区的理解



> 可以说永久代或者元空间等同于方法区，不能说方法区等同于永久代。
>
> ***方法区是JVM的规范***，而永久代是jdk1.8以前Hotspot对于方法区的实现。在jdk1.7以前，字符串常量池就保存在里面。1.7以后提出了**去永久代**的概念，第一步做的就是将字符串常量池移到了堆中。
>
> jdk1.8以后，移除永久代，在本地内存上开辟了一块空间，称为元空间，里面存放运行时常量池，class文件在jvm里的运行时数据结构，各种元数据等等



方法区在哪？

尽管所有的方法区**在逻辑上属于堆的一部分**，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap非堆，就是要和堆分开

**所以，方法区看作是一款独立于java堆的空间**



![image-20210322153920078](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322153920078.png)

**堆中存放new的对象，类本身存放在方法区**



---



- 方法区和java堆一样，是**各个线程共享的内存区域**
- 方法区在jvm启动的时候被创建，并且它的实际的物理内存空间中和java堆区一样都**可以是不连续的**
- 方法区的大小，可以选择**固定大小或者可扩展**
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，OOMError：PermGen space   或者OOMError：Metaspace
  - 加载了**大量的第三方的jar包**，Tomcat部署的工程过多->导致方法区溢出；大量动态的生成反射类
- 关闭jvm（一个进程 -- main方法）就会释放这个区域的内存



每次程序运行会加载非常多的类：

![image-20210322154528908](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322154528908.png)



----



方法区的演进：

- jdk7以前，习惯上把方法区称为永久代，jdk8开始，使用**元空间取代了永久代**
- 本质上，**==方法区和永久代并不等价==**。仅是对HotSpot而言。规范：对如何实现方法区，不作统一要求。例如JRockit中不存在永久代
  - 当年使用永久代，不是好的idea，导致java程序**更容易OOM**（超过XX:MaxPermSize上限）



**元空间使用本地内存，不使用jvm运行时数据区**

![image-20210322154952687](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322154952687.png)



![image-20210322155722533](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322155722533.png)



jdk8，完全废弃了永久代的概念，在本地内存中实现的元空间metaspace来替代



![image-20210322155808112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322155808112.png)

- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代最大的区别在于：***元空间不在虚拟机设置的内存中，而是使用本地内存***
- 内部结构也调整了
- 如果无法满足元空间新的内存分配需求时，将抛出OOM:Metaspace异常













### 设置方法区大小与OOM



方法区的大小不必是固定的，jvm可以根据应用的需要动态调整



jdk7及以前：

- 通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M
- -XX:MaxPermSize来设定永久代最大可分配空间，32位默认是64M，64位机器是82M

- 当JVM加载的类信息容量超过了这个值，会报异常：OOMError:PermGen space

![image-20210322160940371](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322160940371.png)







jdk8中替换成MetaspaceSize

![image-20210322161046663](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322161046663.png)



---

jdk8以后：

- 元数据去大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述两个参数
- 默认值依赖于平台，**-XX:MetaspaceSize是21M**，-XX:MaxMetaspaceSize的值是-1，**即没有限制**
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会好近所有可用系统内存，如果元数据区发生溢出，虚拟机一样会抛出异常OOM:Metaspace

- XX:MetaspaceSize设置初始的元空间大小，默认值21M是初始的高水位线，一旦触及这个水位线，**Full GC将会被触发并卸载没用的类**（即**这些类对应的类加载器不再存活**），然后这个高水位线将会重置。新的高水位线的值**取决于GC后释放了多少元空间**。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值，如果释放空间过多，则适当降低该值
- 如果初始化的高水位线设置过低，上述高水位线**调整情况会发生很多次**，通过垃圾回收器的日志可以观察到Full GC多次调用，**为了避免频繁的GC，建议将-XX:MetaspaceSize设置为一个相对较高的值**



设置方法：`-XX:(Max)MetaspaceSize=size`

![image-20210322161344221](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322161344221.png)



-----

OOM的栗子

jdk7：

![image-20210322162835244](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322162835244.png)

jdk8：

![image-20210322162719213](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322162719213.png)



**如何解决OOM？**

- 一般是通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了**内存泄漏还是内存溢出**

- 如果是内存泄漏，可进一步通过工具查看泄露对象到GC Roots的引用链，就能找到**泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的**。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置
- 如果不存在内存泄漏，换句话说就是内存中的对象确实都还**必须存活着**，那就应当**检查虚拟机的堆参数-Xms -Xmx与机器物理内存**对比看是否还可以调大，从代码上检查是否存在某些**对象生命周期过长、持有状态时间过长**的情况，尝试**减少程序运行期的内存消耗**













### 方法区的内部结构



![image-20210322163603860](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322163603860.png)



**它用于存储已被虚拟机加载的类型信息、常量(final变量)、静态变量(移出)、即时编译器编译后的代码缓存等** 

![image-20210322164022967](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322164022967.png)



---

**类型信息：**

**可以理解为  就是这个java class的基本属性（也包括其中的field/method）**

对每个加载的类型（类Class、接口、枚举enum、注解anno），JVM必须在方法区中存储以下类型信息：

1. 这个类型的**完整有效名称**（全名=包名.类名）
2. 这个类型**直接父类**的完整有效名
3. **修饰符** public,abstract,final
4. 这个类型**直接接口**的一个有序列表（继承了哪些接口）



**域Field信息**：

- JVM必须在方法区中保存类型的**所有域的相关信息**以及域的**==声明顺序==**
- 域的相关信息包括：域名称、类型、修饰符(pulic,protected,static,final,volatile,transient....)



**方法Method信息**：

- 方法名称
- 方法的返回类型
- 方法参数的数量和类型
- 方法的修饰符(public,static,final,synchronized,native,abstract...)
- 方法的字节码bytecodes，**操作数栈，局部变量表**及大小
- **异常表**
  - 每个异常处理的开始位置、结束为止、代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引





`javap -v -p`   -p显示权限小的如private。

![image-20210322165122884](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165122884.png)

![image-20210322165352071](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165352071.png)

**加载到方法区的类中记录了是被哪个ClassLoader加载的，但是在class文件中看不到类加载器的信息，因为目前还没被加载到运行时数据区呢。。。。**



![image-20210322165605949](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165605949.png)



自动生成的构造方法：

![image-20210322165733096](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165733096.png)



方法的字节码：操作数栈深度、局部变量表大小，参数列表（形参或者this引用），操作指令....

![image-20210322165844638](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322165844638.png)



![image-20210322170001315](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170001315.png)

异常表：

![image-20210322170041728](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170041728.png)

如果能执行到指令9：那么跳过异常处理继续执行，否则去target：12处进行异常处理！

![image-20210322170300545](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170300545.png)





**non-final的类变量**

- **静态变量和类关联**在一起，随着类的加载而加载，它们成为**类数据**在逻辑上的一部分
- 类变量表被类的所有实例共享，即使没有类实例时也可以访问他

**直接通过类名来访问：**

**此时对象的引用为null，不会出现空指针异常，都能访问！**

![image-20210322170508939](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322170508939.png)



***全局常量  static final：被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了***



![image-20210322171006775](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322171006775.png)



![image-20210322171032990](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322171032990.png)

 **final值在编译期就写入了它的值**，所以final变量一定要指定值。

**而static需要在类加载器阶段，准备prepare环节给它默认赋零值，初始化时`<clinit>`才会执行赋值操作**   







----



**运行时常量池 vs 常量池**



![image-20210322171547482](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322171547482.png)



- 方法区，内部包含了运行时常量池
- **字节码文件，内部包含了常量池**——>通过类加载器将**类信息**加载到方法区中，字节码文件中的常量池加载到方法区以后——>运行时常量池
- 要弄懂方法区，先理解**ClassFile**，因为**加载类的信息都在方法区**
- 要弄懂方法区的运行时常量池，先理解**ClassFile中的常量池**



ClassFile文件：

![image-20210322172056884](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322172056884.png)



![image-20210322180921563](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322180921563.png)



一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含了一项信息那就是**常量池表**

包括各种字面量和对类型、域和方法的**符号引用->`system.out.println()`这些都是符号引用，常量池中存储的是他们的名称、描述符等信息**

![image-20210322181041717](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322181041717.png)



---

**为什么需要常量池？**

一个java源文件中的类、接口，编译后产生一个字节码文件。而java中的字节码需要数据支持，通常这种**数据会很大以至于不能直接存到字节码里**，换另一种方式，可以**存到常量池**，这个**字节码包含了指向常量池的引用**。在**动态链接**的时候会用到**运行时常量池**，



![image-20210322181530774](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322181530774.png)

虽然只有194字节，但是里面却使用了String、system、printstream及object等结构，这里代码量其实已经很小了。如果代码多，引用到的结构会更多！又或者重复出现的一些引用，只需要加载一遍。



需要使用某个类的方法，去常量池中寻找**它的引用**即可



几种在常量池内的数据类型包括：

- **数量值**
- **字符串值**
- **类引用**
- **字段引用**
- **方法引用**



例如下面这段代码：

![image-20210322182720815](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322182720815.png)

![image-20210322183055695](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322183055695.png)



**常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型** 





---



**字面量：如直接给sout中传入一个字符串，这就是字面量 `System.out.println("xxxxxxxx");`**

只有在这个int数值足够大（short范围外）才会存进常量池中

![image-20210322190335715](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322190335715.png)



![image-20210322190347398](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322190347398.png)





**运行时常量池**



- 运行时常量池是方法区的一部分
- 常量池表示Class文件的一部分，**用于存放编译期生成的各种==字面量和符号引用==，这部分内容将在类加载后存放到方法区的运行时常量池中**
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池
- JVM为***每一个已加载的类型（类/接口）都维护一个常量池***。池中的数据项  像数组项一样，是通过**索引访问**的
- 运行时常量池中包含**多种不同的常量**，包括编译器就已经明确的**数值字面量**，也包括到运行期解析后才能获得的**方法或者字段引用**。此时**不再是常量池中的符号地址了**，这里换为真实地址
  - **运行时常量池，相对于Class文件常量池的领域重要特征是：具备动态性！**
    - String.intern()放入常量池中
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OOM异常









----

常量池存储数据：

**除了保存一些数值、字符串等字面量以外，对于类、方法等都是保存引用——>包名、名称、描述符**

![image-20210322191415641](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322191415641.png)













### 方法区使用实例



![image-20210322195337457](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322195337457.png)



![image-20210322195740207](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322195740207.png)





![image-20210322200620256](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322200620256.png)

**执行的时候，会通过常量池中给出的完整包名、类名、描述符  符号引用，来看方法区中System/...类是否被加载过，没有就加载进来，然后这个符号引用转为真实内存中的System类的直接引用，现在还只是==字符串形式==，用的时候是一个类**

**将符号引用转换为直接引用！！！**



![image-20210322202600751](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322202600751.png)





**调用方法的参数    ——>  从操作数栈中弹出，**

invokevirtual调用方法，如果解析出来的方法不是native的，***所有的参数和this从操作数栈中弹出***。在JVM栈上***为当前准备调用的方法创建一个新的栈帧***。
   * this和所有参数被按照如下顺序***作为新栈帧的局部变量***，**this占slot0**，arg1即55占slot1(如果arg1为long或double类型，则占slot1和slot2)，
        此时本线程的**PC寄存器指向本条语句，即：invokevirtual #3**，
   * 新的栈帧成为当前栈帧，当前线程的PC寄存器压入**即将调用方法的第一条指令的操作码**，程序执行从第一条指令继续进行。
   * 当前println方法执行完成后，栈帧弹出jvm栈，PC寄存器继续执行上一个调用该方法的方法，此时的PC寄存器值为调用方法的下一个指令地址：25

**程序计数器一直在记录当前线程执行到的操作指令的地址，与jvm栈顶的栈帧方法对应。**

![image-20210322202739935](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322202739935.png)

















### 方法区的演进细节



![image-20210323090659984](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323090659984.png)



- 只有HotSpot才有永久代。 

- HotSpot中方法区的变化：

  ![image-20210323090743963](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323090743963.png)





![image-20210323092804998](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323092804998.png)



永久代为什么要被元空间替代？



- 类的元数据信息被移到了一个与 **堆不相连的本地内存区域，这个区域叫做元空间**
- 元空间的最大可分配空间就是系统可内存



原因：

1. **为永久代设置空间大小是很难确定的**

   如果动态加载类过多，容易产生Perm区的OOM。在运行过程中，要不断动态加载很多类

   ![image-20210323093736395](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323093736395.png)

2. 对永久代进行调优是很困难的



----

**为什么要把字符串常量池和静态变量移除？**



Stringtable为什么要调整？

jdk7中将StringTable放入到了堆空间中，因为永久代的回收效率很低，在full gc的时候才会触发，而full gc是老年代的空间不足 / 永久代不足时才会出发。

开发中会有大量的字符串被创建，回收效率低导致永久代内存不足，**放到堆中，能及时回收内存。**



---



**静态变量放在哪里**

![image-20210323095500129](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323095500129.png)



在1.7中：

![image-20210323095651835](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323095651835.png)

**放在了堆中的老年代中**

1.6中也在老年代中

8：也在老年代中



为什么6.7.8都在堆空间中？

**结论：静态引用的<对象本身>始终存放在堆中！变量arr这个引用名存放有所变化！**



使用JHSDB工具进行分析



![image-20210323100256047](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323100256047.png)



![image-20210323100355606](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323100355606.png)

**对象的数据都在堆中。但三个引用有不同：**

- **成员变量的引用instanceobj随着对象一起放在堆空间中**
- **局部变量**的引用放在方法栈帧的**局部变量表**中



**静态成员变量**的引用呢？存放在哪？

在Class实例中，而**所有的Cl实例对象都保存在堆中**。

![image-20210323100840593](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323100840593.png)

把静态变量与类型与**Class对象**存放在一起，存储在Java堆中 





















### 方法区的垃圾回收



规范对方法取得约束非常宽松，不要求虚拟机在方法区中实现垃圾收集。

事实行业确实有没实现方法区类型卸载的收集器存在（ZGC收集器不支持类卸载）

**这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。**但是这部分区域的回收有时又确实是必要的。

**方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量  和  不再使用的类型**





- 方法区内常量池之中主要存放的是两大类常量：字面量和符号引用

  字面量：如文本字符串、被声明为final的常量值等。

  符号引用属于编译原理方面的概念：

  - 类和接口的**全限定名**
  - 字段的**名称和描述符**
  - 方法的名称和描述符



- HotSpot虚拟机对常量池的回收策略很明确，**只要常量池中的常量没有被任何地方引用，就可以被回收**

- 回收废弃常量与回收java堆中的对象非常类似



判定一个常量是否“废弃”还是相对简单，而要判断一个类型是否属于“不再被使用的类”的条件就比较苛刻：

![image-20210323102750104](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323102750104.png)

**字节码文件使用类加载器加载进内存中，这时方法区记录了这个类的类加载器**



![image-20210323102833827](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323102833827.png)











### 总结



![image-20210323103333748](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/VU7T3mYBpg4sNiG.png)





![image-20210323104708920](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323104708920.png)



![image-20210323104900210](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323104900210.png)





## 对象的实例化内存布局与访问定位



![image-20210323105226864](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323105226864.png)





### 对象的实例化





![image-20210323105259036](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323105259036.png)



#### 创建对象的方式



- new：
  - 最常见的方式+构造器  
  - 单例模式 xxx的静态方法（构造器不暴露在外）
  - xxxBuilder/Factory 内部静态方法返回对象
- Class的newInstance() 
  - 反射的方式，调用的空参构造器，权限必须是public
- Constructor的newInstance(Xxx)
  - 反射，可以调用无参/带参构造器，权限没有要求
- 使用clone()
  - 不调用任何构造器，当前类需要去实现Cloneable接口，需要实现clone()方法
- 使用反序列化
  - 从文件/网络中获取对象的二进制流，还原为对象
- 第三方库Objenesis





#### 创建对象的步骤



---

从字节码角度来看：

```
Object o = new Object();
```



```
0 new #2 <java/lang/Object>
3 dup
4 invokespecial #1 <java/lang/Object.<init>>
7 astore_1
8 return
```



1. 调用new操作符，判断方法区中是否已经加载Object类，没加载就使用类加载器进行加载。然后在堆空间中开辟空间，零值初始化

2. dup：复制，操作数栈
3. invokespecial #1 **调用Object类中的`<init>`构造器方法**。如果构造器有形参，也需要及时放到操作数栈中（可能也需要初始化，赋值）

如：

```java
class Person{
    public int age;

    public Person(int age) {
        this.age = age;
    }
}

public static void main(String[] args)  {
    int age = 20;
    Person person = new Person(age);
}
```

![image-20210323111159513](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323111159513.png)

iload_1是先将局部变量表中的参数压入操作数栈中，再将其传递给Person的构造器



4. 将这个对Object对象的引用 o 放入局部变量表中



---

**从执行步骤的角度来分析：**

1. 判断对象对应的类是否加载、连接、初始化。加载类元信息

   虚拟机遇到一条new指令，首先去检查这个指令的参数能否在**Metaspace的常量池中定位到一个类的符号引用**，并且检查这个**符号引用代表的类是否已经被加载、解析、初始化**。（即判断类元信息是否存在）。如果没有，那么在**双亲委派模式**下，使用当前类加载器以***ClassLoader+包名+类名为Key进行查找对应的class文件***。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则**进行类加载，并生成对应的Class类对象**。



2. 为对象分配内存

   首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象，**此时该对象占用的堆空间已经可以确定了！**如果实例成员变量是引用变量，**仅分配引用变量空间即可**——>4个字节大小

   - 如果内存规整

     - **指针碰撞**

       Bump The Pointer，所有用过的内存在一遍，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用**带有compact（整理）过程的收集器时，使用指针碰撞**

   - 如果内存不规整

     - 虚拟机需要维护一个列表--**空闲列表**

       已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存

       列表记录了**哪些内存块是可用的**，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并**更新列表上的内容**

   - 说明

     选择哪种分配方式由**Java堆是否规整**决定，而java堆是否规整又由所采用的的**垃圾收集器**是否带有**压缩整理功能**来决定



3. 处理**并发安全问题**
   - 采用CAS失败重试、区域加锁保证更新的原子性
   - 每个线程预先分配一块TLAB——通过-XX:+/-UseTLAB参数来设定



4. **初始化分配到的空间**——所有属性设置**默认值（零值）**，保证对象实例字段在不赋值时可以直接使用，



> 1. 默认初始化--零值
> 2. 显示初始化
> 3. 代码块中初始化
> 4. 构造器初始化



5. 设置对象的**对象头**

   将对象的所属类（类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。**指向方法区/元空间的类元信息**



6. 执行**init方法(构造器)**进行初始化

   java程序的视角看来：初始化才正式开始。初始化成员变量，执行实例化代码块，**调用类的构造方法**，并把**堆内对象的首地址赋值给引用变量**

   new指令之后会接着就是执行方法，把对象按照我们的意愿进行初始化，这样一个真正可用的对象才算完全创建出来

   **显示初始化、代码块中初始化、构造器初始化都是在最后一步中实现的**



```java
class Person{
    public int age = 20;

    public Person(int age) {
        this.age = age;
    }
}
```

![image-20210323130618874](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323130618874.png)

aload_0：从局部变量表中加载this引用，对age进行显式赋值。

iload_1：从局部变量表中获得构造器传入的age参数（调用者的操作数栈age->被调用者的局部变量表），构造函数方法进行赋值



---

new还是构造器才是造对象？

都是！

- new是加载类、开辟空间分配内存、默认零值、对象头

- 构造器来进行属性显式初始化

**二者共同协作创造一个对象实例**







### 对象的内存布局





![image-20210323131629703](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323131629703.png)



**对象头**：

- 运行时元数据

  哈希值：堆中对象首地址——>引用变量

  GC分代年龄（进入老年代）

  锁状态标志

  ...

- **类型指针**

  指向类元数据InstanceClass，元空间中的类型信息，**确定该对象所属的类型**

  `getClass（）`

- 数组也是一个对象，还需要记录**数组的长度**

---

**实例数据**：

- 是对象真正存储的有效信息，包括**程序代码中定义的各种类型的字段**（包括从父类继承下来的和本身拥有的字段）
- **相同宽度**的字段总是被分配在一起
- **父类中定义的变量会出现在子类之前**
- 如果CompactFields参数为true，**子类的窄变量可能插入到父类变量的空隙**



---

对齐填充padding：起到**占位符**的作用



![image-20210323132520448](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323132520448.png)







### 小结图示



从new一个Customer类的实例cust开始：

主线程的   jvm栈的   main()方法栈帧的   局部变量表：0:args; 1:cust

cust指向堆空间中的实例信息：1.对象头（运行时元数据+类型指针）2.实例数据 3.对齐填充

实例数据如：acct实例、name值都存在堆空间中，将地址传给引用

类型指针指向   元空间/方法区中的类元信息——>类型信息

![image-20210323132532977](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323132532977.png)









### 对象的访问定位



![image-20210323134854452](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323134854452.png)



**java虚拟机是如何通过栈帧中的局部变量 -> 对象引用访问到其内部的对象实例的呢？**

![image-20210323134902194](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323134902194.png)



1. 创建对象的目的就是为了使用它

2. jvm如何通过栈帧中的对象引用访问到其内部的对象实例的呢？

   **定位，通过栈上reference访问**

3. 对象访问方式主要有两种：

   1. 句柄访问

      ![image-20210323135225631](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323135225631.png)

    **对象的句柄  由两部分组成：对象实例数据  &  对象类型数据**

   

   实现：

   

   优缺点：效率低，需要专门开辟空间保存句柄。reference中存储稳定句柄地址，对象被移动时（**垃圾收集时移动对象很普遍**）只会**改变句柄中实例数据指针**即可，**reference本身不需要被修改**

   

   

   2. 直接指针(HotSpot采用)

   ![image-20210323135245740](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323135245740.png)

   **对象实例数据中包含了到对象类型数据的指针，指向方法区中的对象类型数据**

   

​	优缺点：效率高，不需要专门开辟空间记录句柄。在垃圾回收改变实例地址后需要对栈中的	引用地址进行修改。







## 直接内存(元空间)



- 不是**虚拟机运行时数据区**的一部分，也不是jvm规范中定义的内存区域
- **直接内存是在java堆外的、直接向系统申请的内存区间**
-  来源于NIO，通过存在堆中的**DirectByteBuffer**操作**Native内存**。**直接分匹配本地空间**
- 访问直接内存的速度会优于java堆，即**读写性能高**
  - 处于性能考虑，读写频繁的场合可能会考虑使用直接内存
  - Java的NIO库允许java程序使用直接内存



> IO：byte[]  / char[]   Stream流
>
> NIO：New IO /  Non-Blocking IO非阻塞。 Buffer，Channel通道



```java
public class BufferTest {
    private static final int BUFFER = 1024 * 1024 * 1024;

    public static void main(String[] args) {
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);//创建DirectByteBuffer对象
        System.out.println("直接内存分配完毕");

        Scanner scanner = new Scanner(System.in);
        scanner.next();

        System.out.println("直接内存开始释放");
        byteBuffer = null;
        System.gc();
        scanner.next();
    }
}
```



![image-20210323152242278](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323152242278.png)



释放内存

![image-20210323152326048](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323152326048.png)

减去的差不多就是1GB





![image-20210323152552946](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323152552946.png)

 

物理磁盘<——>物理内存<——>java

![image-20210323152915944](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323152915944.png)





---

- 也可能导致OOMError:Direct buffer memory异常
- 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大的堆大小，但是系统内存是优先的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存
- 缺点
  - 分配回收成本较高
  - 不受jvm内存回收管理
- **直接内存大小**可以通过`MaxDirectMemorySize`设置
- 如果不指定，**默认与堆的最大值-Xmx参数值一致**





![image-20210323155104099](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323155104099.png)

![image-20210323155221181](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323155221181.png)





**java process memory = java heap + native memory**

![image-20210323155348508](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323155348508.png)







# 执行引擎



![image-20210323155521144](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323155521144.png)





## 执行引擎概述



![image-20210323155909460](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323155909460.png)



![image-20210323155934585](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323155934585.png)



- 执行引擎是java虚拟机核心的组成部分之一
- “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行的能力，区别是**物理机**的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而 **虚拟机的执行引擎则是由软件自行实现的**，因此可以**不受物理条件制约**地定制指令集（x86/ARM/...）与执行引擎的结构体系，**能够执行那些不被硬件直接支持的指令集格式**



JVM的主要任务是负责 **装载字节码文件其内部**，但**字节码并不能够直接运行在操作系统之上**，因为字节码指令**并非等价于本地机器指令**，它内部包含的仅仅只是一些**能够被JVM所识别**的字节码指令、符号表，以及其他辅助信息

![image-20210323160404489](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323160404489.png)

**如果想让一个java程序运行起来，执行引擎execution engine的任务就是  将字节码指令解释/编译为对应平台上的本地机器指令才可以**。

简单来说，***JVM中的执行引擎充当了将高级语言翻译为机器语言***  的译者

这里的编译是 **后端编译**，将java文件编译为字节码文件的是 **前端编译**





----

**执行引擎工作过程：**

![image-20210323161011261](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323161011261.png)

1. **执行引擎在执行的过程中需要执行什么样的字节码指令  完全依赖于  PC寄存器**
2. 每当执行完一项指令操作后,**PC寄存器就会更新**下一条需要被执行的指令地址
3. 当然方法在执行的过程中，执行引擎有可能会通过存储在**局部变量表中的对象引用**准确定位到***存储在java堆区中的对象实例信息***，以及通过***对象头中的元数据指针定位到目标对象的类型信息***

**负责翻译  字节码指令->机器指令**

![image-20210323161707952](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323161707952.png)



**从外观上看，所有的jvm的执行引擎输入、输出都是一致的：**

**输入的是字节码二进制流，处理过程是字节码解析、编译、执行的等效过程，输出的是执行结果**













## java代码编译和执行过程



![image-20210323161920155](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323161920155.png)

橙色：javac编译器（前端编译器），**线性字节码指令流**，**和jvm没关系**

绿色：解释器，逐行解释翻译执行

蓝色：JIT编译器，**程序代码->目标机器代码，后端编译器**

java：半编译、解释语言



大部分的程序代码转换成**物理机的目标代码**或**虚拟机能执行的指令集之前**，都需要经过上图中的各个步骤

java源码编译是由java源码编译器javac来完成：

![image-20210323162433739](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323162433739.png)

java字节码的执行是由jvm执行引擎来完成：

![image-20210323162619467](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323162619467.png)



-----

**什么是解释器interpreter，什么是JIT编译器？**

解释器：当java虚拟机启动时会根据预定义的规范 **对字节码采用    逐行解释  的方式执行**，将每条字节码文件中的内容“**翻译**”为对应平台的本地机器指令执行

JIT---Just In Time Compiler编译器：就是虚拟机**将源代码直接编译成和本地机器平台相关的机器语言**，先翻译完成，再执行



---

**java是半编译半解释型语言？**

jdk1.0，解释执行，后来，java发展处可以直接生成本地代码的编译器

现在jvm在执行java代码的时候，通常都会**将解释执行与编译执行二者结合起来进行**

在编译时也能优化！

（**方法区能保存JIT代码缓存，频繁调用->直接得到机器指令**）











## 机器码、指令、汇编语言





生成字节码的规则是统一的

![image-20210323164018239](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323164018239.png)



**机器码：**

- 各种用二进制编码方式表示的指令，机器指令吗
- 机器语言虽然能够被计算机理解和接受，到哪和人们的语言差别太大，不易被人们理解和记忆
- 已经输入计算机，CPU直接读取运行，因此执行速度最快
- 机器指令与CPU紧密相关，**不同种类的cpu所对应的机器指令也就不同**



**指令：**

- 机器码只有0和1，可读性实在太差
- 指令就是把机器码中特定的0和1序列简化成对应的指令（一般为英文：mov,inc）可读性稍好
- **不同的硬件平台**，执行同一个操作，对应的**机器码可能不同**，所以不同的硬件平台的**同一种指令**（如mov），**对应的机器码也可能不同**



**指令集**：

- 不同硬件平台，支持各自的指令，每个平台锁支持的指令，称之为对应平台的指令集
- x86指令集
- arm指令集



**汇编语言：**

- 指令的可读性还是太差
- **用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址**
- 不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令，计算机只认识二进制指令码



**高级语言**

- 更接近人的语言
- **仍然需要把程序解释和编译成机器的指令码，过程：解释程序或编译程序**



![image-20210323180102550](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323180102550.png)







![image-20210323180404313](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323180404313.png)

![image-20210323180358800](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323180358800.png)





**字节码：**



- 字节码是一种中间状态的二进制代码，它比机器码更抽象，需要翻译后才能成为机器码
- **字节码主要为了实现特定软件运行和软件环境，与硬件环境无关**
- 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码。









## 解释器



**初衷是仅仅为了满足java程序实现跨平台特性  **，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。



![image-20210323180856180](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323180856180.png)







解释器真正意义上承担的角色就是一个运行时翻译者，蒋字节码文件中的内容翻译为对应平台的本地机器指令执行。

当一条字节码指令被解释器执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作



- **字节码解释器**

  纯软件代码你字节码的执行，效率非常低

- **模板解释器**

  将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，提高了解释器的性能

cpython：使用c语言解释python



- **基于解释器执行已经沦落为低效的代名词**
- **JVM平台支持一种叫做即时编译的技术，避免函数被解释执行，将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可**，使得java的执行效率大幅度提升







## JIT编译器

Just In Time即时

![image-20210323182356030](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323182356030.png)



 

HotSpot VM是高性能虚拟机的代表作之一。**采用解释器与即时编译器并存的架构**。在java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，**尽力去选择最合适的方式来权衡     编译本地代码的时间      和    直接解释执行代码的时间**

java的性能已经可以和C/C++一较高下





---

**问题来了**！



既然JIT性能已经很好了，为什么还要保留解释器呢？



当程序启动后，**解释器可以马上发挥作用，省去编译的时间，立即执行，响应速度快！！**

编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。

所以：

尽管JRockit VM程序的执行性能会非常搞笑，**但程序在启动时必要需要花费更长的时间来进行编译。**对于服务器端还好（服务器更关注性能，启动后保持高性能运行），但对于那些看重启动时间的应用场景（客户端需要很块的响应时间）来说，需要采用解释器与即时编译器并存的架构来换取一个平衡点。

**当java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去很多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率**



同时，解释执行在比爱你一起进行激进优化不成立的时候，作为编译器的“逃生门”



---

HotSpot VM：

**解释器首先发挥作用，省去许多不必要的编译时间。**即时编译器柱间发挥作用，根据热点探测功能， **将有价值的字节码编译为本地机器指令，换取更高的程序执行效率**





![image-20210323184939384](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323184939384.png)





**JIT**编译器



java语言的编译期其实是一段不确定的操作过程，

- 前端编译器，把.java文件转变成.class文件的过程
- **后端运行期编译器JIT编译器**，把字节码转变成机器码的过程
- **静态提前编译器（AOT编译器）**，直接把.java文件编译成本地机器代码的过程

![image-20210323190044247](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323190044247.png)





### 热点代码及探测方式



是否需要**启动JIT编译器**将字节码直接编译为对应平台的本地机器指令，需要根据代码被调用 **执行的频率**而定。关于那些需要被编译为本地代码的字节码，也被称之为 **“热点代码”**，JIT编译器在运行时会针对那些**频繁被调用的“热点代码”**做出 ***深度优化***，将其直接编译为对应平台的本地机器指令，以此提升java程序的执行性能



- **一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为热点代码**。这种编译方式发生在方法的执行过程中，被称之为栈上替换OSR（On Stack Replacement）



- **多少次才算多？**，需要一个明确的阈值，**这里主要依靠热点探测功能**
- **目前HotSpot VM所采用的热点探测方式是   *基于计数器的热点探测***



- 采用基于计数器的热点探测，HotSpot VM将会为每个方法都建立2个不同类型的计数器，   方法调用计数器，回边计数器
  - 方法调用计数器：统计方法的调用次数
  - 回边计数器：统计循环体执行的循环次数



---



**方法调用计数器：**

统计方法被调用次数，默认阈值在Client模式下是1500次，在server模式下是10000次，超过这个阈值，就会出发JIT编译



- 这个阈值可以通过**虚拟机参数** `-XX:CompileThreshold`来设定

- 当一个方法被调用时，会**先检查该方法是否存在被JIT编译过的版本**，如果存在，则**优先使用编译后的本地代码来执行**。

  如果不存在，该方法的调用计数器+1，**使用解释器来执行**，**判断方法调用计数器与汇编计数器之和是否超过方法调用器的阈值**，如果已超过，那么会向即时编译器提交一个该方法的代码编译请求



![image-20210323191320068](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323191320068.png)

**编译后的机器指令需要缓存起来——元空间/方法区中**



---

**热度衰减**：

- 如果不做任何设置，方法的调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，**即一段时间之内方法被调用的次数**，当超过 **一定的时间限制**，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被 **减少一半**，这个过程称之为方法调用计数器热度的 **衰减Counter Decay**，**半衰周期Counter Half Life Time**



- 热度衰减的动作实在***虚拟机进行垃圾收集时顺便进行的***， 可以使用参数 `-XX:-UseCounterDecay`来**关闭热度衰减**，让**方法计数器统计方法调用的*绝对次数***，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码



- `-XX:CounterHalfLifeTime`参数**设置半衰周期的时间**，单位是 s



---



**回边计数器**

统计一个方法体重**循环体代码执行的次数**，在字节码中遇到控制流向后跳转的指令称之为"回边

"Back Edge。建立回边计数器统计的目的就是为了触发OSR编译

  

![image-20210323192935204](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323192935204.png)







----

**设置程序执行方式：**



![image-20210323193237140](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323193237140.png)



![image-20210323193934698](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323193934698.png)



`java -Xint -version`切换为纯解释器的模式

`java -Xcomp -version`

.....

或者JVM参数：-Xint/.....





纯用解释器：6520ms

纯用编译器 ：950ms

混合模式：936ms







---

**JIT分类：**



HotSpot VM内嵌两个JIT编译器，Client Compiler，Server Compiler

C1编译器和C2编译器。

显示指定java虚拟机在运行时到底使用哪个JIT编译器：

**64位操作系统只支持Server VM**

- -client：指定java虚拟机运行在client模式下

  C1编译器进行 **简单可靠的优化，耗时短，更快的编译速度**

- -server：指定java虚拟机运行在Server模式下

  **耗时较长**，激进优化，但执行效率更高





![image-20210323195955416](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323195955416.png)



 

![image-20210323200050269](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323200050269.png)

两种编译器同步使用





![image-20210323200230464](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323200230464.png)





----



jdk10后，HotSpot加入了一个全息的即时编译器：Graal编译器



**AOT编译器**

![image-20210323200414410](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323200414410.png)

**提前编译器？**

**将字节码文件在运行之前翻译成机器码**



![image-20210323200810463](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323200810463-1616501298078.png)



















# StringTable







## String的基本特性



- 创建方式：
  - String s1 = "xxx";  **字面量的定义方式，像是基本数据类型**
  - String s = new String("xxx"); 

- String声明为 **final**的，**不可被继承 **

- String实现了Serializable接口：表示字符串是支持序列化的

  实现了Comparable接口：表示String可以比较大小

- 内部存储类型改变：

1.8：`private final char value[];`

11：`private final byte[] value;`  **从char数组变为了byte数组**

![image-20210323210247060](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210323210247060.png)



一个char两个字节，16bits。String是堆空间主要部分。**大部分String对象包含拉丁字符**。一个字节就能存的下，**会有一半空间浪费了**。

再附加一个字符编码的标识。



String再也不用char[]来存储了，改成了byte[]加上编码标记，节约了一些空间

**StringBuffer和StringBuilder都修改了**！



---

String：代表不可变的字符序列，**不可变性**

- 当对字符串**重新赋值时**，需要***重写指定内存区域赋值***，不能使用原有的value进行赋值
- 当对现有的字符串进行连接操作时，也需要**重新指定内存区域赋值**，不能使用原有的value进行赋值
- 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。

***不会对原本堆空间字符串常量池中的字符串来赋值*，只会在常量池中新创造一个对象来返回给引用**

- ***通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中————>>> 即这个对象数据存储在常量池中***



```java
public static void main(String[] args) {
    String s1 = "abc";//字面量定义的方式，“abc”存储在字符串常量池中
    String s2 = "abc";//其实共用的是字符串常量池中的同一个字符串引用
    //s1 = "hello"; //重新造一个String对象"hello"

    System.out.println(s1 == s2);//判断地址

    System.out.println(s1);
    System.out.println(s2);
}
```



```java
public static void main(String[] args) {
    String s1 = "abc";//字面量定义的方式，“abc”存储在字符串常量池中
    String s2 = "abc";//其实共用的是字符串常量池中的同一个字符串引用
    //s1 = "hello"; //重新造一个String对象"hello"
    s2 += "def";//堆空间的字符串常量池中新造一个String对象“abcdef”
    System.out.println(s1 == s2);//判断地址

    System.out.println(s1);
    System.out.println(s2);
}
```



```java
public static void main(String[] args) {
    String s1 = "abc";//字面量定义的方式，“abc”存储在字符串常量池中
    //String s2 = "abc";//其实共用的是字符串常量池中的同一个字符串引用
    //s1 = "hello"; //重新造一个String对象"hello"
    //s2 += "def";//堆空间的字符串常量池中新造一个String对象“abcdef”

    String s2 = s1.replace('a','m');//同样是新造一个String对象"mbc"，并不会改变原本的abc
    System.out.println(s1 == s2);//判断地址

    System.out.println(s1);
    System.out.println(s2);
}
```



------

经典String题型：

![image-20210324091039356](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324091039356.png)

传入的是String的引用，在方法中“试图对引用的值进行修改”，**但String有不可变性，只能是在常量池中新建一个“test ok”字符串，并将其引用返回给<u>方法中的str</u>**

**方法传入的只是形参，除非对形参引用指向的堆地址进行修改，否则直接修改引用是没有用的！！！！！！**





----

**字符串常量池中是不会存储相同内容的字符串的**

- String的String Pool是一个固定大小的**HashTable**，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成**Hash冲突**严重，从而导致**链表会很长**，而链表长了后直接会造成的影响就是**当调用String.intern时性能会大幅下降**。不会扩容，只能直接设置

- 使用 `-XX:StringTableSize=`设置StringTable的长度
- jdk6中StringTable是固定的，1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTableSize的设置没有要求
- jdk7中，StringTable的长度默认是60013

- jdk8中，1009是最小值

  ![image-20210324092454955](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324092454955.png)



- jdk11：  最小可以设置为128. 

![image-20210324091959402](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324091959402.png)

![image-20210324092203130](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324092203130.png)



**将StringtableSize调大，明显看到操作intern()更快了**









## String的内存分配



- 在java语言中有八种基本数据类型和比较特殊的类型String。这些类型为了使它们在运行过程中速度更快，更节省内存，**都提供了一种常量池**的概念。**都有常量池！**

- 常量池类似一个java系统级别提供的缓存，8种基本数据类型的常量池都是系统协调的。**String类型的常量池比较特殊。它的主要使用方法有两种：**

  - 直接使用双引号声明出来的String对象会直接存储在常量池中

    `String info = "xxx"`

  - 如果不是用双引号声明的String对象，可以使用String提供的`intern()`方法。



----

- java6及以前，字符串常量池存放在**永久代** 
- java7，**将字符串常量池的位置调整到java堆中**
  - **所有的字符串都保存在Heap中，和其他普通对象一样，在调优应用时仅需要调整堆大小就可以了**
  - 使我们重新考虑使用`String.intern()`，这样就可以被回收了，否则在永久代中不好回收

- java8 元空间，字符串常量池**仍在堆中**



 

---



**为什么StringTable要调整？**

1. 永久代 permSize默认比较小，可能导致OOM，intern方法也不敢用
2. 永久代**垃圾回收频率低**——————主要原因



----

- jdk6：

`-XX:PermSize=6m -XXMaxPermSize=6m -Xms6m -Xmx6m`

![image-20210324094135518](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324094135518.png)

**永久代溢出！**

![image-20210324094305876](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324094305876.png)



- jdk8：

`-XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m  -Xms6m -Xmx6m`

**堆空间溢出！**

![image-20210324094431760](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324094431760.png)











## String的基本操作





```java
public static void main(String[] args) throws InterruptedException {

    System.out.println();//常量池中有2152个字符创
    System.out.println("1");//2153
    System.out.println("2");//2154
    System.out.println("3");
    System.out.println("4");
    System.out.println("5");
    System.out.println("6");
    System.out.println("7");
    System.out.println("8");
    System.out.println("9");
    System.out.println("10");//2162

    System.out.println("1");//2163
    System.out.println("2");//2163
    System.out.println("3");
    System.out.println("4");
    System.out.println("5");
    System.out.println("6");
    System.out.println("7");//2163
    System.out.println("8");
    System.out.println("9");
    System.out.println("10");//2163
}
```

![image-20210324094856849](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324094856849.png)

2163-2153正好10个，存入字符串常量池中



java语言规范要求**完全相同的字符串字面量**，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例

**先在字符串常量池中生成，后面再调用就不需要再次加载了**



----

![image-20210324094539417](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324094539417.png)

字符串被创建到字符串常量池中

![image-20210324100045392](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324100045392.png)





## 字符串拼接操作





1. ***常量与常量(二者都是需要时常量)***的拼接**结果在常量池**，原理是**编译期优化**
2. 常量池中不会存在相同内容的常量
3. 只要其中***有一个是变量，结果就在堆（常量池之外的堆区）中***。变量拼接的原理是***StringBuilder***
4. 如果拼接的结果调用intern()方法，则**主动将常量池中还没有的字符串你对象放入池中**，并返回此对象地址



----

```java
String s1 = "a" + "b" + "c";//三个常量的拼接结果也在常量池中，将拼接结果地址返回
String s2 = "abc";//发现常量池中有一个abc，返回引用地址
System.out.println(s1 == s2);//true
System.out.println(s1.equals(s2));//true
```

![image-20210324104641525](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324104641525.png)

**相同常量池中的引用地址**



-----



```java
String s1 = "javaEE";
String s2 = "hadoop";

String s3 = "javaEEhadoop";
String s4 = "javaEE" + "hadoop";  //编译期优化
//拼接符号的前后出现了变量，相当于在堆空间中new String()，具体内容为拼接结果:javaEEhadoop
String s5 = s1 + "hadoop"; 
String s6 = "javaEE"+s2;
String s7 = s1 + s2;

System.out.println(s3 == s4);//true
System.out.println(s3 == s5);//false
System.out.println(s3 == s6);//false
System.out.println(s3 == s7);//false
System.out.println(s5 == s6);//false
System.out.println(s5 == s7);//false
System.out.println(s6 == s7);//false

//intern()：如果常量池中有javaEEhadoop，直接返回常量池中javaEEhadoop的地址，如果不存在，在常量池中创建一个javaEEhadoop字符串，并返回其地址
String s8 = s6.intern();
System.out.println(s3 == s8);//true
```



![image-20210324105522685](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324105522685.png)

`String s5 = s1 + "hadoop"; `

拼接符左右只要出现变量，`new StringBuilder()`，调用其构造器

`aload_1`：从局部变量表中取出字符串引用，`append("javaEE")`

`ldc #3`: 从字符串常量池中得到字符串hadoop，`append("hadoop")`

对此拼接结果`StringBuilder.toString()`在堆中创建一个字符串返回。

toString() ——> **约等于**    直接 new  String("javaEEhadoop")

```java
public String toString() {
    // Create a copy, don't share the array
    return new String(value, 0, count);
}
```

**其实还是有一点区别的**

jdk1.5之前使用的是`StringBuffer`



---



```java
final String s1 = "javaEE";
final String s2 = "hadoop";

String s3 = "javaEEhadoop";
String s4 = s1 + s2;
System.out.println(s3 == s4);//true
```



![image-20210324124004765](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324124004765.png)

**如果拼接的是变量，就使用stringbuilder拼接，**

**虽然也是引用，但不是变量，而是一个 常量(final字段)**



> 字符串拼接操作不一定使用的是StringBuilder，如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，非StringBuilder方式



**final：修饰类、方法、基本数据类型、引用数据类型的“变量”，推荐使用。在编译期就已经确认下来了。**

> **因为final在编译的时候就会分配了，类加载的准备prepare阶段会显式初始化**



显而易见：

![image-20210324124801897](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324124801897.png)





----



StringBuilder通过"+"拼接和append添加字符串所耗时间对比：**append快了非常多**！！！

- 拼接符+：
  - 意味着**每次循环都会创建一个StringBuilder**，**再进行tostring方法 ** StringBuilder和String各创建一个对象。非常耗时
  - 内存中由于创建了较多的StringBuilder和string对象，内存占用过多，进行GC需要花费时间

- append：
  - 自始至终只创建过一个StringBuilder对象
  - **改进空间：空参构造——>需要不断扩容！如果基本确定要添加的字符串长度，通过构造器   直接创建足够大容量的char[]，可以更快！**









## intern()的使用



```java
public native String intern();
```



![image-20210324130017258](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324130017258.png)



- 如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串**放入常量池中并返回其引用**。
  - `String info = new String("xxx").intern();`

- 如果在任意字符串上调用String.intern()方法，那么其**返回结果 所指向的那个string实例**，必须和**直接以常量形式出现的字符串实例完全相同**。下面表达式必定为true：
  - `("a" + "b" + "c").intern() == "abc";`



如何保证变量s指向的是字符串常量池中的数据呢？

1. `String s = "xxx"` 字面量定义的方式
2. `String s = new String("Xxx").intern()`   调用intern()方法



**Interned String就是确保字符串在内存里还有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意：这个值会被放在字符串内部池：String intern pool**











-------



### 面试题





![image-20210324135510504](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324135510504.png)





```
String str = new String("ab");

 
 0 new #2 <java/lang/String>
 3 dup
 4 ldc #3 <ab>
 6 invokespecial #4 <java/lang/String.<init>>
 9 astore_1
10 return
```

创建了两个对象：

- 字符串常量池中的字符串“ab”    `ldc #3 <ab>`
- new关键字在   堆中创建 的String对象





```
String s = new String("a") + new String("b");

 0 new #2 <java/lang/StringBuilder>
 3 dup
 4 invokespecial #3 <java/lang/StringBuilder.<init>>
 7 new #4 <java/lang/String>
10 dup
11 ldc #5 <a>
13 invokespecial #6 <java/lang/String.<init>>
16 invokevirtual #7 <java/lang/StringBuilder.append>
19 new #4 <java/lang/String>
22 dup
23 ldc #8 <b>
25 invokespecial #6 <java/lang/String.<init>>
28 invokevirtual #7 <java/lang/StringBuilder.append>
31 invokevirtual #9 <java/lang/StringBuilder.toString>
34 astore_1
35 return

```

1. new StringBuilder()

2. new String("a")

3. 字符串常量池 “a”

4. new String("b")

5. 字符串常量池 “b”

6. **StringBuilder.toString()** 

   -  这个方法里面会new  String("ab") 

   ```
   public String toString() {
   // Create a copy, don't share the array
   return new String(value, 0, count);
   }
   
   
    0 new #80 <java/lang/String>
    3 dup
    4 aload_0
    5 getfield #234 <java/lang/StringBuilder.value>
    8 iconst_0
    9 aload_0
   10 getfield #233 <java/lang/StringBuilder.count>
   13 invokespecial #291 <java/lang/String.<init>>
   16 areturn
   ```

   ***此时字符串常量池中不存在“ab”***——>主要区别

因为：

**这时候的new String构造方法使用的是char[]数组，并不是直接使用的"ab"字符串常量，所以不会在字符串常量池中创建一个“ab”字符串**

![image-20210324141004225](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324141004225.png)







---

再来看这个面试题：

![image-20210324135315421](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324135315421.png)



- jdk  6： 

false

false

- jdk  7/8：

false

true



1. 造了两个对象，返回在堆中的引用。

   `s.intern()`：调用此方法之前，***在字符串常量池中已经存在了“1”***

   这两个地址明显不是一个地址：**一个是堆空间中的地址，一个是字符串常量池中的地址**



2.  `String s3 = new String("1") + new String("1");`s3变量记录的地址是new String("11")返回的堆空间的地址引用

   **执行完这一条后，字符串常量池中   不存在“11”**

   `s3.intern();`在字符串常量池中生成“11”

   `String s4 = "11"; ` s4：使用的是上一行代码执行时，在字符串常量池中生成的“11”



**关键在intern()**如何理解：

- 在jdk6中：创建新的对象“11”，也就有新的地址，此时和上面刚创建的s3地址不同

- 在jdk7/8中：常量池放到了堆空间中，字符串常量池中**不再重复创建“11”**，此时字符串常量池中放的就是**指向堆空间中new String("11")的这个地址引用**

  当 `String s4 = "11"`执行时，去字符串常量池中寻找字符串“11”，找到的是对   堆空间中new的“11”的引用，返回。所以是一个引用地址





![image-20210324142828853](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324142828853.png)



**字符串常量池中不再保存数据了，保存一个引用即可**

![image-20210324142920321](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324142920321.png)



---

变形：

![image-20210324144944984](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324144944984.png)

这时候就是false

`String s4 = "11";`   **这时候在字符串常量池中不存在“11”，接下来生成一个字符串常量“11”，这时候并不是一个引用。**

`s3.intern()`  发现常量池中已经存在“11”，那么就什么也不做。s3还是指向堆中new的对象!

如果：`s5 = s3.intern()`  那么这时候s5 == s4





----

总结String的intern()的使用：

- jdk1.6中，将这个字符串对象尝试让如字符串常量池
  - 如果常量池中有，则并不会放入，返回已有的常量池中的对象的地址
  - 如果常量池中没有，**会把此对象复制一份，放入常量池，并返回常量池中的对象地址**
  - **（如果没接收引用那么就还是指向的堆中对象地址）**

- jdk1.7起，将这个字符串对象尝试放入常量池
  - 如果常量池中有，则并不会放入，返回已有的常量池中的对象的地址
  - 如果没有，**则会把此对象的引用地址复制一份，放入常量池，并返回常量池中的引用地址**



---



### intern练习：





![image-20210324150741629](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324150741629.png)



此时在常量池中存放的是堆中String的引用地址，所以都是相同的地址

![image-20210324150729616](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324150729616.png)



先在常量池中创建一个“ab”常量，s2接收的是返回的常量池中的地址，s仍然是堆中地址

![image-20210324150555407](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324150555407.png)



---



练习2：



在jdk8中是true。**常量池中存放的是堆中的字符串实例“ab”的引用地址**

![image-20210324151025023](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324151025023.png)



**这样构造  字符串常量池中已经生成“ab”**，而上面的操作**不会在字符串常量池中生成“ab”**

那么s1指向的就是堆中地址，而s2指向的是常量池中的地址

false

![image-20210324151222292](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324151222292.png)





----



### intern效率测试



空间角度：  

![image-20210324153342245](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324153342245.png)



- 不使用intern（）

内存使用：

![image-20210324153725421](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324153725421.png)

**一千万左右的String实例个数**



- 使用intern()

**时间快了很多**

**这时候只有一百万左右的String实例**

![image-20210324154023350](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324154023350.png)

***节约大量内存空间。***



> 当调用intern方法时，也会先在堆空间new一些String对象，但都将**他们的引用放入了常量池中（不会重复）**
>
> 当再次new String().intern()的时候，先创建一个对象出来，再去常量池中寻找，直接返回**常量池中的实例**——>**常量池中的实例是堆中实例的引用**
>
> 前面new的这些对象由于用不到（没有对它们的引用），会进行垃圾回收



**对于程序中大量存在的字符串，尤其存在很多重复字符串时，使用intern()方法可以节省内存空间**



> 大的网站平台，需要内存中存储大量的字符串，比如社交网站，很多人都存储“北京市”，“海淀区”等信息，这时候如果字符串都调用intern()方法，就会明显降低内存的大小











## StringTable的垃圾回收 





`-XX:+PrintStringTableStatistics`打印字符串常量池统计信息



![image-20210324162043397](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324162043397.png)

![image-20210324161713816](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324161713816.png)

↓   100次：

![image-20210324161724782](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324161724782.png)

10000次：

![image-20210324161817856](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324161817856.png)

100000次：。。。

**进行了垃圾回收**

![image-20210324161849590](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324161849590.png)

不到10万：说明进行了垃圾回收

![image-20210324161904777](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324161904777.png)













## G1中的String去重操作



字符串常量池中本身就不存在重复的数据



```
String s = new String("xxx");
String s2 = new String("xxx");
String s3 = new String("xxx");
```

去重指的是：**在堆空间中String实例  的value（char[] / byte[]）**



对许多java应用做的测试得出以下结果：

- 堆存活数据集合里面String对象占了25%
- 堆存活数据集合里面重复的String对象有13.5%
- String对象的平均长度是45



许多大规模的java应用的瓶颈在于内存，这些类型的应用里面，**java堆中存活的数据集合差不多25%是String对象**，这里面差不多一般的String对象是重复的=> `s1.equals(s2)` value数组 值相等。

**堆上存在重复的String对象必然是一种内存的浪费**。这个项目将在**G1垃圾收集器**中实现自动持续对重复的String对象进行去重，避免浪费内存



![image-20210324163011933](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324163011933.png)





![image-20210324163058731](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324163058731.png)







## String的两种初始化方式的区别



```java
String a = "str1";
```

直接赋值：如果常量池中没有"str1"这个字符串常亮，则直接赋值在常量池中创建一个对象。

```java
String b = new String("str2")
```

通过new出来的：在如果常量池中没有没有"str2"这个字符串常量，则创建两个对象（一个是new String("str2")在**<u>堆中</u>**用来存储str2的地址值，另外一个是**<u>字符串常量"str2"在常量池</u>**中）。


```java
String c = "abc";
String d = "abc";
String e = new String("abc");
System.out.println(c == d);	//true
System.out.println(c == e);	//false
```

解析：
1."=="运算符比较的是地址值。
2.c和d都是指向常量池中的字符串常量abc， e指向的则是堆中的对象new String("abc");再指向常量池中的字符串常量abc。







# 垃圾回收概述





## 什么是垃圾



![image-20210324193232403](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324193232403.png)



- 垃圾收集，不是java语言的伴生产物
- 三个经典问题：
  - 哪些内存需要回收？
  - 什么时候回收？
  - 如何回收？

- 垃圾收集机制是java的招牌能力，**极大地提高了开发效率**。正在不断演进中。**面试热点！！**



面试题：



![image-20210324193643292](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324193643292.png)



![image-20210324193743370](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324193743370.png)



---

- **什么是垃圾？**
  - **垃圾是指在运行程序中没有任何指针指向的对象**，这个对象就是需要被回收的垃圾。（聚合量）
- 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会**一直保留**到应用程序结束，**被保留的空间无法被其他对象使用，甚至可能导致内存溢出**。



----

磁盘碎片整理：

![image-20210324194435082](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324194435082.png)







## 为什么需要GC



- 对于高级语言，如果不进行垃圾回收，**内存迟早都会被消耗完**，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不进行打扫
- 除了释放没用的对象，垃圾回收也可以**清除内存里的记录碎片**，碎片整理将所占用的堆内存**移到堆的一端**，**以便jvm将整理出的内存分配给新的对象**
- 业务越来越庞大、复杂，用户越来越多，**没有GC就不能保证应用程序的正常进行**。而经常造成STW的GC又跟不上实际的需求，才会不断尝试对GC进行优化









## 早期垃圾回收



![image-20210324195223046](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324195223046.png)



![image-20210324195449254](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324195449254.png)





## java垃圾回收机制



- 自动内存管理，无需开发人员手动参与内存的分配与回收，**这样降低内存泄露和内存溢出的风险**
  - 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让人头疼不已
- 自动内存管理机制，将程序员从繁重的内存管理中释放出来，**可以更专心地专注于业务开发**





- 对于开发人员，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么将会是一场灾难，**弱化java开发人员在程序出现内存溢出时定位问题和解决问题的能力**

- **了解jvm的自动内存分配和内存回收原理**就显得非常重要，只有在真正了解jvm是如何管理内存后，我们才能够在遇见OOM时，快速地**根据错误异常日志定位问题和解决问题**
- 当需要排查各种**内存溢出、内存泄漏**问题时，当**垃圾收集成为系统达到更高并发量的瓶颈**时，我们就必须对这些“自动化”的技术 **实施必要的监控和调节**









![image-20210324202401731](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324202401731.png)



垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收

**其中，java堆是垃圾回收的工作重点**

- **频繁收集young区**
- **较少收集old区**
- **基本不动perm区（元空间）**





 











# 垃圾回收相关算法





## 标记阶段：引用计数算法





----

**对象存活判断**

- 在堆里存放着几乎所有的java对象实例，在GC执行垃圾回收之前，**首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象**。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，这个过程：**垃圾标记阶段**



- 如何标记一个死亡对象？**当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡**
- 判断对象存活一般有两种方式：**引用计数算法  &  可达性分析算法**





---



**引用计数算法**



References Counting

**每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况**



- 对于一个对象A，只要有任何一个对象引用了A，A的引用计数器就+1，当引用失效时，-1。当A的引用计数器的值为0，即表示对象A**不可能再被使用**，可进行回收（**最后一个引用该地址的对象已经不再对其引用，那么就没有任何对象可以再引用它了->类似内存泄漏，找不到它的地址了**）

优点：

- **实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性**



缺点：

- 需要单独的字段存储计数器，增加了 **存储空间的开销**
- 每次赋值都需要更新计数器，伴随着加法和减法操作，增加了**时间开销**
- **无法处理循环引用的情况**，**致命缺陷！**导致在java的垃圾回收器中没有使用这类算法





循环引用： 

各自的counter都没到0，所以不会触发垃圾回收，**但当前没有对象指向其中任何一个，无法再使用它们了，内存泄漏！**

![image-20210324204814551](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324204814551.png)



内存泄漏的例子：别举这个例子。。因为java没有选择这种算法，不会出现这种内存泄漏行为



----



举例：

![image-20210324205221207](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324205221207.png)



按照引用计数算法，这两个对象还各自都有一个引用指向它们，没法回收

![image-20210324205333669](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324205333669.png)

打印GC细节：

没有进行垃圾回收：system.gc()

![image-20210324205909974](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324205909974.png)

**进行了垃圾回收，*那么证明：java使用的一定不是引用计数算法***

![image-20210324205928221](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324205928221.png)







- python语言使用了引用计数算法 
- 看场景，可以提高吞吐量
- java没有选择引用计数，因为存在一个基本的难题，**很难处理循环引用关系**
- python如何解决循环引用？
  - 手动解除
  - 使用弱引用weakref，标准库，用来解决循环引用









## 标记阶段：可达性分析算法



**根搜索算法  /  追踪性垃圾收集**



- 可达性分析算法不仅同样具备实现简单和执行高效等特点，**可以有效地解决引用计数算法中循环引用的问题，防止内存泄漏的发生**

- 可达性分析就是java、C#选择的。**追踪性垃圾收集Tracing Garbage Collection**



**所谓GC Roots 根集合就是一组必须活跃的引用**

思路：

- 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式 **搜 索被根对象集合所连接的目标对象*是否可达***
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为 **引用链Reference Chain**

- 如果目标对象**没有任何引用链相连**，则是**不可达的**，意味着该对象已经死亡，可以标记为垃圾对象
- 在可达性分析算法中，只有能够**被根对象集合直接或者间接连接的对象才是存活对象**





![image-20210324210817046](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324210817046.png)



---

**GC Roots**

GC Roots包括以下几类元素：

- 虚拟机**栈中引用的对象（局部变量表中）**

  - 各个线程被调用的方法中使用的**参数、局部变量**等

- **本地方法栈内**引用的对象

  - 就是程序中**native本地方法**引用的对象。

- 方法区/堆 中**类静态属性**引用的对象

  - java类的**引用类型静态变量**

    

  ![image-20210325105726635](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325105726635.png)

- 方法区中**常量   引用的对象**

  - **字符串常量池里的引用**
  - 在类中使用final声明的**引用类型**字段（**final修饰 引用类型的变量，在对其初始化之后便不能再让其指向另一个对象。**）

- 所有被同步锁**synchronized**持有的对象

- java虚拟机内部的引用
  
  - 基本数据类型对应的Class对象，常驻的异常对象，系统类加载器AppClassLoader
- 翻译jvm内部情况的JMXBean，JVMTI注册的回调、本地代码缓存等



GC Roots指向堆中对象，该对象还指向另一个对象，形成一条链，这一条链都不会被回收。

如果是没有被Roots指向的对象  指向了 **引用链中的某个对象**，那么该对象同样是需要被回收，垃圾~

![image-20210324211923789](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324211923789.png)



----

**临时加入**

可能一个在老年代中的对象a指向新生代中的对象b，但a没有被root所连接，当只回收新生代时（不回收老年代），可以将a也加入gc roots，这样a和b就不会被回收

- **单独看heap：从roots出发，即从栈（堆外）到heap的引用链不可达的   heap中的其他对象都是垃圾**——>整堆回收 

- **单独看新生代：从roots出发，&  从新生代外部的（如老年代）到新生代内部的引用无法到达的   新生代中的其他对象，都是垃圾**——>年轻代回收

![image-20210324212130375](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210324212130375.png)

**不在堆空间的变量，但引用指向堆空间。那么就是一个root**



如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能**保证一致性**的快照中进行。不然**分析结果的准确性**就无法保证，**分析期间，*对象的引用关系不能有改变***

这点是导致GC进行时必须“Stop the world”的一个重要原因

- 号称几乎不会发生停顿的CMS收集器中，**枚举根节点时也是必须要停顿的**













## 对象的finalization机制



- java语言提供了对象终止的机制（finalization）来允许开发人员提供  **对象被销毁之前的自定义处理逻辑** 

- 当垃圾回收器发现没有引用指向一个对象，即：**垃圾回收此对象之前，总会先调用这个对象的finalize()方法**
- finalize()方法允许在子类中进行**重写**，**用于在对象被回收时进行资源释放**。通常在这个方法中进行一些资源释放和清理的工作，关闭文件、套接字和数据库连接等





- 永远不要主动调用某个对象的finalize（）方法，**应该交给垃圾回收机制调用**，理由：
  - 在finalize（）时可能会导致对象复活
  - finalize（）方法的**执行时间没有保障**，**完全由GC线程决定，**极端情况下，若不发生GC，则finalize方法将没有执行机会
  - 一个糟糕的finalize会严重影响GC的性能

- finalize（）方法与CPP中的析构函数比较相似，但是java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于cpp的析构函数
- 由于finalize（）方法的存在，**虚拟机中的对象一般处于三种可能的状态**



---

如果从所有根节点都无法访问到某个对象，说明对象已经不再使用了，一般来说需要被回收。但事实上，它们处于“缓刑”阶段。**一个无法触及的对象可能在某一个条件下“复活”自己**。那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态：

- **可触及的**：从根节点开始，可以到达这个对象
- **可复活的**：对象的所有引用都被释放，但是**对象有可能在finalize（）中复活**
- **不可触及的**：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 **finalize（）只会被调用一次**

以上3种状态中，是由于finalize（）方法的存在  进行的区分。只有在对象不可触及时才可以被回收



---

**具体过程：**

判定一个对象objA是否可以被回收，至少要经理两次标记过程：

1. 如果对象objA到 GC Roots没有引用链，则进行第一次标记
2. 进行筛选，判断此对象是否有必要执行finalize（）方法
   1. 如果对象objA**没有重写finalize（）方法**，或者finalize（）方法**已经被虚拟机调用过**，则虚拟机视为“没有必要执行”，**objA被判定为不可触及的**
   2. 如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到**F-Queue队列**中，由一个**虚拟机自动创建的、低优先级的finalizer线程**触发其finalize（）方法执行
   3. **finalize（）方法是对象逃脱死亡的最后机会**，稍后GC会对F-Queue队列中的对象进行**第二次标记**，如果**objA在finalize方法中与引用链上的任何一个对象建立了联系**，那么在第二次标记时，objA会被**移除“即将回收”集合**。之后对象会再次出现没有引用存在的情况，在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态。**一个对象的finalize方法只会被调用一次**





![image-20210325095944452](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325095944452.png)



```java
public class finalizeTest {
    public static finalizeTest obj;//类标量，属于GC Roots

    //此方法只能被调用一次
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("调用finalize()方法");
        //当前待回收的对象在finalize()方法中与引用链上的一个对象建立了联系
        obj = this;//将类的静态变量obj指向当前实例this，实例对象就不再没有引用了，重新建立引用，使其不被回收，对象复活！！！
    }

    public static void main(String[] args) throws InterruptedException {
        obj = new finalizeTest();
        obj = null;

        System.gc();//调用垃圾回收器
        System.out.println("第一次gc！");

        //因为finalizer线程优先级低，等待它
        Thread.sleep(2000);

        if(obj == null){
            System.out.println("obj is dead");
        }else{
            System.out.println("obj is still alive");
        }
        System.out.println("第二次gc！");
        obj = null;
        //finalize()方法只能被调用一次
        System.gc();
        Thread.sleep(2000);
        if(obj == null){
            System.out.println("obj is dead");
        }else{
            System.out.println("obj is still alive");
        }
    }
}
```



![image-20210325102834490](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325102834490.png)









## MAT与JProfiler的GC Roots溯源



MAT是Memory Analyzer的简称，是一款功能强大的java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况

基于eclipse开发 





**获取dump文件**

方式一：命令行使用jmap

方式二：使用jvisualVM导出

- 捕获的heap dump是一个临时文件，关闭jvisualVM后自动删除，若要保留，需要将其保存

  ![image-20210325121743020](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325121743020.png)

  ![image-20210325121751801](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325121751801.png)





```java
public static void main(String[] args) throws InterruptedException {
    List<Object> numList = new ArrayList<>();
    Date birth = new Date();

    for(int i = 0; i < 100; i++){
        numList.add(String.valueOf(i));
        Thread.sleep(10);
    }
    System.out.println("数据添加完毕！");

    new Scanner(System.in).next();
    numList = null;
    birth = null;

    System.out.println("numList，birth已置空，请操作！");
    new Scanner(System.in).next();

    System.out.println("结束");
}
```



![image-20210325122349892](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325122349892.png)

**生成快照**

![image-20210325122304791](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325122304791.png)







在MAT中打开dump

![image-20210325122844074](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325122844074.png)



![image-20210325123003723](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325123003723.png)



![image-20210325123138100](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325123138100.png)

**此时两个对象都被回收了！**

![image-20210325123254703](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325123254703.png)





----

**往往需要查找某个引用对象这一个引用链上的GC Roots——Gc溯源**



使用Jprofiler：



![image-20210325124200675](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325124200675.png)



![image-20210325124153190](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325124153190.png)





![image-20210325124427442](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325124427442.png)







**使用jprofiler分析OOM**



`-XX:+HeapDumpOutOfMemoryError`发送OOM时生成dump文件



**分析大对象**

![image-20210325124918304](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325124918304.png)









## 清除阶段：标记-清除算法



当成功区分出内存中存活对象和死亡对象后，进行垃圾回收。

三种垃圾收集算法：

- 标记-清除算法 Mark-Sweep
- 复制算法Copying
- 标记-压缩算法Mark-Compact 





---

**背景：**

标记-清除算法，非常基础和常见的垃圾收集算法

执行过程：

当堆中的有效内存空间被耗尽的时候，就会停止整个程序（stop the world），然后进行两项工作：

- **标记**：Collector从引用根节点开始遍历，**标记所有  *被引用*  的对象**，一般是在**对象的Header对象头中**记录为**可达对象**。从根节点也**只能找得到可达对象**，没法找到垃圾对象。
- **清除**：collector对堆内存从头到尾进行**线性的遍历**，如果发现某个对象在其Header中**没有标记为可达对象**，则将其回收。





![image-20210325125602809](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325125602809.png)

清除阶段，将没标记的垃圾对象清除。



缺点：

- 效率不高
- 在进行GC的时候，需要停止整个应用程序，导致用户体验差
- **这种方式清理出的空闲内存是不连续的**， **产生内存碎片**，需要维护一个 **空闲列表**

![image-20210325130246944](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325130246944.png)



**何为清除？？**

- 所谓的清除**并不是真正的置空**，而是把**需要清除的对象地址保存在空闲的地址列表**里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放，不够就OOM



 





## 清除阶段：复制算法

为了解决标记清除算法在效率方面的缺陷



将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将**正在使用的内存中的存活对象复制到未被使用的内存块中**，之后**清除正在使用的内存块的所有对象**，交换两个内存的角色，最后完成垃圾回收

  

**分为两块区域——A，B，将A中的正在使用的对象复制到B中连续空间上，然后整个清理A区，下一次垃圾回收再从B->A，整个清理B区**

![image-20210325130925373](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325130925373.png)

**都整理到连续的区域中，剩下的区域都为空，可以更好的为大对象提供空间**

类似新生代中的S0、S1区



优点：

- 没有标记和清除的过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现 **碎片**，**指针碰撞方式**



缺点：

- 需要两倍的内存空间
- 对于G1这种分拆成为大量region的GC，**复制**而不是移动，意味着GC需要维护region之间**对象引用关系（对象引用地址需要调整）**，不管是内存占用还是时间开销也不小



**如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行**

希望存活的对象很少，垃圾很多，这样该算法才算比较理想。



**新生代   朝生夕死，很适合**

![image-20210325135051696](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325135051696.png)

**老年代就不适合了。回收的效率很差。需要复制的很多。**





## 清除阶段：标记-压缩算法



**标记-整理  Mark Compact**



复制算法的高效性建立在存活对象少、垃圾对象多的前提下。在新生代经常发生，但是在老年代，更常见的情况是大部分的对象都是存活对象，复制的成本很高。**基于老年代垃圾回收的特性，需要使用其他的算法**

标记清除算法会产生很多内存碎片。**需要整理碎片  for  大对象**



----

第一阶段和标记清除算法一样，从根节点开始**标记所有被引用对象**

第二阶段**将所有的存活对象压缩到内存的一端，按顺序排放**

之后，**清理边界外的所有空间**

![image-20210325135423406](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325135423406.png)



标记压缩算法的最终效果等同于标记清除算法执行完成后，再进行一次内存碎片整理，**标记-清除-压缩算法**



 本质差异：标记清除算法是一种**非移动式**的回收算法，标记压缩是**移动式的**，**是否移动回收后的存活对象是一项优缺点并存的风险决策**



被标记的对象按照内存地址依次排列，未被标记的内存会被清理掉。

当我们需要给**新对象分配内存时**，JVM只需要持有一个**(空闲)内存的起始地址**即可，比维护一个空闲列表显然少了许多开销

**使用指针碰撞来分配内存**

![image-20210325140223903](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325140223903.png)







优点：

- 消除了标记清除算法的内存区域分散的缺点
- 消除了复制算法中，内存减半的高额代价

缺点：

- 标记整理算法**效率低**于复制算法

- 移动对象的同时，如果对象被其他对象引用，则还需要**调整引用的地址**
- 移动过程中，需要**全程暂停用户应用程序**，stw







## 对比三种算法



![image-20210325140825170](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325140825170.png)





最优算法？？

无，没有最好的算法，只有最适合的算法。

具体问题具体分析



## 分代收集算法



没有一种算法可以代替其他算法，有各自的优势和特点



分代收集算法：不同的对象的生命周期是不一样的，因此，**不同生命周期的对象可以采取不同的收集方式，以便提高回收效率**。把java堆分为新生代和老年代，可以根据各个年代的特点使用不同的回收算法。

http请求中的session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。还有一些对象，运行中生成的临时变量，生命周期会比较短，如String对象，有些对象甚至只用一次即可回收



**目前几乎所有GC都是采用分代收集 Generation Collecting算法执行垃圾回收的**



在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点

**复制算法 浪费的只是一个survivor区域(8:1:1) **

![ ](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325142625159.png)



以HotSpot中的CMS回收器为例，**CMS是基于标记清除**实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于**标记整理**算法的**Serial Old回收器**作为不唱做事：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用**Serial Old执行Full GC以达到对老年代内存的整理**





## 增量收集算法、分区算法



---

**增量收集算法**

上述算法，在垃圾回收过程中，应用软件将处于stw状态，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，**严重影响用户体验或者系统的稳定性**

实时垃圾收集算法

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，让垃圾收集线程和应用程序线程交替执行。**每次，垃圾收集线程*只收集一小片区域的内存空间*，接着切换到应用程序线程。依次反复，直到垃圾收集完成**

增量收集算法的基础仍是传统的标记-清除和复制算法。**通过对==线程间冲突==的妥善处理，允许垃圾收集线程以     分阶段的方式完成标记、清理、复制工作**





**缺点：**

在垃圾回收过程中，**间断性**执行了应用程序代码，所以能**减少系统的停顿时间**。但是，因为线程切换和上下文转换的消耗，会使得**垃圾回收的总体成本上升**，**造成系统吞吐量的下降**



-----



**分区算法：**



相同条件下，堆空间越大，一次GC时所需要的时间就越长，停顿时间也越长，控制GC产生的停顿时间——**将一块大的内存区域分隔成多个小块，根据  <目标的停顿时间>  ，每次合理地回收  <若干个小区间>  ，而不是整个堆空间，从而减少一次GC所产生的的停顿**



分代算法将**按照对象的生命周期长短**分成两个部分，分区算法将整个堆空间划分成**连续的不同小区间**

每一个小区间都**独立使用，独立回收**，可以**控制一次回收多少个小区间**



![image-20210325144858167](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325144858167.png)



**这些知识基本的算法思路，实际GC的过程要复杂的多，现在都使用复合算法，同时考虑到并行和并发**





# 垃圾回收相关概念









## System.gc()的理解



- 默认情况下，通过`System.gc()`或者`Runtime.getRuntime().gc()`(->native方法)   的调用，**会显式触发Full GC**，同时对老年代和新生代进行回收，释放被丢弃占用的内存

- `System.gc()`调用附带一个免责声明：无法保证对垃圾收集器的调用
- JVM实现者可以通过`System.gc()`调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是**自动进行**的，**无需手动触发，否则就太过麻烦了**。在一些特殊情况下，如我们正在编写一个性能基准，可以在运行期间调用`System.gc()`



**只能是提醒JVM的垃圾回收器执行gc，不能保证一定会"立马"回收并且调用finalize()方法.......   如果将主线程sleep一下，是可以的**



`System.runFinalization()`强制调用失去引用对象的finalize()方法

![image-20210325160528358](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325160528358.png)





----

栗子：

![image-20210325160618004](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325160618004.png)

![image-20210325160700914](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325160700914.png)

![image-20210325160711645](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325160711645.png)



查看GC详细信息：

1. 经过YGC，新生代的对象没有被回收掉；进行Full GC后，将对象放到了老年代中

2. YGC ——在新生代中就回收掉了垃圾对象。

3. **代码块？不会被回收。**没有释放掉，放到了老年代中

   **当前方法的局部变量表中放入过该对象引用，虽然看不到，但还是占用着局部变量表中index=1的slot，仍然是指向着该对象的，不会被回收**

4. 新建一个局部变量**替换**掉   代码块中对象引用在**局部变量表中的slot，这时没有引用buffer就不在局部变量表中——>同时也不在GC Roots中，那么指向的数组对象没有在引用链中，即不可达，也就会被当做垃圾对象进行回收**，这时就没有引用指向对象了。会进行回收

5. 会被回收

   ![image-20210325162124711](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325162124711.png)

   在调用方法后，方法1的栈帧已经弹出jvm栈，不在GC Roots中，是**不可达的**,会被当成垃圾进行回收









## 内存溢出与内存泄漏



---

内存溢出OOM：

- 内存溢出相对于内存泄漏，内存溢出也是引发程序崩溃的罪魁祸首之一
- 由于GC一直在发展，所以一般情况下，除非应用**程序占用的内存增长速度非常快**，造成垃圾回收已经**跟不上内存消耗的速度**，否则不太容易出现OOM的情况
- 多数情况，GC会进行各种年龄段的垃圾回收，实在不行就Full GC，这时候会回收大量的内存，共应用程序继续使用
- javadoc对OOM的解释是：***没有空闲内存，并且垃圾收集器也无法提供更多内存***





1. **java虚拟机的对内存设置不够**

可能存在内存泄漏问题，也可能是堆的大小不合适 -Xms  -Xmx

2. **代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）**

jvm对永久代垃圾回收（常量池、不需要的类型）非常不积极，当我们不断添加新类型的时候，永久代出现OOM非常多见。类似intern字符串缓存占用太多空间，也会导致OOM :PermGen space

元数据区引入，方法区的内存不那么小了，OOM:Metaspace



在抛出OOM之前，**通常垃圾收集器会被触发，尽其所能去清理空间**

- 引用分析机制中，jvm回去尝试回收 **软引用指向的对象**
- java.nio.Bits.reserveMemory()方法中，能看到System.gc()会被调用，以清理空间



也不是在任何情况下垃圾收集器都会被触发：分配一个超大对象，超过堆的最大值。。。jvm判断出垃圾收集不能解决这个问题，直接抛出OOM



---



**内存泄漏 Memory Leak**

**只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏**



实际一些不太好的实践会**导致对象的生命周期变得很长（将一次性对象定义为成员/静态变量）**甚至导致OOM，也可以叫做 **宽泛意义上的内存泄漏**



尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的**可用内存就会被逐步蚕食，直至耗尽所有内存**，最终出现OOM异常，导致程序崩溃



这里的存储空间并不是指物理内存，而是指**虚拟内存（jvm内存）大小**，这个虚拟内存大小取决于磁盘交换区设定的大小

 



![image-20210325173628737](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325173628737.png)

**虽然销毁了对象的引用，但还有被忘掉的引用。。。但我们此时并不想用他们了，但还有一个引用还藕断丝连.....导致内存泄漏！**



不要举下面这个内存泄漏的栗子↓ **因为gc使用的不是引用计数算法，可达性分析算法并不会出现这种类型的内存泄漏 **

![image-20210325174014432](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325174014432.png)



- **单例模式**：

单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有**对外部对象的引用**的话，那么这个外部对象是不能被回收的，会导致内存泄漏的产生



- **一些提供close的资源未关闭导致内存泄漏：**

数据库连接datasource.getConnection()，网络连接socket和io连接必须手动close，**否则是不能被回收**的。这个引用***一直连接着外部资源，无法被释放***









## Stop The World



GC事件发生过程中，产生应用程序的停顿，**停顿产生时整个应用程序线程都会被暂停，没有任何响应**，类似卡死，这个停顿称为STW

- 可达性分析算法中枚举根节点GC Roots会导致java执行线程停顿
  - 分析工作必须在一个确保 **一致性的快照中进行**
  - **一致性：**   指分析期间整个执行系统看起来像被冻结在某个时间点上
  - **如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证**

- 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，***所以需要减少STW的发生***



- STW事件和采用哪款GC无关，所有的GC都有这个事件
- 哪怕是G1也不能完全避免STW的发生，只能说**垃圾回收器越来越优秀，回收效率越来越高，缩短暂停时间**
- STW是jvm在 **后台自动发起和自动完成**的，在用户不可见的情况下，把用户正常的工作线程全部停掉
- 开发中不要使用System.gc()；会导致STW的发生



 





## 垃圾回收的并行与并发



并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段，在这几个时间区间之间来回切换，让用户感觉是多个应用程序同时在进行

![image-20210325181422115](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325181422115.png)



当系统cpu有多个核/多个cpu，同时执行多个进程，互不抢占CPU资源，可以同时进行，**称之为并行**

**决定并行的因素不是CPU的数量，而是CPU的核心数量**

![image-20210325181832197](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325181832197.png)



![image-20210325181931933](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325181931933.png)



---

**垃圾回收的并发与并行**

- 并行：**多条垃圾收集器线程并行**工作，但此时**用户线程仍处于等待状态**

  ParNew, Parallel Scavenge, Parallel Old

- 串行

  - 单线程执行
  - 如果内存不够，则程序暂停，**启动jvm垃圾回收器进行垃圾回收，回收完再启动程序的线程**



![image-20210325182333900](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325182333900.png)



- 并发：**用户线程和垃圾收集线程同时执行（一段时间内，不是同一时间点）（不一定是并行的，交替执行），垃圾回收线程在执行时不会停顿用户程序的运行**
  - 用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU线程上，一旦需要进行垃圾收集，就STW（**一定需要出现STW**）
  - CMS，G1



- 并发关键在于**不会一次性停顿太长时间**，传统的垃圾收集器stw直接停死，所有工作线程都需要等到垃圾收集的 标记、清除阶段结束后，才能继续执行工作线程，CMS **并发** 收集器 **也会出现stw，但在并发标记阶段可以和用户线程共同运行，并且 <并发清理阶段>  也是和用户线程并行运行**，只有在必需stw的阶段才进行stw，其它阶段垃圾收集线程都可以和用户线程并发执行

> 为啥说CMS是并发收集器呢？
>
> 因为耗时最长的  并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作，**所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行**

![image-20210325182521041](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325182521041.png)









## 安全点与安全区域



程序执行时并不是在任何时间点都能停顿下来执行GC，只有在特定的位置才能停顿洗下来开始GC，**安全点 SafePoint**

安全点选择很重要，**如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题**。

大部分指令的执行时间都非常短暂，根据 "**是否具有让程序长时间执行的特征**"  为标准。

比如：***选择一些执行时间较长的指令作为 安全点***，如 **方法调用、循环跳转和异常跳转等**



如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？

![image-20210325183658660](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325183658660.png)

 **主动式中断**

---



**安全区域 Safe Region**

**对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的**

![image-20210325183720083](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325183720083.png)



![image-20210325184022423](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325184022423.png)













## 再谈引用：强引用



描述这样一类对象：当内存空间足够时，则保留在内存中，如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象



> 面试题：
>
> **强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？**

**这四种引用强度一次逐渐减弱**

除强引用之外，其他3种引用均可以在java.lang.ref包中找到它们的身影，直接使用：

![image-20210325184414740](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325184414740.png)

软引用：内存满了后才会回收 

 弱引用：无论内存是否足够，只要进行垃圾收集，就回收

![image-20210325185222243](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325185222243.png)







---

**强引用**： —— **不回收**



![image-20210325185513080](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325185513080.png)

可触及的 / 可达的：从 GC Roots开始可以到达

只要强引用对象是可达的，那么即使调用System.gc()，也无法回收掉。

直到没有任何引用指向 / 不可达，才会进行回收



---

- 强引用可以**直接访问目标对象**
- 强引用所指向的对象**在任何时刻都不会被系统回收**，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象
- 强引用可能**导致内存泄漏**









## 再谈引用：软引用

——内存不足即回收



**在第一次回收（不可触及的对象）后，还不够，那么就回收软引用。**

![image-20210325190942293](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325190942293.png)

**软引用不会导致OOM，只会是强引用导致的OOM**



软引用：当**内存足够时，不会**回收软引用可达的对象；当内存不够时，才会**回收软引用的可达对象**



----

![image-20210325191330761](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325191330761.png)

这种创建方法：既有强引用还有软引用。

 



![image-20210325192720832](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325192720832.png)



![image-20210325192915711](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325192915711.png)

执行完**GC后还是没有被销毁**，此时被软引用使用，并且**堆空间内存足够**，就不会回收

内存不够时：

![image-20210325193113630](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325193113630.png)

在报OOM之前，GC会**回收软引用的可达对象**。



**使得堆空间既能够放下数组，但容不下User对象，必须要将User软引用删除才可以放得下数组。**

**没有报OOM**，**只是清理掉了软引用的可达对象**







## 再谈引用：弱引用





![image-20210325194034106](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325194034106.png)





**弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。**

***弱引用对象更容易、更快被 GC回收***



---

**WeakHashMap？**

可以在内存不足时回收。**避免OOM出现**

 

![image-20210325195826890](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325195826890.png)









## 再谈引用：虚引用

**对象回收跟踪**



![image-20210325200007252](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325200007252.png)



虚引用**必须和引用队列一起使用**，虚引用在创建时***必须提供一个引用队列作为参数。***

当垃圾回收器准备回收一个对象时，如果发现**它还有虚引用**，就会在回收对象**后**，**将这个虚引用加入引用队列，以   通知应用程序对象的回收情况！**



**由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中   执行和记录**

![image-20210325200409552](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325200409552.png)





---

obj强引用，同时还有一个虚引用指向该对象。



![image-20210325201440430](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325201440430.png)

- 无法通过虚引用get到对象
- 进行一次gc：可以通过finalize()方法进行复活
- 再次gc：无法复活了，将对象回收掉了。



使用一个分线程来操作引用队列：

**当下面的gc操作执行的时候，一旦将obj对象回收掉了，就会将此虚引用存放到引用队列中，通过对该引用队列操作，可以获取到强引用对象obj的回收信息——实现追踪！**



主线程结束，守护线程执行结束！

![image-20210325201620417](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210325201620417.png)









## 再谈引用：终结器引用



```java
class FinalReference<T> extends Reference<T> {

    public FinalReference(T referent, ReferenceQueue<? super T> q) {
        super(referent, q);
    }
}
```

**用于实现对象的finalize()方法，也可以称为终结器引用**

无需手动编码，内部配合**引用队列**使用

在GC时，**终结器引用入队**，由Finalizer线程通过终结器引用**找到被引用对象并调用它的finalize()方法**，**进行复活后，第二次GC才能回收被引用对象**









# 垃圾回收器





## GC分类与性能指标



- 垃圾收集器可以由不同的厂商，不同版本的jvm来实现
- 从不同角度分析垃圾收集器，可以将GC分为不同的类型

> 不同版本新特性：
>
> 1. 语法层面：lambda表达式，switch、自动装箱拆箱、enum、泛型....
> 2. API层面：Stream API，新的日期时间、Optional、String、集合框架
> 3. 底层优化：JVM的优化、GC的变化

线程数：**垃圾回收的线程数**

![image-20210326083439318](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326083439318.png)



![image-20210326083844661](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326083844661.png)



![image-20210326083949750](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326083949750.png)



![image-20210326084006343](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326084006343.png)

压缩式：指针碰撞；非压缩式：空闲列表



-----



**评估GC的性能指标**

- **吞吐量：运行用户代码的时间占总运行时间的比例**   `a/a+b`
  - 总运行时间：程序的运行时间 + 内存回收的时间
- 垃圾收集开销：吞吐数的补数，垃圾收集所用时间与总运行时间的比例  `b/a+b`
- **暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间**（越小越好）
- 收集频率：相对于应用程序的执行，收集操作发生的频率（频率低时间长，频率高时间短）
- **内存占用：java堆区所占的内存大小**
- 快速：一个对象从诞生到被回收所经历的时间



重点的（吞吐量、暂停时间、内存占用）三者共同构成了一个“不可能三角”。三者总体的表现越来越好。一款优秀的收集器最多同时满足其中两项





硬件性能的提升有助于降低收集器运行时对应用程序的影响，提高吞吐量。——可以持续运行很长时间才会出现内存不足。

而内存的扩大，对延迟反而带来负面效果。**现在内存空间越来越大——>暂停时间长**。

**主要抓住两点：吞吐量+暂停时间**



----



**吞吐量** throughput

- 吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）
  - 虚拟机总共运行100分钟，垃圾回收1分钟，吞吐量99%
- 应用程序能**容忍较高的暂停时间**，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的
- 吞吐量优先，意味着在**单位时间内，STW的时间最短**。***但是单次  STW的时间可能会较长***





![image-20210326085613489](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326085613489.png)



**暂停时间 pause time**

- 一个时间段内应用工程需线程暂停，让GC线程执行的状态



**暂停时间优先，意味着尽可能让   *单次 STW的时间*  更短**。但**吞吐量可能会更低**。还需要再用户线程和垃圾回收线程不断切换，花费时间



 ![image-20210326090144472](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326090144472.png)



在设计GC算法时，必须确定目标：一个GC算法只可能针对两个目标之一（关注较大吞吐量或最小暂停时间）

标准：***在最大吞吐量优先的情况下，降低停顿时间***。可控的暂停时间内。









## 不同的垃圾回收器概述



垃圾收集器一定是和不同版本JVM绑定。



垃圾回收的**并行**处理，降低延迟和提高吞吐量

jdk11开始，ZGC出现

jdk14，删除CMS（第一款并发垃圾收集器）

![image-20210326090608552](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326090608552.png)



经典的垃圾收集器：

- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel Old
- 并发回收器：G1、CMS



![image-20210326091711456](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326091711456.png)

并发：用户线程和垃圾回收线程并发

G1：分区算法（新生代和老年代共同的垃圾回收）



---

收集器和堆空间分代的关系



![image-20210326092120878](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326092120878.png)



**所以需要搭配使用：新生代+老年代**

![image-20210326092246379](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326092246379.png)

jdk8之前：实线+虚线

（CMS + Serial Old 后备方案）

jdk8和9中：取消了红虚线的组合。默认的是parallel组合  ||  CMS&ParNew  || Serial(单CPU)

在jdk14中：弃用了绿色虚线组合，并行+并行；**CMS也被删除了**。只有串行/并行/G1三种



为什么CMS不能和Parallel搭配？

parallel底层用的框架不一样，不兼容。



**服务器端：吞吐量；客户端：低延迟**

![image-20210326093029293](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326093029293.png)







如何查看默认垃圾收集器

![image-20210326122733293](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326122733293.png)



![image-20210326123122367](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326123122367.png)

![image-20210326123135128](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326123135128.png)

**自动搭配关系**

![image-20210326123200580](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326123200580.png)

在jdk8中没有使用G1收集器

jdk9开始使用G1，不再使用parallelGC











## Serial回收器：串行回收



- Serial收集器是最基本、历史最久的垃圾收集器
- Serial收集器作为HotSpot中CLient模式下默认新生代垃圾收集器
- **Serial收集器采用  *==复制算法==*  、串行回收和STW机制的方式执行内存回收**
- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。**Serial Old收集器同样也采用了串行回收、STW机制，只不过内存回收算法使用的是   *标记压缩算法***
  - Serial Old运行在**Client模式**下默认的**老年代的垃圾回收器**
  - Serial Old在Server模式下主要有两个用途
    - 与新生代的Parallel ScavengeGC 配合使用
    - 作为老年代的CMS GC的 **后备垃圾收集方案**









![image-20210326124040708](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326124040708.png)



Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它 **只会使用一个CPU或一条手机线程去完成垃圾收集工作**，更重要的是在它进行垃圾收集时，**必须暂停其他所有的工作线程，知道收集结束 —— STW**



----

对于单线程来说，比并行的收集器要 **高效！**。没有额外线程开销，效率更高

 ![image-20210326124140138](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326124140138.png)



---

使用串行垃圾回收器

添加参数`-XX:+UseSerialGC`，配置一个，自动搭配老年代的Serial Old GC，不能作为参数

查看：

`-XX:+PrintCommandLineFlags`

`jinfo -flag UseSerialGC port`





---

只限定在单核cpu才可以用。

对于交互性强的应用而言，不能接受。例如web程序











## ParNew回收器：并行回收



ParNew收集器是Serial收集器的多线程版本

只能处理新生代

**除了采用并行回收之外，和Serial基本没有区别。。**ParNew在年轻代中同样采用 **复制算法 + STW机制**，只不过暂停时间会略短一些

ParNew是很多JVM运行在Server模式（多核/多CPU）下新生代的默认垃圾收集器





![image-20210326125145467](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326125145467.png)

- 对于新生代，回收次数频繁，使用并行方式高效
- 对于老年代，回收次数少，使用串行节省资源。CPU并行需要切换线程，串行可以省去切换线程的资源



ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？

- ParNew收集器运行在多CPU的环境下，可以充分利用多CPU、多核心的资源优势，更快完成垃圾收集，提升吞吐量
- **单CPU，需要CPU频繁切换线程做任务切换**



除了Serial GC外，目前只有ParNew GC能和CMS收集器配合工作



----



![image-20210326125710104](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326125710104.png)





`-XX:+UseParNewGC`

```
Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release
```

![image-20210326125840293](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326125840293.png)



![image-20210326125952281](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326125952281.png)







## Parallel回收器：吞吐量优先



- HotSpot的年轻代中除了拥有ParNew收集器时基于并行回收的以外，Parallel Scavenge收集器同样采用了 **复制算法、并行回收和STW机制**

- 是否多此一举？
  - 和ParNew不同，Parallel收集器的目标则是达到一个 ***可控制的吞吐量***，被称为吞吐量优先的垃圾收集器
  - **自适应调节策略**也是parallel Scavenge与parnew的一个重要区别





- 高吞吐量可以高效率利用CPU时间，尽快完成程序的运算任务，主要 **适合在后台运算而不需要太多交互的任务**。因此，常见在**服务器**环境中使用。**例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序**

**暂停时间可能长一点**

- Parallel收集器在1.6时提供了用于执行***老年代垃圾收集的parallel Old收集器***，用来**替代**老年代的**Serial Old收集器**
- parallel Old收集器采用了 ***标记 - 压缩算法***，同样基于 **并行回收和STW机制**



![image-20210326131521028](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326131521028.png)



在程序吞吐量优先的应用场景中，parallel & parallel old收集器可以发挥非常高的效率



jdk8中，默认是parallel收集器



---



![image-20210326131705378](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326131705378.png)

`-XX:+UseParallel(Old)GC`   **Parallel Old 自动和 Parallel配合使用，当一个开启，另一个也开启——   互相激活**

![image-20210326132024524](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326132024524.png)

jdk9中默认是G1回收器 



![image-20210326132206050](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326132206050.png)



![image-20210326132345600](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326132345600.png)









![image-20210326132908782](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326132908782.png)

会调整的**堆小**一点，那么**每次GC停顿时间就短了一点，**

但是空间小就会经常GC，频率高了，**会使得吞吐量降低**



堆空间，新生代/老年代默认比例1:2, 新生代中8:1:1，**默认这个自适应是开启状态**，都有自动调整，尽量来满足设置的吞吐量/暂停时间参数  等行为。

![image-20210326132934476](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326132934476.png)











## CMS回收器：低延迟



- 在jdk1.5时期，HotSpot推出 **强交互应用**中几乎可以认为有划时代意义的垃圾收集器：CMS  Concurrent Mark Sweep收集器，**这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作**



- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。**停顿时间越短（低延迟）**就越适合与**用户交互**的程序，良好的响应速度能提升用户体验
  - **目前很大一部分的java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短**，以给用户带来较好的体验，CMS收集器就非常符合这类应用的需求



- CMS的垃圾收集算法采用 **标记-清除** 算法，并且**也会STW**



![image-20210326134700108](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326134700108.png)





初始标记  STW

并发标记

重新标记 STW

并发清理

重置线程

![image-20210326134829261](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326134829261.png)



CMS的整个过程分为4个主要阶段：初始标记 、并发标记、重新标记、并发清除

- 初始标记阶段：在这个阶段中，程序中所有的工作线程都**会STW**，出现暂停。这个阶段的主要任务  **仅仅是标记处 GC Roots能直接关联到的对象**，一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，***速度非常快*！**
- 并发标记阶段：从GC Roots的 **直接关联对象开始遍历整个对象图的过程**，这个过程 **耗时较长但是*不需要停顿用户线程*，可以与垃圾收集线程一起并发运行**
- 重新标记阶段：在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了  **修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段的停顿时间通常会比初始标记阶段稍长一些，远比并发标记阶段的时间段。**这时候执行STW**
- 并发清除阶段：此阶段 **清理删除掉标记阶段判断的已经死亡的对象，释放内存空间**。由于***不需要移动存活对象***，所以**这个阶段也是可以与用户线程同时并发的**，不需要STW——存在内存碎片



---



**不可能做到完全不使用STW——尽可能缩短STW时间**

最耗时的操作是并发执行的。低停顿！

**CMS回收过程中应该确保用户线程有足够的内存使用！  不能等到来年代几乎完全被填满了再进行收集，内存使用率达到一定阈值时，就开始进行回收。如果内存还不够，就使用后备方案：Serial Old收集器来进行老年代的垃圾收集 **

![image-20210326135641505](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326135641505.png)





----

CMS采用的是 **标记-清除算法**，意味着每次执行完内存回收后，**不可避免地将会产生一些内存碎片**，在为新对象分配内存空间时，无法使用指针碰撞，之恩能够选择空闲列表来执行内存分配

![image-20210326140015796](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326140015796.png)



**那为什么CMS不使用Mark Compact标记压缩呢？**

**其实很简单，因为在执行  并发清理阶段时，是和用户线程并发执行，如果需要移动？那么就修改了正在运行的用户线程使用的对象的地址，它运行的资源不能受到影响——而准备清理掉的对象是已经不用的，自然可以直接清理**







---

弊端：

- 产生内存碎片，无法存放大对象，导致提前触发Full GC。——**埋了一颗定时炸弹！！！！！业务高峰导致OOM，从而导致CMS无法工作，只能使用Serial Old串行工作，程序可能需要停顿很久！！**
- 分出一个线程进行垃圾回收，吞吐量降低
- **浮动垃圾**：在并发标记阶段不是垃圾，但在重新标记阶段变成了垃圾。。那么就无法对这些垃圾对象进行标记，最终导致没有被及时回收。只能下次再回收了。 

![image-20210326140447096](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326140447096.png)





---



CMS参数：



![image-20210326141433906](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326141433906.png)



同时新生代会触发 -XX:+UseParNewGC的使用

![image-20210326141635005](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326141635005.png)



需要未雨绸缪进行垃圾回收——阈值。**通过该选项便可以有效降低Full GC的执行次数**

 

![image-20210326142059215](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326142059215.png)







---

 

![image-20210326144614481](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326144614481.png)



新特性：

![image-20210326144758882](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326144758882.png)







## G1回收器：区域化分代式

https://blog.csdn.net/baidu_38083619/article/details/105752830







既然已经有了几个强大的GC，为什么还要发布G1呢？

**业务越来越庞大、复杂，用户越来越多**，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1垃圾回收器是在java7之后引入的一个新的垃圾回收器。

为了适应现在 **不断扩大的内存和不断增加的处理器数量**，进一步降低暂停时间，同时兼顾良好的吞吐量

**官方给G1设定的目标是在   *==延迟可控的情况下   获得尽可能高的吞吐量==*，所以才担当起    全功能  收集器  的重任与期望**



分割为很多不相关的区域，不同的区域region来表示Eden、幸存者0 1区，老年代。

避免在整个堆中进行全区域的垃圾收集。跟踪Region，垃圾堆积的价值大小。**在不超过暂停时间的前提下，优先回收价值最大的Region**

垃圾优先...

![image-20210326175300683](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326175300683.png)

 

**全功能：年轻代+老年代都可以回收**

![image-20210326175812700](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326175812700.png)





-----

### G1回收器的优缺点



- **并行与并发**。
  - 可以有多个GC线程同时工作，多核并行回收。**需要STW**
  - 和用户线程并发执行。**部分工作可以和用户线程并行执行**。——>不会在整个回收阶段完全阻塞应用程序
- **分代收集**
  - **G1依然属于分代垃圾回收器**，区分年轻代和老年代。但不要求各个区是连续的——分块，不坚持固定大小和固定数量
  - 若干个Region来表示逻辑上的年轻代和老年代
  - 可能这个代表Eden的Region被释放后，下一刻被使用为 Old区，这个Region的角色在清空后是不固定的
  - ***兼顾年轻代和老年代***
- **空间整合**
  - CMS：标记清除算法，可以在若干次CMS后进行碎片整理
  - Region**之间是复制算法(Eden->Survivor 这样正好可以腾出一个干净的Region)**，整体上实际可看作是 **标记压缩算法**，都可以避免内存碎片。java堆非常大的时候，G1的优势更加明显

- **可预测的停顿时间模型**  软实时
  - 能让使用者明确指定在一个长度为M毫秒的时间段内，**消耗在垃圾收集上的时间不得超过N毫秒**
  - 由于分区，只选取**部分区域进行内存回收**，**对于全局停顿情况的发生得到较好控制**
  - **优先列表，回收价值最大的Region。获得更大的收集效率**

![image-20210326180134366](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326180134366.png)

![image-20210326180303221](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326180303221.png)

![image-20210326180319683](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326180319683.png)



![image-20210326180702514](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326180702514.png)





---

G1回收器的缺点

![image-20210326181931197](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326181931197.png)







### G1的参数设置



如果将期望时间设置的非常小，能挑选的Region就很少，清理的空间也很少，会占满堆，然后进行Full GC 

![image-20210326182302906](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326182302906.png)





----



G1的操作步骤：



![image-20210326184351894](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326184351894.png)





---



使用场景：

- 大内存，多处理器
- 低延迟，大堆
- 只是清理一部分Region，保证停顿时间不超过暂停时间值
- 替换CMS（同样是低延迟）
- 使用应用线程帮助加速垃圾回收过程

![image-20210326184921506](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326184921506.png)





### 分区Region

使用G1收集器时，它将整个java堆分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB、2、 4 、8、16 、32。通过 `-XX:G1HeapRegionSize`来设定。**所有的Region大小相同，且在JVM生命周期内不会被改变**

虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，都是一部分Region（**不需要连续**）的集合。***通过Region的动态分配方式实现逻辑上的连续***



![image-20210326190147587](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326190147587.png)

**一个Region在使用时 的角色一定是单一的，当清空后可以被重新分配为另一个角色**



![image-20210326190214714](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326190214714.png)



Region内分配内存指针碰撞：

![image-20210326190548251](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326190548251.png)

在Region中单独分配TLAB，每个线程一小份，并行执行不需要加锁





### G1回收器垃圾回收过程





G1 GC的垃圾回收过程，主要包含前三个环节：

- 年轻代GC  Young GC
- 老年代**并发标记过程**  Concurrent Marking
- 混合回收 Mixed GC
- 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，**即强力回收**



![image-20210326180522095](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326180522095.png)







![image-20210326193443251](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326193443251.png)



-----

**Remembered Set** 

**一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个java堆才能保证准确？**回收新生代也不得不同时扫描老年代？（哪些对象作为GC Roots？非该区域的引用也要作为GC Roots一部分）

解决：

- **使用remembered set避免全局扫描** 
- 如果是同一个Region，那在扫描的时候肯定也会扫描到，不需要记录
- 如果不是同一个Region，那么就把引用信息记录到引用指向对象的  所在Region对应的remembered set中
- 垃圾收集时，在gc根节点枚举范围加入remembered set，保证不进行全局扫描，也不会有遗漏



![image-20210326193821002](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326193821002.png)



![image-20210326194604060](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326194604060.png)







---

### 年轻代GC

YGC发生的频率非常高。



JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当**Eden区空间耗尽**时，G1会启动一次年轻代垃圾回收过程

**年轻代垃圾回收只会回收Eden区和Survivor区**

YGC时，首先**G1停止应用程序的执行：STW（独占式的）**，G1创建**回收集**，回收集是需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区的**所有内存分段**

![image-20210326200138086](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326200138086.png)

**Eden + Survivor  到另一个Region 保存下来，使用复制算法。**

1. 扫描根 GC Roots   **一定要用到Remembered Set**
2. **更新Remembered Set**
   - 对于应用程序的引用赋值语句 Object.field = object，JVM会在**之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card**。在年轻代回收的时候，会对dirty card queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系
   - 不在引用赋值语句处直接更新RSet？这是为了性能的需要，**RSet的处理需要线程同步**，开销会很大，使用队列性能会好很多
3. 处理RSet，识别被老年代中对象指向的新生代中的对象，这时候Eden中的对象被认为是存活的对象（**被老年代对象所引用。这时候老年代对象有可能是还没被回收的垃圾对象，但仍然认为此时新生代中的这个被引用的对象是存活对象**）
4. **复制对象 Eden->Survivor  From->To   复制算法！**
5. **处理引用，一定会回收弱引用。复制到的Region中都是按照顺序存储的，没有碎片**

![image-20210326200952390](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326200952390.png)





----



### 并发标记过程

（和CMS很像。。。）

1. **初始标记阶段——> STW，只标记根节点直接可达的对象**
2. **标记被引用的对象**。必须在YGC之前完成？
   - YGC需要挪动Survivor区，先扫描完再去挪动survivor区

3. **并发标记**，和应用程序并发执行。**计算对象活性**：只会回收价值高的Region，不会一次全部回收
4. 再次标记，因为上一次是和用户程序并发执行的。需要**STW**。**初始快照算法**
5. **STW**，清理。排序，识别可以混合回收的区域。
6. **并发清理**？——>清理那些区域对象中的所有对象都是垃圾的，在 **并发标记阶段就直接回收掉了，标记为空闲Region**

![image-20210326202008000](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326202008000.png)







### 混合回收



> 当整个堆内存（包括老年代和新生代）被占满一定大小的时候（默认是45%，可以通过-XX:InitiatingHeapOccupancyPercent进行设置），Mixed GC（混合回收）就会被启动。具体检测堆内存使用情况的时机是年轻代回收之后或者Houmongous对象分配之后。





**Mixed GC不是Old GC，也不是Full GC**

**只回收价值高并且不会超时的一部分Old Region**

![image-20210326202824450](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326202824450.png)





- **部分为垃圾的Region被计算出来**，这些Region会分8次进行回收

- 老年代中有垃圾的Region   默认分8次回收，G1会优先回收垃圾多的Region（价值高）
- **回收集包括：所有的新生代Region（可能是移动，可能是回收），1/8的有垃圾的老年代Region**
- **优先回收垃圾比例多的老年代Region**
- **如果可回收的垃圾占堆比例太小，不回收了~**

![image-20210326203408151](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326203408151.png)







### 可选的过程：Full GC





直接STW，使用**单线程的内存回收算法进行回收，性能很差**

**并发标记处理完成之前空间耗尽——>需要和用户线程并发执行并发标记过程，在这个时候堆满了，就直接Full GC，不留机会！**

![image-20210326204735405](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326204735405.png)

**如果设置的最大停顿时间太小，那么每次释放的空间就很少，虽然频率高，还是会满，继而触发Full GC**







---





![image-20210326205418398](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326205418398.png)



优化建议：

暂停时间太小，频繁回收，吞吐量被限制

![image-20210326205903661](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210326205903661.png)







## 垃圾回收器总结







![image-20210327102730941](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327102730941.png)





---

垃圾回收器组合：（更新到了jdk14）

![image-20210327103209347](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327103209347.png)



- jdk7中这些组合都可以使用

- jdk8中红虚线被标记为deprecated，但仍然可以使用，jdk9中被removed，无法使用

- jdk14  绿色虚线被标记废弃，**CMS被移除**，

只剩下：

- Serial-Serial Old；

- Parallel Scavenge - Parallel Old；

- G1



---



**如何选择垃圾回收器**



1. 优先调整堆的大小让JVM自适应完成

2. 如果内存小于100M，使用串行收集器

3. 如果是单核、单机程序，并且没有停顿时间要求，串行收集器

4. 如果是多CPU，需要**高吞吐量，允许停顿时间较长**（>1s?），选择并行ParNew或者jvm自己选择

5. 如果是多CPU，追求 **低停顿时间，需要快速响应(比如延迟不能超过1s，如互联网应用)**，使用并发收集器 parallel

   官方推荐G1，性能高，**现在互联网的项目，基本都是使用G1**







![image-20210327104225588](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327104225588.png)



 



## GC日志分析



![image-20210327104610549](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327104610549.png)



**不会显示堆空间使用情况**

Allocation Failure：希望再去Eden区分配空间，但是失败了

![image-20210327105011343](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327105011343.png)





---



![image-20210327105737401](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327105737401.png)

具体使用的收集器  （Full GC就是年轻代和老年代两个收集器同时工作）

![image-20210327105915440](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327105915440.png)

堆空间的详细使用情况：

![image-20210327110000203](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327110000203.png)







---



![image-20210327110216590](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327110216590.png)



![image-20210327110203995](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327110203995.png)





---





  

![image-20210327110400798](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327110400798.png)



![image-20210327110841170](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327110841170.png)

 





![image-20210327111039181](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327111039181.png)



---

 **Minor GC日志**

![image-20210327111116066](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327111116066.png)

![image-20210327111104628](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327111104628.png)



----

**full GC日志**



![image-20210327111835640](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327111835640.png)

这里使用的是永久代

 

---



栗子：



![image-20210327112410858](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327112410858.png)





**按照以上参数配置，堆空间的分配情况：**

![image-20210327112520251](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327112520251.png)

![image-20210327114132910](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327114132910.png)



----

jdk7：

使用 Serial GC

新生代9216k = 减去一个Survivor区的大小，正好9MB  ，总会有一个是空的，不计算在内

Eden：**4M**

老年代：**正好6M = 3 * 2M**

![image-20210327112632320](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327112632320.png)

分析结果：

一开始伊甸园区放了 3个2M的数组，后来需要加入一个4M的数组，不够分啊！触发一次Serial GC，都放到老年代中，新生代来放4M的新数组



---

jdk8：

3个2M数组都存放在了Eden区中

**老年代使用了4M？大数组直接存放进了老年代**

jdk8中，如果Eden空间不够，直接进入老年代

![image-20210327113912244](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327113912244.png)







---



日志分析工具



![image-20210327110330037](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327110330037.png)





![image-20210327114517216](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327114517216.png)





![image-20210327114822382](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327114822382.png)





![image-20210327114912577](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327114912577.png)



![image-20210327114924739](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327114924739.png)







## 垃圾回收器的新发展





![image-20210327115058608](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327115058608.png)



jdk11新特性：

![image-20210327115426912](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327115426912.png)



----

**Open jdk的Shenandoah GC**

![image-20210327115715409](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327115715409.png)



![image-20210327115838334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327115838334.png)

**暂停时间与堆大小无关！限制停顿时间在非常小的范围内**





![image-20210327120524929](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327120524929.png)

**吞吐量下降**

![image-20210327120558823](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327120558823.png)





---



**ZGC**



ZGC和Shenandoah目标高度相似，**在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小都可以把垃圾收集的时间限制在10ms以内的低延迟**

**可并发的标记压缩算法，目标是低延迟**

![image-20210327134511306](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327134511306.png)



**低延迟！把停顿时间控制在10ms以内**

![image-20210327135015774](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327135015774.png)



**服务端、大内存、低延迟应用的首选垃圾收集器**



![image-20210327135218483](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327135218483.png)

`-XX:+UseZGC` 需要解锁实验vm选项



---



![image-20210327135314158](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210327135314158.png)









































































































































































































































































































































































































































# Tip



## aload_n的解释



<n>必须是当前帧的**局部变量数组的索引**（第2.6节）。 <n>处的局部变量必须包含**一个引用**。 <n>处的局部变量中的objectref被压入操作数堆栈。



![image-20210321132146922](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132146922.png)



string栈帧的局部变量表：

![image-20210321132201032](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132201032.png)

**这里加载局部变量表中索引为0位置的引用：即this，将this加载到操作数堆栈中，再对这个this方法调用本地的虚方法，将方法的返回值x存储到局部变量表中**



main栈帧的局部变量表：

![image-20210321132717373](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132717373.png)

![image-20210321132305846](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132305846.png)

**如果是static方法，那么就不需要通过this引用实例  来进行调用，直接调用常量池中的引用即可。再将返回值引用保存到局部变量表中**

但接下来调用string()方法，就需要使用到局部变量表中索引为1的实例，aload_1将其加载进操作数栈，然后调用-保存。











## int在运行时常量池



```java
System.out.println(32767);
```

对应的字节码指令：`sipush 32767`

**并且还发现，这个字面量并没有存在常量池中？怎么回事呢？**



> ldc: 将int, float或String型常量值从常量池中推送至栈顶。
>
> ldc_w: 将int, float或String型常量值从常量池中推送至栈顶（宽索引）
>
> ldc2_w: 将long或double型常量值从常量池中推送至栈顶（宽索引）
>
> 这三个指令是属于ldc系列的指令，该系列的指令负责将**数值常量或String常量值从常量池中推送到栈顶**。该命令后面需要给一个表示常量在常量池中位置(编号)的参数。



bipush 将单字节的常量值(-128~127)推送至栈顶
sipush 将一个短整型常量值(-32768~32767)推送至栈顶
该系列命令**负责把一个整形数字（长度比较小）送到到栈顶**。该系列命令**有一个参数，用于指定要送到栈顶的数字。**
注意该系列命令只能操作**一定范围**内的整形数值，**超出该范围的使用将使用ldc命令系列。**

***原来JVM字节码的指令是可以存储一定范围的值的，不需要将该范围内的值放置到常量池当中，然后搞个索引指向常量池中。***



这样，Integer值就存在了常量池中！从常量池中获取引用。**如果太小的int值，就直接赋值了，无需使用引用从常量池中获取**

` ldc #9 <32768>`

![image-20210322191312638](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210322191312638.png)











## 符号引用



解析阶段会有一个步将常量池当中二进制数据当中的符号引用转化为直接引用的过程



符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能**无歧义地定位到目标**即可，符号引用和虚拟机的布局无关。

个人理解为：在编译的时候一个**每个java类都会被编译成一个class文件**，但在编译的时候虚拟机**并不知道所引用类的地址**，多以就用**符号引用来代替**，而在这个解析阶段就是为了把这个***符号引用转化成为真正的地址***  的阶段。



**比如，将PrintStream类加载进内存中，符号引用转为直接引用来调用后，执行其方法println()，将其加载进当前线程的栈帧进行执行.....**



如果有了直接引用，那么直接引用的目标一定被加载到了内存中。

直接引用可以是： 

1：直接指向目标的指针。（个人理解为：指向对象，类变量和类方法的**指针，就是直接指向内存地址**）

2：相对偏移量。    （指向实例的变量，方法的指针）

3：一个间接定位到对象的句柄。







## 为什么young gc时要把old gen中的对象作为gc roots的一部分



我们知道HotSpot VM 是基于分代垃圾收集机制gc的(G1也是一种特殊的分代机制，动态分代)，那么在分代收集的过程中显然会存在一个问题那就是跨代引用。**比如当我们进行young gc时，新生代中的对象是完全有可能被老年代所引用的**。然而young gc的过程中我们并不会收集老年代中的对象(无论是否存活)，***当jvm从gc roots 出发trace的过程中如果出现老年代对象会直接中断这条trace路径***，这个时候**为了防止将新生代中存活的对象误判为死亡我们不得不将老年代中的对象当作gc roots的一部分。**

既然这样**为什么不直接不要中断老年代的trace路径呢？** 

是的，如果我们将所有的老年代对象都当作young gc的gc roots的话我们还不如不切断老年代的的trace路径来的效率高。但是在jvm的实际实现中，我们会在新生代上建立一个全局Remembered Set数据结构，这个结构把老年代分成数个小块，并**标识出那一块会存在跨代引用**。当发生young gc的时候**只有包含跨代引用的小块才会被加入gc roots扫描**。 显然这样做虽然多了一个维护**Remembered Set**的开销，但总的来说比之将老年代整体加入gc roots扫描肯定时间效率要高多了。

**那么它就一定保证比不中断老年代trace链快吗？从跨代引用假说上来说，是的！**

**跨代引用假说：跨代引用相对于同代引用来说只占极少数。**





————————————————
版权声明：本文为CSDN博主「FRESH_9527」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_42360572/article/details/103797007



