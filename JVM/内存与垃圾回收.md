JVM学习路线：

![image-20210321154529797](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321154529797.png)



# 内存与垃圾回收







# JVM和Java体系结构







![image-20210319184628767](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319184628767.png)

始终是在软件层面进行操作。需要去了解底层

**内功修炼！**



高级语言->汇编语言->机器指令->CPU



![image-20210319190029581](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319190029581.png)

垃圾回收机制，大大提高了开发效率，但也不是万能的，懂得JVM内部的**内存结构，工作机制**，是设计高扩展性应用和诊断运行时问题的基础。



## Java及JVM简介



跨平台的语言：

![image-20210319192535044](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319192535044.png)





JVM：跨语言的平台。只要他们的编译器编译出的字节码文件符合规范，那么就可以被java虚拟机解释运行。**它只关心字节码文件**。

![image-20210319192731453](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319192731453.png)



字节码->**jvm字节码**

多语言混合编程，他们最终都运行在一个虚拟机之上。





## 虚拟机与java虚拟机



系统虚拟机和程序虚拟机。

系统虚拟机完全是对物理计算机的仿真，提供可运行完整操作系统的软件平台。

程序虚拟机，如java虚拟机，专门为执行单个计算机程序而设计。

Java虚拟机：执行**java字节码**的虚拟计算机，**跨平台+优秀的垃圾回收器+可靠的即时编译器**



作用：java虚拟机就是**二进制字节码的运行环境**。

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能





**JVM的位置**：





![image-20210319183620188](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319183620188.png)

JVM是运行在操作系统之上的，**与硬件没有直接的交互**



javac：前端编译器。

![image-20210319183811985](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319183811985.png)







## JVM的整体结构



HotSpot VM是目前市面上高性能虚拟机的代表作之一

采用**解释器与即时编译器**并存的架构

- 字节码文件输入->类加载器->生成class对象

- 共享方法区和堆

- 每个线程独享程序计数器，本地方法栈和虚拟机栈
- 执行引擎：高级语言->机器语言

![image-20210319200058541](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200058541.png)



**更详细的图：**

![image-20210319200616290](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200616290.png)



![image-20210319200630907](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319200630907.png)







## Java代码执行流程



![image-20210319201439951](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319201439951.png)





## JVM架构模型



基于栈的指令集架构，基于寄存器的指令集架构



==hotspot是基于栈的指令集架构==

- 设计和实现更简单
- 避开了寄存器的分配难题，使用零地址指令方式分配
- 执行过程依赖于操作栈，指令集更小，编译器更容易实现
- 不需要硬件支持，可移植性更好，更好实现跨平台



基于寄存器架构：

- x86的二进制指令集
- **完全依赖硬件**，性能优秀，可移植性较差
- 花费更少的指令去完成一项操作
- 一地址指令、二地址指令、三地址指令







- 一地址指令：地址+操作数的个数

- 零地址指令：没有地址，只有操作数 



![image-20210319202114141](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319202114141.png)



```
int i = 2 + 3;
```

```
javap -v StackStruTest.class 反编译
```

![image-20210319203345499](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319203345499.png)



```
int i = 2;
int j = 3;
int k = i + j;
```

![image-20210319203550140](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319203550140.png)



总结：

**由于跨平台性的设计，java的指令都是根据栈来设计的**



栈：

- 跨平台性
- 指令集小
- 指令多
- 执行性能比寄存器差一点





## JVM的生命周期



- **虚拟机的启动**

Java虚拟机的启动是通过**引导类加载器**bootstrap class loader创建一个初始类initial class来完成的，这个类是由虚拟机的具体事先指定的

自定义的类通过系统类加载器加载

Object被引导类加载器加载

需要先加载父类，发现没有，启动虚拟机

- **虚拟机的执行**

一个运行中的Java虚拟机有着一个清晰的任务：执行java程序

程序开始执行时他才运行，程序结束时他就停止

**执行一个所谓的java程序的时候，在执行的是一个叫做java虚拟机的进程**

![image-20210319205159316](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210319205159316.png)



- **虚拟机的退出**

程序正常执行结束

执行过程中遇到一场或错误而异常终止

操作系统错误

**Runtime(运行时环境)**或System的exit方法，Runtime的halt方法，并且java安全管理器也云溪这次exit或halt操作

Java Native Interface也可以来加载或卸载java虚拟机





## JVM发展历程



- Sun Classic VM

  只提供了解释器，逐行解释字节码。。。效率较低。如果为了执行效率使用 JIT 编译器，就需要进行外挂，但是一旦使用JIT编译器，就会接管虚拟机的执行系统，解释器就不再工作。解释器和编译器也**不能配合工作**

  只使用JIT，**暂停时间**较长。二者应该**搭配使用**效率才高。

  hotspot内置了此虚拟机

- Exact VM

  准确是内存管理，可以知道内存中某个位置的数据具体是什么类型

  编译器与解释器混合工作模式

  热点探测



- HotSpot VM

oracle/Open  jdk的默认虚拟机。

**hotspot：热点代码探测技术**：

​	通过计数器找到最具编译价值代码，触发即时编译（缓存起来）或栈上替换

​	通过编译器与解释器**==协同工作==**，在最优化的**==程序响应时间与最佳执行性能==**中取得平衡



- JRockit

  专注于服务器端应用

  - 不太关注程序启动速度，因此内部不包含解析器实现，都靠即时编译器编译后执行

  是世界上**最快的JVM**

  优势：

  - 提供毫秒、微妙级的JVM响应时间
  - MissionControl服务套件，监控、管理和分析生产环境中的应用程序

- IBM 的 J9

  市场定位与HotSpot接近。有影响力的三大商用虚拟机之一，号称世界上最快的jvm....



- KVM和CDC/CLDC HotSpot

  移动领域

  一次编译，到处运行

- Azul VM

  与特定硬件平台绑定，软硬件配合的专有虚拟机。

- Liquid VM

  BEA公司，运行在自家的系统上。

  不需要操作系统的支持，自己本身实现了一个专用操作系统的必要功能：线程调度、文件系统、网络支持等。

- Apache Harmony 

  它的Java类库代码吸纳进了Android SDK

- Microsoft JVM

- Taobao JVM

  基于Openjdk HotSpot深度定制且开源的高性能服务器版Java虚拟机

  降低垃圾回收的频率

  在淘宝、天猫上线，替换了Oracle JVM

- Dalvik VM

  谷歌开发。应用于Android系统。不是Java虚拟机，没有遵循Java虚拟机规范。

  不能执行Java 的Class文件

- Graal VM

  跨语言全栈虚拟机，作为任何语言的运行平台使用：Java,Scala,C,C++,JS,Python.....

  支持不同语言中混用对方的接口和对象





# 类加载子系统



## 内存结构概述





![image-20210320094037787](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320094037787.png)



使用类加载子系统将class字节码文件加载到内存中，生成大的class对象，初始化静态属性...



- 加载阶段：引导/扩展/系统  类加载器
- 链接阶段：验证、准备、解析
- 初始化阶段

![image-20210320094311385](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320094311385.png)



如果自己手写一个java虚拟机，需要考虑类加载器和执行引擎。







## 类加载器与类的加载过程



![image-20210320095232496](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320095232496.png)

- 类加载器子系统负责从文件系统或者网络中加载Class文件，ckass文件在文件开头有特定的文件标识
- `ClassLoader`只负责**class文件的加载**，至于它是否可以运行，则**由Execution Engine执行引擎来决定**
- 加载的**类信息**存放于一块称为**==方法区==**的**内存空间**。除了类的信息外，方法区中还会存放**运行时常量池信息**，可能还包括**字符串字面量和数字常量**（这部分常量信息是Class文件中常量池部分的内存映射）







![image-20210320095640068](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320095640068.png)

- class file 存在于本地硬盘上，根据这个文件**实例化**出n个一模一样的实例。
- class file 加载到JVM中，被称为DNA元数据模板，放在方法区

- Car Class调用 `getClassLoader`获取类加载器
- 通过具体的类对象还可以 `getClass()`获取到是哪个Class创建的对象

- 在.class文件 ->JVM -> 最终成为**==元数据模板==**，此过程就要一  个运输工具：类装载器Class Loader，扮演一个快递员的角色



类的加载过程：

![image-20210320100106181](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320100106181.png)



### 类的加载过程

---

**加载：Loading**

- 通过一个类的全限定名获取定义此类的**二进制字节流**（网络、本地、jar/war压缩包、动态地里、jsp）
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口



---

**链接**

验证Verify：

- 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证部IE加载类的枕骨且行，不会危害虚拟机自身安全。"CAFEBABE"
- 文件格式验证、元数据验证、字节码验证、符号引用验证



准备Prepare：

- 为类变量分配内存并且设置该类变量的默认初始值：**==零值==**
- **这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化**
- **这里不会为实例变量分配初始化**，**==类变量会分配在方法区==**中，而**==实例变量是会随着对象一起分配到Java堆中==**



![image-20210320101330889](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320101330889.png)



解析Resolve：

- 将常量池中的符号引用转换为常量引用

![image-20210320102524219](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320102524219.png)

- **符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在Class文件格式中，直接引用就是直接指向目标的指针、相对偏移量**
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等



---



> 类/静态变量属于类，就像实例变量一样，它们是在类内在任何方法之外声明的，但是使用static关键字声明。
>
> 它们可以在编译时访问，您可以在实例化之前/不实例化类时进行访问，整个类中只有一个静态字段的副本可用，即，静态字段的值在所有对象中都相同。您可以使用static关键字定义一个静态字段。
>
> 如果您在类中声明了静态变量，则尚未初始化它，就像使用实例变量一样，编译器将使用默认构造函数中的默认值对其进行初始化。
> ————————————————
> 版权声明：本文为CSDN博主「圭 圭」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/weixin_29163797/article/details/114134698



**初始化**

- 就是执行类构造器方法`<clinit>()`的过程

- javac编译器自动收集类中的所有**类变量（static）的赋值动作和静态代码块（static）**中的语句合并而来

  ```java
  private static int num = 1;
  static{
  	num = 2;
  }
  ```

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103016926.png" alt="image-20210320103016926" style="zoom:150%;" />

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103120733.png" alt="image-20210320103120733" style="zoom:150%;" />

  **一开始赋值为1，后来又赋值为2，会把显示初始化和静态代码快的初始化合并在一起**

- 构造器方法中指令按语句在**源文件中出现的顺序**执行 ↑

  ```java
  static{
  	num = 2;
  	number = 20;
  }
  private static int number = 10;//在linking阶段，prepare环境，将number赋值为0，在initialization阶段，重新覆盖，按照顺序  先20  后被覆盖为10
  ```

   <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103434246.png" alt="image-20210320103434246" style="zoom:150%;" />

  ![image-20210320103545588](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320103545588.png)

  **报错：非法的前向引用↑。声明的对象在后面，可以赋值但不可以调用**

- `<clinit>()`不同于类的构造器（关联：构造器是虚拟机视角下的`<init>()`）

  ==**如果类中没有静态代码块或者静态变量，那么不存在`<clinit>()`类构造器方法**== 

- <`init`>是类构造器函数

  **任何类声明以后，内部至少存在一个类的构造器（系统默认提供 -> 默认父类Object构造器）**

- 若该类具有父类，JVM会在子类的clinit执行前，父类的clinit已经执行完毕

  **首先会加载father类，其次加载son类  B=2**

  ![image-20210320105010950](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105010950.png)

  <img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105346224.png" alt="image-20210320105346224" style="zoom:150%;" />

- 虚拟机必须保证一个类的 `<clinit>()`方法在多线程下被**同步加锁**。**一个类只需要加载一次就可以，加载到内存中，以后都是使用的内存中的类本身。**

  如果是多线程，

  ![image-20210320105544125](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105544125.png)

  不让这个类加载完成。。。

  ![image-20210320105628138](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105628138.png)

  两个线程都需要初始化DeadThread类：

  ![image-20210320105824928](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320105824928.png)

​	**只有一个类可以进到 `<clinit>()`方法来初始化这个类**，实现了同步加锁







## 类加载器的分类



- 引导类加载器 Bootstrap

   C和C++编写

- 自定义类加载器 User-Defined

   将所有继承自抽象类ClassLoader的类加载器都划分为自定义类加载器



![image-20210320110405264](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110405264.png)

不是继承关系，等级关系。**ExtClassLoader是AppClassLoader的父加载器**

```java
public static void main(String[] args) {
    //获取系统类加载器
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
    
    //获取其上层：扩展类加载器
    ClassLoader extClassLoader = systemClassLoader.getParent();
    System.out.println("extClassLoader = " + extClassLoader);
    //extClassLoader = sun.misc.Launcher$ExtClassLoader@1b6d3586
    
    //试图继续获取上层，获取不到引导类加载器
    ClassLoader parent = extClassLoader.getParent();
    System.out.println(parent);//null
    
    System.out.println("用户自定义类的类加载器：" + ClassLoaderTest.class.getClassLoader());
    //用户自定义类的类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2
    //和上面AppClassLoader是一个对象，使用系统类加载器进行加载
}
```

`String.class.getClassLoader`：null，获取不到类加载器。**证明了String类使用引导类加载器进行加载的。——>java的核心类库都是使用引导类加载器**

**Bootstrap Class Loader没法获取到，非常高端....只加载核心类库，c和c++编写，拿不到对象**

![image-20210320110437650](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110437650.png)



**ExtClassLoader是AppClassLoader的父加载器**：

```java
private ClassLoader(Void unused, ClassLoader parent) {
    this.parent = parent;
```

**在构造AppClassLoader时传入了ExtClassLoader对象，在ClassLoader类中将其设置为AppClassLoader的parent，==其实就是一个属性值，并不是继承关系==，二者都继承自URLClassLoader**

```java
Launcher.ExtClassLoader var1;
try {
    var1 = Launcher.ExtClassLoader.getExtClassLoader();
} catch (IOException var10) {
    throw new InternalError("Could not create extension class loader", var10);
}

try {
    this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
} catch (IOException var9) {
    throw new InternalError("Could not create application class loader", var9);
}

```







### 虚拟机自带的类加载器：



**启动类加载器（引导类加载器 Bootstrap ClassLoader）**

- 使用C/C++语言实现，嵌套在JVM内部
- 用来接下载Java核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar），用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader，没有父加载器
- 启动类加载器  **加载扩展类和应用程序类加载器**，并指定他们的父类加载器
- Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类





**扩展类加载器（Extention ClassLoader）**

- **==Java语言编写==**，sun.misc.Luncher.ExtClassLoader
- 派生于ClassLoader类
- 父加载器为启动类加载器
- java.ext.dirs，jre/lib/ext子目录下加载类库。**如果用户创建的jar放在此目录下，也会自动由扩展类加载器加载**



**应用程序类加载器（系统类加载器，AppClassLoader）**

- **==Java语言编写==**，sun.misc.Luncher.AppClassLoader
- 派生于ClassLoader类
- 父加载器为扩展类加载器
- 复杂加载环境变量**==classpath==**或系统属性  java.class.path指定路径下的类库
- **该类加载器是程序中默认的类加载器**，一般来说，Java应用都是由它来完成加载
- 通过`getSystemClassLoader()`方法来获取



![image-20210320113959039](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320113959039.png)

  ![image-20210320114013328](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114013328.png)

其中String也是在rt.jar下

```
sout:Provider.class.getClassLoader()  //null 表明他的加载器是引导类加载器
```



![image-20210320114545334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114545334.png)

 ![image-20210320114357922](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320114357922.png)

```
sout:CurveDB.class.getClassLoader() //ExtClassLoader
```







### 用户自定义类加载器



为什么要自定义类加载器：

- 隔离加载类，隔离中间件和应用的jar包

- 修改类加载的方式
- 扩展加载源，扩展数据库....字节码的来源
- 防止源码泄露，加密解密



实现步骤：

1. 通过集成抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，满足一些特殊的需求
2. 1.2之后，不建议覆盖loadClass()方法，写在findClass()中
3. 如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作
4. 可以直接继承URLClassLoader类，避免编写**findClass()**和**获取字节码流**的方式，







## 关于ClassLoader

是一个**抽象类**，其后所有的类加载器都继承自ClassLoader，**不包括启动类加载器**

 

![image-20210320130632001](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320130632001.png)





![image-20210320110437650](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320110437650.png)



获取ClassLoader的途径：

![image-20210320130821877](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320130821877.png)







## 双亲委派机制



Java虚拟机对class文件才用的是 **按需加载**的方式，当需要使用该类是才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机才用的是 **==双亲委派模式==**，即**把请求交由父类处理，它是一种任务委派模式**







例：

```java
package java.lang;

public class String {
    //初始化阶段 clinit
    static {
        System.out.println("我是自定义的String类！");
    }
}
```

```java
public class StringTest {
    public static void main(String[] args) {
        java.lang.String str = new java.lang.String();//不是自定义的String，用的还是核心api中的String类
        System.out.println("hello");
        System.out.println(str.getClass().getClassLoader());//null 使用的是启动类加载器
    }
}
```



**工作原理**：

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委**托给父类的加载器**去执行，使用AppClassLoader的parent：ExtClassLoader

2. 如果父类加载器化存在其父类加载器，则**进一步向上委托**，依次递归，**==请求最终将到达顶层的启动类加载器==**

3. 如果**父类加载器可以完成类加载任务**，就成功返回，倘若父类加载器无法完成此加载任务，**子加载器才会尝试自己去加载**，**这就是双亲委派模式**

   **（启动类加载器只加载包名为java,javax,sun开头的类）**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320132335504.png" alt="image-20210320132335504" style="zoom:150%;" />



若此时在java.lang.String中写一个main方法

![image-20210320133952868](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320133952868.png)

**最终加载的是核心包中String类，但这里面并没有main方法。完全不会加载自定义的String类**



---

栗子：



![image-20210320134115501](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320134115501.png)

接口是核心类，接口的实现类是第三方jar包



优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被随意修改
  - 自定义类java.lang.String 

找到引导类加载器，发现是java开头包名，加载这个类，直接报错

![image-20210320134613853](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320134613853.png)





---

 **沙箱安全机制**：

自定义String类，但是在加载自定义String的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程会先加载jdk自带的文件（rt.jar中java/lang/String.class），报错说没有main方法。这样可以**保证对java核心源代码的保护**，**这就是沙箱安全机制**





## 其他



JVM中表示两个class对象是否为同一个类存在两个必要条件：

- 类的完整类名必须一致，包括包名
- 加载这个类的ClassLoader（ClassLoader实例对象）必须相同



在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也不同





---

**类加载器的引用**

如果一个类型是由用户类加载器加载的，**那么JVM会将这个==类加载器的一个引用作为类型信息==的一部分保存在==方法区==中**，当解析一个类型到另一个类型的引用时，JVM需要保证这两个类型的类加载器是相同的。





---

类的主动使用和被动使用



主动使用：

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（Class.forName()）
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- 动态语言支持invoke.MethodHandle....



**其他都是对类的被动使用，都不会导致类的初始化**







# 运行时数据区



## 运行时数据区内部结构

 执行引擎执行的过程中也都**用到了运行时数据区**

![image-20210320142938272](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320142938272.png)



 内存是非常重要的系统资源，承载操作系统和应用程序的实时运行。JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。

**不同的JVM对于内存的划分方式和管理机制存在着部分差异。**



![image-20210320143430824](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143430824.png)

![image-20210320143505089](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143505089.png)





![image-20210320143518524](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320143518524.png)



Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而出阿年，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着县城开始和结束而创建和销毁



![image-20210320144015179](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320144015179.png)

灰色为单独线程私有的：程序计数器、本地方法栈、虚拟机栈

红色为多个线程共享的，堆heap、堆外内存（元空间/方法区、代码缓存）





![image-20210320144608624](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320144608624.png)

**每个JVM只有一个Runtime实例，即运行时数据区，内存结构中的运行时环境**





## 线程



JVM允许一个应用有**多个线程并行执行**

在HotSpot JVM里，**==每个线程都与操作系统的本地线程直接映射==**。

- **当一个Java线程准备好执行以后**，此时一个**操作系统的本地线程也同时创建**，java线程执行终止后，本地线程也会回收

操作系统负责所有线程的安排调度到一个可用的CPU上。一旦本地线程初始化成功，就会**调用java线程中的`run()`方法**



后台系统线程（HotSpot JVM）

- 虚拟机线程，JVM达到安全点才会出现，stop-the-world
- 周期任务线程
- GC线程，垃圾回收
- 编译线程，字节码编译成本地代码
- 信号调度线程







## 程序计数器（PC寄存器）



### PC Register介绍



![image-20210320145806983](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320145806983.png)



Program Counter Register程序计数寄存器。

这里并非是广义上所指的物理寄存器，JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟



**作用：**

**PC寄存器用来存储指向下一条指令的地址，就是即将要执行的指令代码。由执行引擎读取下一条指令**



![image-20210320150032281](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320150032281.png)



- 是一块**很小的内存空间**，非常小，运行速度最快！

- 每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

- 任何时间一个线程都只有一个方法在执行，**当前方法**。程序计数器会存储**==当前线程正在执行的Java方法的JVM指令地址==**；或者如果是在执行native方法，则是未指定值（undefined）

- 是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取**下一条需要执行的字节码指令**
- 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域



**==GC和OOM都不会发生在程序计数器中==**

 





### 栗子



```java
public class PCRegister {
    public static void main(String[] args) {
        int i = 10;
        int j  = 20;
        int k = i + j;
    }
}
```

第一列就是**==指令地址/偏移地址==**

第二列是**==操作指令==**

```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 return
```





```
 0 bipush 10
 2 istore_1
 3 bipush 20
 5 istore_2
 6 iload_1
 7 iload_2
 8 iadd
 9 istore_3
10 ldc #2 <abc>  常量池中取常量  两个操作
12 astore 4
14 getstatic #3 <java/lang/System.out>  也在常量池中
17 iload_1
18 invokevirtual #4 <java/io/PrintStream.println>
21 getstatic #3 <java/lang/System.out>
24 iload_3
25 invokevirtual #4 <java/io/PrintStream.println>
28 return
```

常量池：

![image-20210320151518571](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320151518571.png)







![image-20210320152113344](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320152113344.png)

地址5存储的是 istore_2操作指令，执行引擎通过PC寄存器找到下一个需要执行的指令的地址：**5**，再去局部变量表LV、操作数栈OS**使用这个地址**获取**操作指令**，编译成机器指令进行操作.....



### 两个常见问题



**使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**



因为CPU需要**不停地切换**各个线程，这时候**切换回来**以后，就得知道接着**从哪开始继续执行**

JVM的**字节码解释器**就需要通过**改变PC寄存器的值**来明确**下一条应该执行什么样的字节码指令**

![image-20210320153646579](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320153646579.png)





---



**PC寄存器为什么会被设定为线程私有**

肯定不能共用啊！不能让多个线程共用PC寄存器

多线程在一个特定的时间段内只会执行其中某一个线程的方法，Cpu会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？***为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。***



> CPU时间片限制，中多线程在并发执行的过程中，任何一个确定的时刻，一个处理器或者多核处理器的一个内核，只会执行某个线程的一条指令

![image-20210320154234725](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320154234725.png)



> CPU时间片：
>
> CPU分配给各个程序的时间，每个线程被分配一个时间段-时间片。每个程序轮流执行
>
> 并行：(和串行相反)，同时在执行，一个时间点切面上多个程序在执行
>
> 并发：一个核快速切换，（伪并行）。









## 虚拟机栈

Java Virtual Machine Stack



### 虚拟机栈概述



由于跨平台性的设计，Java的指令根据栈来设计。

**优点是跨平台，指令小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令**



内存只有堆栈？？？？



**栈是运行时的单位，而堆是存储的单位**

> 栈解决程序的**运行问题**，即程序如何执行，或者说如何处理数据
>
> 栈中存放变量...对变量执行指令...都是栈来做的   局部变量表、操作数栈
>
> 
>
> 堆解决的是**数据存储**的问题，即数据怎么放、放在哪儿



  **Java虚拟机栈是什么？**

每个线程在创建时都会创建一个**==虚拟机栈==**，内部保存一个个的**栈帧Stack Frame**，对应着一次次的***Java方法调用***，且是线程私有的

![image-20210320162739765](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320162739765.png)

栈顶B：当前方法。出栈，A变成当前方法



**生命周期**

​	和线程一致

**作用：**

​	主管Java程序的运行，**保存方法的局部变量（8种基本数据类型、对象的==引用地址==(对象本身存放在==堆空间==)）、部分结果，并参与方法的调用和返回**

​	局部变量 vs 成员变量/属性

​	基本数据变量 vs 引用类型变量





---

栈的特点（优点）

- 栈是一种快速有效的分配存储方式，**访问速度**仅次于程序计数器

- JVM直接对Java栈的操作只有两个：

  - 每个***方法执行***，伴随着**进栈**（入栈、压栈）
  - 执行结束后的**出栈工作**

- 对于栈来说**不存在垃圾回收问题**

  栈不存在GC，存在OOM，会溢出





### 面试题：开发中遇到的异常有哪些



**栈中可能出现的异常**

- Java虚拟机规范允许**==*Java栈的大小是动态的或者是固定不变的*==**
  - 如果采用**固定大小的java虚拟机栈**，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果**线程请求分配的栈容量**超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个`StackOverflowError`异常
  - 如果Java虚拟机栈可以**动态扩展**，并且尝试扩展的时候**无法申请到足够的内存**，或者在创建新的线程时**没有足够的内存区**创建对应的虚拟机栈，那Java虚拟机将会抛出一个 `OutOfMemoryError`异常

```java
public static void main(String[] args) {
    main(args);
}
```

![image-20210320164505903](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320164505903.png)



- **设置栈内存大小**

  是用参数-Xss选项来设置爱线程的最大栈空间，栈的大小直接决定了函数调用的最大深度

![image-20210320164914785](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320164914785.png)



```java
private static int count = 1;
public static void main(String[] args) {
    System.out.println(count++);//默认count=9830
    main(args);
}
```

![image-20210320165200489](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320165200489.png)

修改虚拟机栈的大小：count=2263，设置的栈的大小起作用了

**栈的大小直接决定了函数调用的最大深度！**





### 栈的存储单位



**栈中存储什么？**

- 每个线程都有自己的栈，栈中的数据都是以**栈帧Stack Frame**的格式存在
- 这个线程上正在执行的**每个方法都各自对应一个栈帧**，**==方法和栈帧一一对应==**
- 栈帧就是一个**内存区块**，是一个**数据集**，维系着方法**执行过程中**的各种数据信息

> 类，对象
>
> field（属性、字段、域），method（方法）

- JVM直接对Java栈的操作只有两个，就是对栈帧的 **压栈 & 出栈**，FIFO原则
- 在**一条活动线程**中，一个时间点上，只会有**一个活动的栈帧**。即当前在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为 **当前栈帧Current Frame**，与当前栈帧对应的是当前方法Current Method，定义这个方法的类就是 **当前类Current Class**
- 执行引擎运行的所有字节码指令**只针对当前栈帧进行操作**

- 如果在该方法中**调用了其他方法**，对应的新的栈帧就会被其创建出来，放在栈的顶端，成为新的栈帧

![image-20210320170059505](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320170059505.png)

> Debug左侧显示的Frames就是栈帧结构显示
>
> ![image-20210320170834142](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320170834142.png)





- 不同线程中所包含的栈帧是**不允许存在相互引用**的，即不可能在一个栈帧之中引用**另一个线程**的栈帧，**相互隔离！**
- 如果当前方法调用了其他方法，方法返回之际，**==当前栈帧会传回此方法的执行结果给前一个栈帧==**，接着，虚拟机会**丢弃**当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式，
  - **一种是正常的函数返回，使用return指令**
  - **另一种是抛出异常Throw Exception(不是try-catch)，不管使用哪种方式，都会导致栈帧被弹出**，把异常抛给上一层的栈帧，看能不能处理？继续往上抛.....

> 返回值void写return也没问题，因为方法返回的指令最后都会有return，不过是可以省略







### 栈帧的内部结构

 

**每个栈帧**中存储着：

- **局部变量表Local Variables**
- **操作数栈Operand Stack 或表达式栈**

- 动态链接Dynamic Linking（或指向运行时常量池的方法引用）
- 方法返回地址Return Address 或方法正常退出或者异常退出的定义
- 一些附加信息



![image-20210320181056054](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320181056054.png)





![image-20210320181851764](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320181851764.png)



### 局部变量表



Local Variables



局部变量数组/本地变量表

- **定义为一个==数字数组==，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括八种基本类型数据，对象引用reference，以及returnAddress类型
- 由于局部边来那个表是建立在线程的栈上，是线程的**私有数据**，因此**不存在数据安全问题**
- **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximum local variables数据项中，在方法运行期间是不会改变局部变量表的大小的

↓

这个容量指的就是最大容量，编译的时候确定了**有几个变量**。局部变量表的大小就为这个值。并且在运行时不会改变

![image-20210320182800335](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320182800335.png)

![image-20210320182807852](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320182807852.png)



<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320183226961.png" alt="image-20210320183226961" style="zoom:150%;" />



- **方法嵌套调用的次数由栈的大小决定。**一般来说，**栈越大，方法掐按套调用次数越多**。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀。它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。今儿函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少
- **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成  参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁。局部变量表也会随之销毁**



代码中的行号和字节码指令的行号对应

![image-20210320194445112](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194445112.png)

局部变量表：

![image-20210320194620054](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194620054.png)

![image-20210320194641417](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194641417.png)

![image-20210320194705460](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320194705460.png)

每个变量都有相应的索引

Start PC：字节码指令的行号

Length：当前变量作用域范围->长度范围，声明完后就可以用了





#### 关于Slot的理解

- 参数值的存放总是在局部变量数组的index0开始 ，到length-1结束
- **局部变量表，最基本的存储单元就是Slot（变量槽）**
- 局部边来那个表中存放编译器可知的各种基本数据类型（8种），引用类型和returnAddress类型的变量
- 在局部变量表里，**32位以内的类型只占用一个slot，包括引用和returnAddress，64位（long&double都是8个字节 8*8）占用两个slot **
  - byte、short、char转换为int

- JVM会为局部变量表中的每一个Slot分配一个**访问索引**，通过这个索引即可成功访问到局部变量表中指定的局部变量值，long和double使用他们的**起始索引，即前一个索引**
- 当一个实例方法被调用的时候，它的方法参数和方法体内定义的局部变量将会 **按照顺序被赋值**到局部便能量表中的每一个slot上
- 如果当前帧是由构造方法或者实例方法创建的，那么 **该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列**



构造方法：

![image-20210320201303871](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201303871.png)

如果是在构造器中对类变量进行赋值，那么不会在lv中保存，因为都是属于this实例的值，局部变量表中放入一个this就够了

静态方法：

```java
public static void test(){
    int i = 1;
    int j = 2;
}
```

![image-20210320201712970](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201712970.png)

非静态方法：

```java
public void test(){
    int i = 1;
    int j = 2;
}
```

![image-20210320201745604](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320201745604.png)

说明如果不是static方法，那么在该方法栈帧的局部变量表中，一定是有this这个变量的，才可以调用。**在static方法中就无法使用this，因为局部变量表中没有！**



```java
public void test(){
    long i = 1;
    double j = 2.55;
}
```

![image-20210320202848079](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320202848079.png)

this引用使用一个槽，**long和double各用两个槽**



---



**Slot的重复利用**



**栈帧中的局部变量表中的槽位是可以重用的**，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会**复用**过期局部变量的槽位，从而 **达到节省资源的目的**

![image-20210320203702951](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203702951.png)

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203747030.png" alt="image-20210320203747030" style="zoom:150%;" />

**重复利用**，数组的这个位置已经开辟了，不能浪费，查看是否有变量在该变量声明之前过期了，如果有，就直接使用那个变量的槽位

![image-20210320203813288](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320203813288.png)

```java
public void test(){
    int x = 1;
    {
        long i = 1;
    }
    int y = 2;
}
```

![image-20210320204131679](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320204131679.png)

this+x+y+long = 5 但由于long过期了，y使用了slot的槽位

![image-20210320205336743](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320205336743.png)



---



**静态变量与局部变量的对比**



> 变量分类：
>
> - 数据类型：基本数据类型 & 引用数据类型
>
> - 按照在类中声明的位置：成员变量（类变量  & 实例变量(归具体的实例所有) ）  &  局部变量
>   - 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并默认赋值
>   - **成员变量在使用前，都经历过初始化默认值**，**linking的prepare阶段**，给类变量默认赋值零值，initialization给类变量显式赋值以及静态代码块赋值
>   - 局部变量：在使用前**必须要显式赋值**。否则编译不通过
>     - 每一个方法都有一个栈帧，其中的局部变量表保存局部变量，不会有默认赋值，必须要显式赋值



- 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配
- **准备阶段，执行系统初始化，对类变量设置零值，初始化阶段，赋予静态变量初始值和静态代码快中的初始值**
- 局部变量表不存在系统初始化的过程，一旦定义了局部变量则必须人为的初始化，否则无法使用



---

**补充说明：**

- 在栈帧中，与**性能调优**关系最为密切的部分就是前面提到的**局部变量表**。在方法执行时，虚拟机使用**局部变量表**完成**方法的传递**

  

- **局部变量表中的变量也是重要的垃圾回收    根节点，只要被局部变量表中直接或间接引用的对象都    不会被回收**







### 操作数栈



Operand Stack



> 栈：可以使用数组，链表来实现



- 每一个独立的栈帧中，除了包含局部变量表意外，还包含一个操作数栈，也可以称之为表达式栈
- **操作数栈，再方法执行的过程中，根据字节码指令，可以往栈中写入数据或提取数据，即入栈出栈**
  - 某些字节码指令将值**压入**操作数栈，其余的字节码指令将操作数**取出栈**。使用它们后把结果压入栈 
  - 比如：执行复制、交换、求和等操作
- **这个过程需要根据字节码指令来进行从操作**

![image-20210320213854275](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320213854275.png)



![image-20210320214147145](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320214147145.png)



- 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量   ->  临时的存储空间**

- 操作数栈就是JVM执行引擎的一个工作去，当一个方法刚开始执行的时候，一个新的栈帧也会随着被创建出来，**这个方法的操作数栈是空的**  --->  但其实是有空间的，只是没有值，数组一旦确定，长度是确定的！

- 每一个操作数栈都会拥有一个**明确的栈深度用于存储数值（编译期）**，其所需的**最大深度在编译期就定义好了**，保存咋地方法的Code属性中，为max_stack值

  ![image-20210320214511808](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320214511808.png)

- 栈中任何一个元素都是可以任意的Java数据类型：

  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用2个栈单位深度

- 操作数栈 **并非采用访问缩印的女方是来进行数据访问的**，而是只能通过标准的入栈/出栈曹总来完成一次数据访问



- **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新**PC寄存器**中**下一条**需要执行的字节码指令

![image-20210320223916346](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320223916346.png)

​	**iload压入操作栈**

**aload_0 获取上一个栈帧返回的结果，并保存在操作数栈上**

> .aload_0是装载第一个(0)局部变量引用的对象

​	![image-20210320224117168](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320224117168.png)





- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
- java虚拟机 **解释引擎是基于栈的执行引擎**





### 代码追踪

```java
public test() {
    byte i = 15;
    int j = 8;
    int k = i + j;
}
```

解析class文件：

![image-20210320221007882](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320221007882.png)

> JVM中 int 类型数值，根据 取值范围将 入栈的 **字节码指令** 就分为4类：
>
> 取值 **-1~5** 采用 `iconst` 指令；
>
> 取值 **-128~127** 采用 `bipush` 指令； byte 2 int
>
> 取值 **-32768~32767** 采用 `sipush`指令； short 2 int
>
> 取值 **-2147483648~2147483647** 采用 `ldc` 指令。
>
> i2l：Convert `int` to `long`





```
 0 bipush 15  # 压入操作数栈中
 2 istore_1   # 从操作数栈中取出值15，压入局部变量表中。局部变量表0位置放的是this引用
 3 bipush 8
 5 istore_2   # ..
 6 iload_1 	  # 在局部变量表中把1和2的位置的数据依次取出
 7 iload_2
 8 iadd
 9 istore_3
10 return
```

istore操作使操作数栈中的数弹出并放入局部变量表中

**每进行一次操作，PC寄存器都会调整**

![image-20210320222648067](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320222648067.png)



iload：将局部变量表中的数压入操作数栈中，

![image-20210320222831550](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320222831550.png)

iadd

![image-20210320223012477](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320223012477.png)

再存储到局部变量表中



**操作数栈自始至终用两个空间就够了！**







### i++和++i的区别



```
int i1 = 10;i1++;
int i2 = 10;++i2;
这两个是一样的
-------------------------

int i3 = 10;
int i4 = i3++;

int i5 = 10;
int i6 = ++i5;

-------------------------

int i7 = 10;
i7 = i7++;

int i8 = 10;
i8 = ++i8;


-------------------------

int i9 = 10;
int i10 = i9++ + ++i9;

```





```
 0 bipush 10
 2 istore_1
 3 iinc 1 by 1
 6 bipush 10
 8 istore_2
 9 iinc 2 by 1
 ----------------------
12 bipush 10
14 istore_3
15 iload_3
16 iinc 3 by 1
19 istore 4

21 bipush 10
23 istore 5
25 iinc 5 by 1
28 iload 5
30 istore 6
---------------------------
32 bipush 10
34 istore 7
36 iload 7
38 iinc 7 by 1  #对局部变量表中的数+1，然后放回去的是没+1的数
41 istore 7

43 bipush 10
45 istore 8
47 iinc 8 by 1
50 iload 8
52 istore 8
---------------------------
54 bipush 10
56 istore 9
58 iload 9
60 iinc 9 by 1
63 iinc 9 by 1
66 iload 9
68 iadd
69 istore 10
71 return

```





### 栈顶缓存



Top-of-Stack Caching



基于栈式架构的虚拟机所使用的的**零地址指令**更加紧凑，但完成一项操作的时候必要需要使用更多的入栈和出栈指令，这通水也就意味着将需要更多的指令分派次数和内存读写次数



由于操作数是存储在内存中的，会因此频繁的执行内存读写操作必然会影响执行速度。为了解决这个问题，JVM的设计者们提出了栈顶缓存技术，**将   栈顶元素  全部缓存在==物理CPU的寄存器==中，以此降低对内存的读写次数，提升执行引擎的执行效率**







### 动态链接

**指向运行时常量池的方法引用**

Dynamic Linking

帧数据区：一些附加信息+动态链接+方法返回地址



- 一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。

- 每一个栈帧内部都包含指向 **运行时常量池**中   **==该栈帧所需 方法的引用，其实就是指向运行时常量池的方法引用==**。包含这个引用的目的就是为了支持当前方法的代码能够实现 **动态链接**。比如：invokedynamic指令

- 在Java源文件被编译到字节码文件中时，==**所有的变量和方法引用**都作为**符号引用保存在class文件的常量池里**==。比如：描述一个方法调用另外的方法时，就是通过常量池中指向方法的符号引用来表示的，**那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**



![image-20210320234339008](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234339008.png)



完整类名、名字、描述符。

![image-20210320234354501](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234354501.png)



![image-20210320234406910](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210320234406910.png)





栈帧中存储的地址->运行时常量池中这个方法的引用

Current Class Constant Pool

![image-20210321000915057](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321000915057.png)

只要用到了这个方法，那么就直接指向运行时常量池中的这个方法地址来进行调用！



![image-20210321002749115](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321002749115.png)



![image-20210321002806814](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321002806814.png)







---



为什么需要常量池呢？

字节码文件需要很多文件、数据的支持。

提供一些符号和常量，便于指令的识别





### 方法的调用



在JVM中，将**符号引用**（#7、#8.....）转换为调用方法的**直接引用**与方法的绑定机制相关。



- **静态链接**

  当一个字节码文件被装载进JVM内部时，如果被调用的 **目标方法在编译期可知，**且**运行期保持不变**时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

- **动态链接**

  **如果被调用的方法在编译器无法被确定下来**，也就是说，只能够在**程序运行期将调用方法的符号引用转换为直接引用**，由于这种引用转换过程具备**动态性**，因此被称为动态链接



----



对应的方法的绑定机制为 早起绑定、晚期绑定。

**绑定是一个字段、方法或者类在   ==符号引用被替换为直接引用==   的过程，这仅仅发生一次**

- **早期绑定**

  被调用的目标方法如果在**编译期可知**，且**运行期保持不变**，将这个方法与所属的类型进行绑定。明确了被调用的目标方法究竟是哪一个，可以使用静态链接的方式将**符号引用转化为直接引用。**

  如：this(),super()

- **晚期绑定**

  **如果被调用的方法在编译器无法被确定下来**，**只能够在程序==运行期==根据 ==实际的类型== 绑定相关的方法**



----

**封装、继承、多态。具备多态特性，那么自然也就具备早起绑定和晚期绑定两种绑定方式**

Java中任何一个普通的方法都具备虚函数的特征——>**运行期才能确定**。在Java中不希望某个方法拥有虚函数的特征时，可以使用**关键字final**来标记这个方法，就不能进行重写了！





---



**非虚方法：**

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，称为非虚方法
- **静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法**，
  - 静态方法、私有方法、**final方法**都不能被重写
    - final方法如果在父类中定义过，那么子类中不能出现与父类的final方法签名（方法名+参数）相同的final方法，会被视为重写，**而final方法不允许重写**
  - 实例构造器`this()`，通过重载已经确定调用哪一个构造器。而且构造器也不能被重写
  - 父类方法，`super()，super.xxx()`，也很确定，可以直接绑定
- 其他方法称为虚方法





虚拟机中提供了几条方法调用指令：

普通调用指令：

1. **invokestatic：调用静态方法，解析阶段确定唯一方法版本**
2. **invokespecial：调用 `<init>`方法、私有及父类方法，解析阶段确定唯一方法版本**
3. invokevirtual：调用所有虚方法（final方法除外）
4. invokeinterface：调用接口方法->肯定是进行重写的方法

动态调用指令：

5. invokedynamic：动态解析出需要调用的方法，然后执行
   - 支持由用户胡确定方法版本

1，2调用的方法称为非虚方法，再加一个invokevirtual调用的final方法



- 注意：子类中调用父类中的final方法，如果不加super.showFinal()，会使用 `invokevirtual`指令来调用，**但实际也是调用的父类的final方法，因为final方法不允许重写**。如果加了`super.`那么就使用 `invokespecial`指令，这个方法是确定的，所以final方法也是虚方法
- 如果在子类中调用父类的**普通方法并且没有重写**，不显式加`super.`  使用指令`invokevirtual`，编译期间无法确定是否有重写，虚方法！



---

关于invokedynamic指令

- JVM字节码指令集一直比较稳定，jdk7中增加了invokedynamic指令，这是 **java为了实现【动态类型语言】支持而做的一种改进**
- jdk7中需要借助ASM这种底层字节码工具来产生invokedynamic指令。jdk8的Lambda表达式的出现，invokedynamic指令的生成在java中才有了直接的生成方式
- java7中增加的动态语言类型支持的本质是**对java虚拟机规范的修改**，而不是对java语言规则的修改。增加了虚拟机中的方法调用



---

动态类型语言 和 静态类型语言

区别在于对**类型的检查**是在编译器还是在运行期，满足前者就是静态类型语言，反之是动态类型语言

java是静态类型语言，必须制定类型int/String/double/......

js：var name="...";  var name = 10;所有的变量都叫var

python：info = 130.99; info = "xxx";

- **静态类型语言是判断==变量==自身的类型信息**

- **动态类型语言是判断==变量值==的类型信息，变量没有类型信息，变量值才有类型信息**



```java
public class lambdaTest {
    public void lambda(Func func){
        return;
    }

    public static void main(String[] args) {
        lambdaTest labmdaTest = new lambdaTest();
        Func func = str -> {
            return true;
        };
        labmdaTest.lambda(func);
        labmdaTest.lambda(s -> {
            return true;
        });
    }
}
interface Func{
    public boolean func(String str);
}
```

` invokedynamic #4 <func, BootstrapMethods #0>`

在编译期并不知道是继承/实现谁的对象，只有在运行期才能确定下来是Func接口的实现类，根据对象的值来确定





---



Java语言中方法重写的本质：

1. 找到**操作数栈顶**的第一个元素所执行的**对象的实际类型**，记作  C
2. 如果在类型 C 中找到与常量中**描述符  简单名称都相符**的方法，则进行**访问权限校验**，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError` 异常
3. 否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
4. 如果最终没有找到合适的方法，则抛出 `java.lang.AbstractMethodError`异常



`java.lang.IllegalAccessError` ：

程序视图访问或修改一个属性或调用一个方法，这个属性或方法你**没有权限访问**。

一般会引起编译器异常，这个错误如果发生在运行时，说明一个类发生了不兼容的改变->maven jar包冲突





---

**虚方法表**

- 频繁的使用到动态分派，每次动态分派的过程中都要重新在类的方法**元数据**中搜索合适的目标的话就可能影响到执行效率。**为了提高性能，jvm采用在类的方法区建立一个虚方法表来实现。使用索引表来代替查找**

- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
- 什么时候被创建？
  - 在类加载的链接阶段（**解析阶段：将常量池内的符号引用转换为直接引用**）被创建并开始初始化，类的变量初始化准备完成之后，jvm会把该类

栗子：

![image-20210321125217469](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125217469.png)

直接将Son中的toString()指向Object中的方法，而不会往上层去查找



栗子：

![image-20210321125413756](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125413756.png)



![image-20210321125545726](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125545726.png)





![image-20210321125901481](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321125901481.png)





![image-20210321130117470](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321130117470.png)





### 方法返回地址



Return Address



- 存放调用该方法的pc寄存器的值
- 一个方法的结束，有两种方式：
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种方式退出，在方法退出后都**返回到该方法被调用的位置**。方法正常退出时，**==调用者的PC计数器的值作为返回地址==，即调用该方法的指令的==下一条指令的地址==**。而通过异常退出的，返回地址是要通过**异常表**来确定，栈帧中一般不会保存这部分信息



方法的退出就是当前栈帧出栈的过程，需要**恢复上层方法的局部变量表、操作数栈、==将返回值压入调用者栈帧的操作数栈==、==设置PC寄存器值==**等，让调用者方法**继续执行下去**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321131225375.png" alt="image-20210321131225375" style="zoom:150%;" />



**异常完成出口退出的不会给他的上层调用者产生任何的返回值**





---



一个方法开始执行后，只有两种方式可以退出这个方法：

1. 执行引擎遇到任意一个方法返回的字节码指令return，会有返回值传递给上层的方法调用者，**正常完成出口**

   - ireturn/lreturn/freturn/dreturn/areturn（引用类型）/return(void，实例初始化方法，类和接口的初始化方法)

2. 遇到了异常，并且这个异常没有在方法内进行处理，在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。**异常完成出口**

   抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码

![image-20210321134220154](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134220154.png)



![image-20210321134625057](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134625057.png)

指令索引4-9间   出现异常就跳转到指令12进行catch处理，然后goto 17继续执行程序

![image-20210321134630982](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134630982.png)

![image-20210321134640762](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321134640762.png)







### 一些附加信息



栈帧中还允许携带与java虚拟机实现相关的一些附加信息。如：对程序调试提供支持的信息





### 栈的相关面试题



- 距离栈溢出的情况？StackOverflowError
  - 通过-Xss来设置栈的大小，但还是会出现 OOM
- 调整栈的大小，就能保证不出现溢出吗？ 
  - 只要递归够深，栈帧够大，肯定可以溢出~~
- 分配的栈内存越大越好吗？
  - 延缓StackOverflowError时间，但无法彻底避免
  - 占用其他线程空间/其他区域空间，
- 垃圾回收是否会涉及到虚拟机栈？
  - 不会。只是出栈入栈，不需要垃圾回收
- 方法中定义的局部变量是否线程安全？
  - 具体问题具体分析
  - 

> 线程安全？
>
> 只有一个线程才可以操作此数据，则肯定是线程安全的
>
> 如果有多个线程操作此数据，则此数据是 共享数据，如果不考虑同步机制的话，会存在线程安全问题。

**局部变量不会存在线程不安全的问题，其他变量无法访问到**

![image-20210321142036549](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142036549.png)



----

变量不归当前方法所有，多个线程都可以调用这个方法来对该变量进行操作，就是线程不安全的

![image-20210321142316902](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142316902.png)

![image-20210321142510261](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142510261.png)



---

针对s1的操作是线程不安全的（**间接不安全**），返回以后可能会被其他的多个线程获取到进行操作，进而导致线程不安全

![image-20210321142557192](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142557192.png)

 

> **将局部变量封闭在方法内，不要传出去。。。。是最安全的**

---

**因为String的值在初始化的时候确定（final），无法进行改变，只能读取。s1是线程安全的，其实String也是线程安全的**

![image-20210321142804178](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321142804178.png)





运行时数据区各部分：

|            | Error   | GC     |
| ---------- | ------- | ------ |
| 程序计数器 | 不存在  | 不存在 |
| 虚拟机栈   | 存在    | 不存在 |
| 本地方法栈 | 存在    | 不存在 |
| 方法区     | 存在OOM | 存在   |
| 堆         | 存在OOM | 存在GC |







## 本地方法接口



![image-20210321150310455](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321150310455.png)



本地方法：

一个 Native方法就是一个Java调用非java代码的接口。该方法的实现由非java语言实现，比如C，这

在定义一个native Method时，并不提供实现体，因为其实现体是由非java语言在外面实现的

本地接口的作用是融合不同的编程语言为java所用，融合C/C++程序

```java
public final native Class<?> getClass();
```





**native和abstract是不共用**的。native是有方法体！

**native可以和权限public/private ，static ，synchronized 等配合使用。**



---



**为什么要使用native Method？**

有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了

- **与java环境外交互**

  **有时java应用需要与java应用外面的环境交互，这是本地方法存在的主要原因。**java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。使我们无需去了解java应用之外的繁琐的细节。

- **与操作系统交互**

  jvm不是一个完整的系统，经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。**使用本地方法，我们得以用java实现了jre的底层系统的交互，甚至ijvm的一些部分就是用c写的。**使用一些java语言本身没有提供封装的操作系统的特性时，也需要使用本地方法

- **Sun's Java**

  **Sun的解释器使用C实现的，使得它能像一些普通的C一样与外部交互**。jre大部分是用java实现的，也通过一些本地方法与外界交互。比如start0(), setPriority0()方法，被植入JVM内部，由java方法来进行调用，最终进行调用操作系统的API。这个方法的具体实现由JVM提供，更多的情况是本地方法由**外部的动态链接库**提供，然后被JVM调用





**目前该方法的而是用越来越少了，除非是与硬件有关的应用**，比如通过java程序驱动打印机或者java系统管理生产设备....





## 本地方法栈



![image-20210321152451743](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321152451743.png)



- **Java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用。**

- 本地方法栈，也是线程私有的
- 允许被是线程固定或者是可动态扩展的内存大小（和jvm栈一样。。内存溢出方面也相同）
  - StackOverflowError
  - OOM Error
- 本地方法是使用C语言实现的
- 具体做法是 Native Method Stack中登记native方法，在Execution Engine执行引擎执行时加载本地方法库



![image-20210321152846425](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321152846425.png)



- **当某个线程调用一个本地方法时，它就进入了一个全新的并且==不再受虚拟机限制==的世界，*它和虚拟机拥有同样的权限***
  - 本地方法可以通过**本地方法接口**来访问**虚拟机内部的运行时数据区，堆/方法区/.....**
  - 它甚至可以**直接**使用***本地处理器中的寄存器 -> cpu寄存器***
  - 直接存**本地内存 -> 物理内存**的堆中分配任意数量的内存



- **并不是所有的JVM都支持本地方法。因为java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等**。如果jvm产品不打算支持native方法，也可以无需实现本地方法栈
- 在HotSpot JVM中，直接将**本地方法栈和虚拟机栈合二为一**
  - 调用java方法中，内部调用了本地方法，本地方法栈使用动态链接指向本地方法，由执行引擎执行













## 堆



### 堆的核心概述



方法区和堆对于一个进程（JVM实例）来说是唯一的。可被多个线程共享。



- 一个**JVM实例只存在一个堆内存（不同的java进程，即每一个main方法）**，堆也是java内存管理的核心区域
- java堆区在jvm启动的时候即被创建，其**空间大小**也就确定了。是jvm管理的最大一块内存
  - ***堆内存的大小是可以调节的***
  - -Xms10m  -Xmx10m
- 堆可以处于物理上**不连续的内存空间**中，但在**逻辑上**它应该被视为连续的
- **所有的线程共享java堆**，在这里还可以划分**线程私有的缓冲区**（**Thread Loacl Allocation Buffer  ——>  TLAB**）共享内存，线程安全问题，并发性很差。每个线程私有缓冲区，不需要考虑线程安全，并发性更好。

- **所有的对象实例以技术组都应当在运行时分配在堆上**
  - **几乎**所有的对象都在这里分配内存——实际使用角度....
- 数组和对象**可能永远都不会存储在栈上**，因为***栈帧中保存引用***，这个引用**指向**对象或者数组在***堆中的位置***
- 在方法结束后，没有引用指向堆中的对象，但堆中的**对象不会马上被移除**，仅仅在**垃圾收集的时候才会被移除**
  - 减少垃圾回收线程执行的频率
- 堆，是GC（Garbage  Collection，垃圾收集器）**执行垃圾回收的重点区域**，回收对象、数组

- 创建对象的指令：new newarray，anewarray，创建对象，开辟空间



工具jvisualvm.exe：

![image-20210321160706866](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321160706866.png)

相加是设置的堆内存空间



栈中变量指向堆中实例，实例来调用方法区中的方法。

![image-20210321170339618](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170339618.png)



---

**堆的核心概述：内存细分**

**现代垃圾收集器大部分是基于分代收集理论设计，堆空间细分为**



![image-20210321170532129](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170532129.png)



![image-20210321170713334](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321170713334.png)



----

设置堆空间为10M，设置的参数只负责新生代和老年代，**不负责元空间的大小**

![image-20210321171816078](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321171816078.png)





![image-20210321171959684](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321171959684.png)



---

jdk8中为元空间：

`-XX:+PrintGCDetails`

![image-20210321172202663](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321172202663.png)



修改为jdk7版本：

永久代

![image-20210321172411632](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321172411632.png)









### 设置堆内存大小与OOM



- java堆区用于cunchujava对象实例，那么堆的大小在jvm启动时就已经设定好了，可以通过选项：-Xmx和-Xms来进行设置
  - -Xms用于表示堆区（年轻代+老年代）的**起始内存**，等价于-XX:InitialHeapSize
    - -X: jvm的运行参数
    - ms：memory start
  - -Xmx用于表示堆区的**最大内存**，等价于-XX:MaxHeapSize



- 一旦堆区的内存大小超过-Xmx所指定的最大内存时，将会抛出OutOfMemoryError异常
- 通常会将-Xms和-Xmx两个参数配置相同的值，**其目的是为了能够在java垃圾回收**



- **默认**情况下，初始内存大小：物理电脑内存大小 / 64; 最大内存大小：物理内存大小 / 4

![image-20210321173040544](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321173040544.png)



```java
public static void main(String[] args) throws InterruptedException {

    long totalMemory = Runtime.getRuntime().totalMemory()/1024/1024;
    long maxMemory = Runtime.getRuntime().maxMemory()/1024/1024;

    System.out.println(totalMemory + "    " + maxMemory);
    System.out.println("系统内存大小："+totalMemory * 64.0 / 1024 + "G");
    System.out.println("系统内存大小："+maxMemory * 4.0 / 1024.0 + "G");

}
```

![image-20210321173627585](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321173627585.png)

**开发中建议将初始堆内存和最大的堆内存设置成相同的值，频繁扩容和释放消耗资源。**



手动设置时，也会比实际设置的值要小一点

`-Xmx600m -Xms600m`

实际打印：`575    575`

  

---



**查看设置的参数**：

（或者直接使用jvisual来看  或者 `-XX:+PrintGCDetails`）

![image-20210321174438815](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321174438815.png)

![image-20210321174425741](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321174425741.png)

```
25600 * 2 + 153600 + 409600  /  1024 = 600

25600 + 153600 + 409600  /  1024 = 575
```

????

伊甸园区+survivor区两个区只有一个区能使用。始终有一个survivor空间是空的。





-----



OOM：

![image-20210321175656555](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321175656555.png)

广义上的异常，`Error&Exception extends Throwable`

```java
List<String> list = new ArrayList<>();
while (true){
    list.add(new String("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"));
}
```

![image-20210321175616109](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321175616109.png)

看到溢出原因

![image-20210321180447859](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180447859.png)













### 年轻代与老年代



- 存储在JVM中的java对象可以被划分为两类
  - 一类是生命周期较短的顺势对象，这类对象的创建和消亡都非常迅速！
  - 另外一类对象的生命周期缺非常长，在某些极端的情况下还能够与jvm的生命周期保持一致
- Java堆区进一步细分的话，可以划分为年轻代YoungGen和老年代OldGen
- 其中**年轻代又可以划分为Eden空间(java最先创建的位置)、Survivor0空间和Survivor1空间**（from区、to区）

![image-20210321180926805](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180926805.png)



下面这参数开发中一般不会调：

![image-20210321180954210](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321180954210.png)



- 配置新生代与老年代在堆结构的占比
  - -XX:NewRatio=2，表示新生代占1/3，老年代占2/3

- **如果生命周期长的对象多，将老年代调大一些**



- 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8:1:1

- 通过  -XX:SurvivorRatio=?  具体调整比例
- 但实际并不是8   1:1:7  
- **自适应机制**
- -XX:-UseAdaptiveSizePolicy关闭自适应内存分配策略。暂时没有用。。。 



- **几乎所有的java对象都是在Eden区被new出来的**
- 绝大部分的java对象的销毁都在新生代进行了
  - 新生代80%的对象都是"朝生夕死"的
- 可以使用选项-Xmn来设置新生代最大内存大小
  - 一般使用默认值



![image-20210321191620860](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321191620860.png)















### 对象分配过程



对象分配过程：

1. new的对象**先放在伊甸园区**，此区有大小限制
2. 当伊甸园的空间填满时，程序又需要创建对象，jvm的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC/Young GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到伊甸园区
3. 然后将伊甸园区中的**剩余对象移动到幸存者0区**
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的对象，如果没有被回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区
6. 什么时候能去养老区呢？可以设置次数。默认是15次
   - **设置参数：`-XX:MaxTenuringThreshold=<N>`**
7. 在养老区，相对悠闲，当养老区内存不足时，再次触发GC，Major GC，进行养老区的内存清理
8. 若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生**OOM异常**



**幸存者区满了不会触发YGC，当Eden区满了后，YGC会将幸存者区和Eden区一起进行回收。被动回收**





红色的对象是被垃圾回收掉的

每一次垃圾回收都倒一下S0、S1中对象的位置

![image-20210321192654404](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321192654404.png)

---

- **针对幸存者s0，s1区的总结：复制之后有交换，谁空谁就是to(另一个是from)**

- **关于垃圾回收：频繁在新生区收集垃圾，很少在养老区收集，几乎不在永久区/元空间收集**



----

特殊情况：

YGC之后伊甸园区一定是空的

Eden放不下，一步到位，放到老年代。。。

Full GC老年代垃圾回收

**总之：放不下就放到老年代中。**

<img src="../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321194355936.png" alt="image-20210321194355936" style="zoom:150%;" />



![image-20210321200900344](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321200900344.png)

老年代满了——> OOM





### 常用调优工具



- jdk命令行
- Eclipse：Memory Analyzer Tool
- Jconsole
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy







### Minor GC、Major GC、Full GC



JVm再进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代

针对HotSpot VM，里面的GC按照回收区域又分为两大种类型：部分收集Partial GC，整堆收集Full GC



- 部分收集：不是完整收集整个java堆的垃圾收集
  - 新生代收集（Minor GC / Young GC），只是新生代的垃圾收集
  - 老年代收集（Major GC / Old GC），**只是老年代的垃圾收集**
    - 目前，只有**CMS GC**会有单独收集老年代的行为
    - **很多时候Major GC会和 Full GC混淆使用需要具体分辨是老年代回收还是整堆回收**
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    - 目前，只有**G1 GC**会有这种行为
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集







----



**年轻代GC触发机制**

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会触发GC，而每次Minor GC满会清理年轻代的内存
- 因为java对象大多都具备朝生夕死的特性，所以Minor GC；非常频繁，一般回收速度也比较快

- **Minor GC会引发STW（stop the word），暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行**

![image-20210321204631767](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321204631767.png)





---

**老年代GC（Major/ Full GC）触发机制**

- 指发生在老年代的GC，对象从老年代消失时，这两个GC会被触发
- 出现了Major GC 经常会伴随至少一次的MinorGC  (非绝对的，在Parallel Scavenge收集器的收集策略里有直接进行Major GC的策略选择过程)
  - 老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC
- **Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长** 
  - **调优：减少Major GC的次数**
- 如果Major GC后，内存还不足，就报OOM了



---

**Full GC触发机制**

1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor、space0区向survivor space1区复制时，对象大小大于To Space可用内存，则吧该对象转存到老年代，且老年代的可用内存小于该对象大小



**Full GC是开发或调优中尽量要避免的，这样暂停的时间会短一些。**

----

栗子：

```java
List<String> list = new ArrayList<>();
String a = "hcrhcrhcr";
while (true){
    list.add(a);
    a = a + a;
}
```



```
[GC (Allocation Failure) [PSYoungGen: 2017K->506K(2560K)] 2017K->830K(9728K), 0.0033778 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2078K->512K(2560K)] 2402K->1986K(9728K), 0.0005180 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2317K->480K(2560K)] 7247K->6027K(9728K), 0.0007253 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 480K->512K(2560K)] 6027K->6075K(9728K), 0.0005772 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 512K->0K(2560K)] [ParOldGen: 5563K->4129K(7168K)] 6075K->4129K(9728K), [Metaspace: 3316K->3316K(1056768K)], 0.0044339 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[GC (Allocation Failure) [PSYoungGen: 39K->32K(2560K)] 6472K->6465K(9728K), 0.0003212 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

[Full GC (Ergonomics) [PSYoungGen: 32K->0K(2560K)] [ParOldGen: 6433K->5281K(7168K)] 6465K->5281K(9728K), [Metaspace: 3316K->3316K(1056768K)], 0.0032575 secs] [Times: user=0.16 sys=0.00, real=0.00 secs] 


[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 5281K->5281K(8704K), 0.0006357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] [ParOldGen: 5281K->5259K(7168K)] 5281K->5259K(8704K), [Metaspace: 3316K->3316K(1056768K)], 0.0066352 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 


Heap
 PSYoungGen      total 1536K, used 70K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 1024K, 6% used [0x00000000ffd00000,0x00000000ffd118e0,0x00000000ffe00000)
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 7168K, used 5259K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb22e18,0x00000000ffd00000)
 Metaspace       used 3348K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 363K, capacity 388K, committed 512K, reserved 1048576K
```

老年代逐渐变大，当Full GC后还没有剩余空间的时候，就OOM了

**元空间没有改变**

```
[GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] 5281K->5281K(8704K), 0.0006357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 

[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(1536K)] [ParOldGen: 5281K->5259K(7168K)] 5281K->5259K(8704K), [Metaspace: 3316K->3316K(1056768K)], 0.0066352 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
```

**字符串越来越大，最后直接就放不下了  先进性YGC，再进行一次Full GC 还是装不下啊！——> OOM**









### 堆空间分代思想



***为什么需要把Java堆分代？不分代就不能正常工作了吗？***



- 不同对象的生命周期不同，70%-99%的对象是临时对象
- 新生代：有Eden、两块大小相同的Survivor（from/to）构成，to总为空
- 老年代：存放新生代中经历多次GC仍然存活的对象（或者放不下的对象）



- 其实不分代完全可以。**分代的唯一理由就是优化GC性能。**如果没有分代，所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建爱你的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来





![image-20210321211331349](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321211331349.png)









### 内存分配策略



如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设置为1.对象在Survivor区中每经历过一次Minor GC，年龄就+1，当它的年龄增加到一定程度（默认为15，可以设置，每个JVM的每个GC都有所不同）时，就会被晋升为老年代中

对象晋升老年代的年龄阈值，通过选项   `-XX:MaxTenuringThreshold`来设置



---

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- **大对象直接分配到老年代**
  - 尽量避免程序中出现过多的**大对象**——>更糟糕的是都是“朝生夕死”的.........折磨堆
- **长期存活**的对象分配到老年代
- **动态对象年龄判断**
  - 如果Survivor区中**相同年龄**的所有对象大小的综合**大于Survivor空间的一半**，年龄**大于或等于**该年龄的对象可以***直接进入老年代***，**免得两个Survivor来回倒腾**，无须等到MaxTenuringThreshold中要求的年龄

- **空间分配担保**
  - 大量的对象在GC后都还是存活的，把Survivor中无法容纳的放到老年代
  - `-XX:HandlePromotionFailure`





```
-Xmx60m -Xms60m -XX:+PrintGCDetails

byte[] buffer = new byte[1024*1024*20];//20m
```



![image-20210321213343955](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321213343955.png)

***↑ 这里直接放入到老年代中——20m大小***











### 为对象分配内存：TLAB

**线程私有的缓冲区**

**为什么有TLAB（Thread Local Allocation Buffer）**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在**并发环境**下从堆区中划分内存空间是**线程不安全**的
- 为避免多个线程操作同一地址，需要使用加锁等级制，进而影响分配速度执行效率



----

**什么是TLAB？**

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为 **每个线程分配了一个私有缓存区域，它包含在Eden空间内**

- 多线程同时分配内存时，使用TLAB**可以避免一系列的线程安全问题** ，同时还能够**提升内存分配的吞吐量**，因此我们可以将这种内存分配方式称之为 **快速分配策略**

- 所有Openjdk衍生出来的JVM都提供了TLAB的设计



![image-20210321213831842](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321213831842.png)



- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
- 可以通过选项  `-XX:UseTLAB`设置是否开启TLAB空间。**默认开启**
  - `jinfo -flag UseTLAB port`
-  默认TLAB占用的空间非常小，**仅占有整个Eden区的1%**，可以通过 `-XX:TLABWasteTargetPercent`设置TLAB空间所占用Eden恐案件的百分比大小
- 一旦对象在TLAB空间分配失败时，JVM就会尝试着通过 **使用加锁机制（在Eden区域）** 确保数据操作的原子性，从而**直接在Eden空间中分配内存**



![对象分配过程：TLAB](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321214439882.png)











### 小结堆空间的参数设置



















### 堆是分配对象的唯一选择吗？







































































# Tip



## aload_n的解释



<n>必须是当前帧的**局部变量数组的索引**（第2.6节）。 <n>处的局部变量必须包含**一个引用**。 <n>处的局部变量中的objectref被压入操作数堆栈。



![image-20210321132146922](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132146922.png)



string栈帧的局部变量表：

![image-20210321132201032](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132201032.png)

**这里加载局部变量表中索引为0位置的引用：即this，将this加载到操作数堆栈中，再对这个this方法调用本地的虚方法，将方法的返回值x存储到局部变量表中**



main栈帧的局部变量表：

![image-20210321132717373](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132717373.png)

![image-20210321132305846](../picture/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20210321132305846.png)

**如果是static方法，那么就不需要通过this引用实例  来进行调用，直接调用常量池中的引用即可。再将返回值引用保存到局部变量表中**

但接下来调用string()方法，就需要使用到局部变量表中索引为1的实例，aload_1将其加载进操作数栈，然后调用-保存。































































































