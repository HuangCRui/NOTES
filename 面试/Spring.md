

# 控制反转和依赖注入







## IOC是什么



Inversion of Control，“控制反转”，**是一种设计思想**。Ioc意味着将设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

> “谁控制谁？控制什么？为何是反转（反转/正转）？哪些方面反转了？”



- 谁控制谁，控制什么？

  传统Java SE程序设计，我们直接在对象内部***通过new进行创建对象***，是程序***主动去创建依赖对象***；而***IoC是有专门一个容器来创建这些对象***，即**由Ioc容器来控制对象的创建**；谁控制谁？当然是**IoC 容器控制了对象**；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。



- 为何是反转，哪些方面反转了

  有反转就有正转，传统应用程序是由我们自己在对象中主动控制去**直接获取依赖对象**，也就是正转；而反转则是由***<u>容器来帮忙创建及注入依赖对象</u>***；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是***被动的接受依赖对象***，所以是反转；哪些方面反转了？***依赖对象的获取被反转了。***

  - 传统程序设计，都是**主动去创建相关对象然后再组合起来**
  - 当有了IoC/DI的容器后，在客户端类中**不再主动去创建这些对象了**，只需要声明出来即可





Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring**你是个什么东西，你需要什么东西**，然后spring会在系统运行到适当的时候，**把你要的东西主动给你**，同时也**把你交给其他需要你的东西**。**所有的类的创建、销毁都由 spring来控制**，也就是说**控制对象生存周期**的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是***所有对象都被spring控制***，所以这叫控制反转。



## IoC能做什么





IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出***松耦合***、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致***类与类之间高耦合***，难于测试；有了IoC容器后，把**创建和查找依赖对象的控制权交给了容器**，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。

其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，**要获取什么资源都是主动出击**，但是在IoC/DI思想中，应用程序就变成被动的了，***被动的等待IoC容器来创建并注入它所需要的资源了。***

IoC很好的体现了面向对象设计法则之一  ——  好莱坞法则：“别找我们，我们找你”；即由**IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。**





## IoC和DI



DI—Dependency Injection，即“依赖注入”：**组件之间依赖关系**由容器在***运行期***  决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可**指定目标需要的资源**，**完成自身的业务逻辑**，而不需要关心具体的资源来自何处，由谁实现。

理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：

●谁依赖于谁：当然是**应用程序依赖于IoC容器**；

●为什么需要依赖：应用程序需要IoC容器来**提供对象需要的外部资源**；

●谁注入谁：很明显是**IoC容器注入应用程序某个对象**，应用程序依赖的对象；

●注入了什么：就是注入某个对象**所需要的外部资源**（包括**对象、资源、常量数据）。**





IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，***至于这个Connection怎么构造，何时构造，A不需要知道 (已经构造完成并注入到了ioc容器中)***。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是**反射**（reflection），它允许程序在***运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。***





IoC和DI是什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了***<u>“被注入对象依赖 IoC 容器配置依赖对象”</u>***







## 耦合关系



在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起。

简单来说，耦合可以理解为：在需要对B中的构造等进行修改时，需要对每个依赖了B对象的地方进行修改，每个new B(... , ... , ... , ...)的地方都需要修改，具有**高耦合**



而使用了Spring之后就不一样了，**创建合作对象B的工作是由Spring来做的**，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，**A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)**，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。



**创建对象的控制权进行转移**，这样**一堆类之间的繁杂依赖关系就没了**，它们都依赖IoC容器了，**通过IoC容器来建立它们之间的关系**







控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，**业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的**。在使用控制反转的情况下，**业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化**，这种实现方式还可以将对象之间的关联关系的***定义抽象化***。而绑定的过程是通过“依赖注入”实现的。

控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。

依赖注入是在***编译阶段尚未知所需的功能是来自哪个的类***  的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础（当前类需要被）。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？

在Java中依赖注入有以下三种实现方式：

1. 构造器注入
2. Setter方法注入
3. 接口注入





































































































































































































































































































































































































































